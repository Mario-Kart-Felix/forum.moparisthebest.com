<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>My OCR</title>
    <link>https://forum.moparisthebest.com/t/my-ocr/426924</link>
    <description>First off a few things. It&#39;s made in C# (burn me at stake), it should translate pretty smoothly to Java. It doesn&#39;t go under client hacking, but there&#39;s a bunch of other shit here that doesn&#39;t.

The concept - [i]Identifier[/i] is used to find an unique set of points in the point array of each character, that won&#39;t be found in any of the arrays of the other characters of the same font. What you would do is e.g feed Simba/SCAR&#39;s font files to some sort of a program that&#39;ll parse out the mask, find the unique arrays and save them to a text file paired with the corresponding letter.

[i]Finder[/i] will split a provided point array of the assumed text into sections (vertical splits, you&#39;re assumed to input a single line), and then match a letter of the instance&#39;s font with the point array of each section. Spaces work (sort of?) by counting empty lines between characters, if the count is greater than the provided min spacing, the gap is a space. This is useful for only scenarios like RuneScape or other computer generated text that is not meant to be challenging to read. I made this because I think using neural networks and all sorts of shit for RuneScape is stupid, where the fonts are constant and you do not have to attempt to recognize prior unseen text. I&#39;m probably going to try to come up with one of those standalone autofighters (or miners, or whatever) (hopefully a non-shit one) that the scene was floating with a few years back.

Credits for the Combination class which is basically responsible for creating each possible combination of an array&#39;s elements go to some dude on daniweb.

Identifier -

Points.cs

[code=csharp]/*
 * Created by SharpDevelop.
 * User: Owner
 * Date: 12/21/2011
 * Time: 1:41 AM
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Collections.Generic;

namespace Identifier
{
	/// &lt;summary&gt;
	/// Description of Points.
	/// &lt;/summary&gt;
	public static class Points
	{
		private static bool ContainsPoint(Point p, Point[] pts)
		{
			foreach (Point pp in pts)
			{
				if (pp.Equals(p))
					return true;
			}
			return false;
		}
		
		public static Point[] FindUniqueSet(Point[] arr, Point[][] total, int max)
		{
			for (int i = 2; i &lt; max; i++)
			{
				Combination&lt;Point&gt; c = new Combination&lt;Point&gt;(arr, i);
				foreach (Point[] pts in c)
				{
					foreach (Point[] t in total)
					{
						Boolean success = true;
						foreach (Point p in pts)
						{
							if (ContainsPoint(p, t))
							{
								success = false;
								break;
							}
						}
						if (success)
							return pts;
					}
				}
			}
			return new Point[] {};
		}
		
		private static Point[] Crop(Point[] p) 
		{
			int minX = p[0].X;
			int minY = p[0].Y;
			foreach (Point point in p)
			{
				if (point.X &lt; minX)
					minX = point.X;
				if (point.Y &lt; minY)
					minY = point.Y;
			}
			List&lt;Point&gt; n = new List&lt;Point&gt;();
			foreach (Point point in p)
			{
				n.Add(new Point(point.X - minX, point.Y - minY));
			}
			return n.ToArray();
		}
	}
}[/code]

Combination.cs

[code=csharp]/*
 * Created by SharpDevelop.
 * User: Owner
 * Date: 12/21/2011
 * Time: 12:45 AM
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections;

namespace Identifier {
    /// &lt;summary&gt;
    /// Class to generate all the combinations of an array of objects. This code
    /// is released under the GPL v3 license with the aditional restriction that
    /// any use in a public product requires notification of the author.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;The type of objects&lt;/typeparam&gt;
    public class Combination&lt;T&gt; : IEnumerable, IEnumerator {
        private T[] items;
        private int atATime;
        private int current = -1;
        private long count;

        /// &lt;summary&gt;
        /// Constructor for the Combination class
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;list&quot;&gt;Array of objects used to build combinations&lt;/param&gt;
        /// &lt;param name=&quot;n&quot;&gt;Number of items in each combination&lt;/param&gt;
        public Combination(T[] list, int n) {
            this.items = list;
            this.atATime = n;
            this.count = Choose(this.items.Length, this.atATime);
        }

        /// &lt;summary&gt;
        /// Gets the specific lexical combination. Note that combinations are numbered from 0 to NumberOfCombinations - 1
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;n&quot;&gt;Lexical combination to return&lt;/param&gt;
        /// &lt;returns&gt;Array containing the nth lexical combination&lt;/returns&gt;
        public T[] GetCombination(long n) {
            if (n &gt;= count) {
                throw new ArgumentOutOfRangeException(String.Format(&quot;Requested combination ({0}) exceeds number of combinations ({1})&quot;, n, count));
            }

            T[] result = new T[this.atATime];
            int[] ans = new int[this.atATime];

            int a = this.items.Length;
            int b = this.atATime;
            long x = (Choose(a, b) - 1) - n;

            for (int i = 0; i &lt; this.atATime; i++) {
                ans[i] = LargestV(a, b, x);
                x -= Choose(ans[i], b);
                a = ans[i];
                b--;
            }

            for (int i = 0; i &lt; this.atATime; i++) {
                result[i] = items[items.Length - 1 - ans[i]];
            }

            return result;
        }

        /// &lt;summary&gt;
        /// Number of combinations for this specific set of objects and grouping size
        /// &lt;/summary&gt;
        public long NumberOfCombinations {
            get {
                return count;
            }
        }

        /// &lt;summary&gt;
        /// Method to allow indexing into combinations. 
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;n&quot;&gt;Lexical combination to return&lt;/param&gt;
        /// &lt;returns&gt;Array containing the nth lexical combination&lt;/returns&gt;
        public T[] this[int n] {
            get {
                return GetCombination(n);
            }
        }

        // The next two methods are used to calculate the combinadic. See
        // Wikipedia article at http://en.wikipedia.org/wiki/Combinatorial_number_system
        // and the 2006 MSDN Article &quot;Test Run&quot; by Dr. James McCaffrey
        private int LargestV(int a, int b, long x) {
            int v = a - 1;
            while (Choose(v, b) &gt; x) {
                v--;
            }
            return v;
        }

        private long Choose(int n, int k) {
            long result = 0;
            int delta;
            int max;

            if (n &lt; 0 || k &lt; 0) {
                throw new ArgumentOutOfRangeException(&quot;Invalid negative parameter in Choose()&quot;);
            }
            if (n &lt; k) {
                result = 0;
            } else if (n == k) {
                result = 1;
            } else {
                if (k &lt; n - k) {
                    delta = n - k;
                    max = k;
                } else {
                    delta = k;
                    max = n - k;
                }
                result = delta + 1;
                for (int i = 2; i &lt;= max; i++) {
                    checked {
                        result = (result * (delta + i)) / i;
                    }
                }
            }

            return result;
        }

        #region IEnumerator &amp; IEnumerable methods
        IEnumerator IEnumerable.GetEnumerator() {
            return this;
        }

        object IEnumerator.Current {
            get {
                return GetCombination(current);
            }
        }

        bool IEnumerator.MoveNext() {
            current++;
            return (current &lt; count);
        }

        void IEnumerator.Reset() {
            current = -1;
        }
        #endregion
    }
}
[/code]


Finder -

CR.cs

[code=csharp]/*
 * Created by SharpDevelop.
 * User: Owner
 * Date: 12/21/2011
 * Time: 9:05 PM
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */

using System;
using System.Diagnostics;
using System.Drawing;
using System.Collections.Generic;

namespace Finder
{
	public class CR
	{
		
		private List&lt;List&lt;Point&gt;&gt; pts;
		private string[] chars;
		private int spacing;
		
		public CR(Point[][] idPts, string[] characters, int spacing)
		{
			this.pts = new List&lt;List&lt;Point&gt;&gt;();
			foreach (Point[] x in idPts)
				this.pts.Add(new List&lt;Point&gt;(x));
			this.chars = characters;
			this.spacing = spacing;
		}
		
		public string PointsToText(Point[] textPoints)
		{
			if (textPoints.Length &lt; 1 || chars.Length &lt; 1)
				return &quot;&quot;;
			string n = &quot;&quot;;
			List&lt;List&lt;Point&gt;&gt; split = Split(textPoints, spacing);
			foreach (List&lt;Point&gt; pp in split)
			{
				List&lt;Point&gt; lp = new List&lt;Point&gt;(Crop(pp.ToArray()));
				if (lp.Count == 0)
				{
					n += &quot;[]&quot;;
				} else
				{
					for (int i = 0; i &lt; pts.Count; i++)
					{
						bool d = false;
						foreach (Point rP in lp)
						{
							bool b = true;
							foreach (Point nP in pts[i])
							{
								if (!ContainsPoint(new Point(nP.X + rP.X, nP.Y + rP.Y), lp.ToArray()))
								{
									b = false;
									break;
								}
							}
							if (b)
							{
								n += chars[i];
								d = true;
								break;
							}
						}
						if (d)
							break;
					}
				}
			}
			return n;
		}
		
		private Point[] Crop(Point[] p)
		{
			if (p.Length &lt; 1)
				return new Point[] {};
			int minX = p[0].X;
			int minY = p[0].Y;
			foreach (Point point in p)
			{
				if (point.X &lt; minX)
					minX = point.X;
				if (point.Y &lt; minY)
					minY = point.Y;
			}
			List&lt;Point&gt; n = new List&lt;Point&gt;();
			foreach (Point point in p)
			{
				n.Add(new Point(point.X - minX, point.Y - minY));
			}
			return n.ToArray();
		}
		
		private int GetWidth(Point[] pts)
		{
			Point[] n = Crop(pts);
			int max = 0;
			foreach (Point p in n)
			{
				if (p.X &gt; max)
					max = p.X;
			}
			return max;
		}
		
		private int GetHeight(Point[] pts)
		{
			Point[] n = Crop(pts);
			int max = 0;
			foreach (Point p in n)
			{
				if (p.Y &gt; max)
					max = p.Y;
			}
			return max;
		}
		
		private bool ContainsPoint(Point p, Point[] pts)
		{
			foreach (Point pp in pts)
			{
				if (pp.Equals(p))
					return true;
			}
			return false;
		}
		
		public List&lt;List&lt;Point&gt;&gt; Split(Point[] pts, int minSpaceWidth)
		{
			List&lt;List&lt;Point&gt;&gt; chars = new List&lt;List&lt;Point&gt;&gt;();
			int width = GetWidth(pts) + 1;
			int height = GetHeight(pts) + 1;
			Point[] n = Crop(pts);
			List&lt;Point&gt; p = new List&lt;Point&gt;();
			int empties = 0;;
			for (int x = 0; x &lt; width; x++)
			{
				int count = 0;
				for (int y = 0; y &lt; height; y++)
				{
					if (ContainsPoint(new Point(x, y), n))
					{
						p.Add(new Point(x, y));
						count++;
					}
				}
				if (count != 0)
					empties = 0;
				if (count == 0)
				{
					empties++;
				}
				if (empties == 1 || empties == minSpaceWidth)
				{
					chars.Add(p);
					p = new List&lt;Point&gt;();
					if (empties == minSpaceWidth)
						empties = 0;
				}
				if (x + 1 == width)
				{
					chars.Add(p);
				}
				
			}
			return chars;
		}
	}
}

[/code]


Program.cs - A small example

[code=csharp]/*
 * Created by SharpDevelop.
 * User: Owner
 * Date: 12/21/2011
 * Time: 8:51 PM
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;

namespace Finder
{
	class Program
	{
		public static void Main(string[] args)
		{
			// In this example a square is shown as [], because counting spaces is superhuman.
			Point[] pts = new Point[] {new Point(5, 4), new Point(6, 4), new Point(7, 4), new Point(8, 4), new Point(17, 4), new Point(18, 4), new Point(7, 5), new Point(9, 5), new Point(17, 5), new Point(18, 5)};
			Point[] v = new Point[] {new Point(0, 0), new Point(2, 0), new Point(1, 1)}; //a crude letter &quot;v&quot;.
			Point[] s = new Point[] {new Point(0, 0), new Point(1, 0), new Point(0, 1), new Point(1, 1)}; // s for square
			CR cr = new CR(new Point[][] {v, s}, new string[] {&quot;v&quot;, &quot;s&quot;}, 4);
			string str = cr.PointsToText(pts);
			Console.WriteLine(str);
			Console.ReadKey(true);
		}
	}[/code]</description>
    
    <lastBuildDate>Tue, 14 Feb 2012 21:28:00 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/my-ocr/426924.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@n3ss3s n3ss3s]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/n3ss3s">@n3ss3s</a> wrote:</p>
          <blockquote>
              <p>Alright, back when I posted this there were some logical issues that prevented it from working in a real scenario (it did not search for the characters in the mandatory order and it didn’t ignore already sorted letters)</p>
<p>In general gedfbhjkmnpaqrsBvDwxyzAEutFGHJKLMN3245890OPQRSTUVWXYZ6Coc71lIi is the order you must look for the characters in. Special characters - not sure, you can slap most of them in the end (e.g, &amp; and % obviously don’t fit in any of the previous characters).</p>
<p>Code for finding the combination of unique points in a single array, in respect to a bunch of arrays. (In our context, finding the combinations of points in a letter than will not be found in any other letter for the font.)</p>
<p><a href="http://pastie.org/3376848" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/3376848</a></p>
<p>Code for creating array combinations, Randy</p>
<p><a href="http://pastie.org/3376854" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/3376854</a></p>
<p>Example code where I feed it the UpCharsEx font bundled with Simba</p>
<p><a href="http://pastie.org/3376859" rel="nofollow noopener">http://pastie.org/3376859</a> (Pastie doesn’t seem to like “”'s)</p>
<p>Code for recognizing a group of points in a line of points (splitting input up into e.g 12 points high segments is the user’s job)</p>
<p><a href="http://pastie.org/3376868" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/3376868</a></p>
<p>A working sample code ([] = space)</p>
<p><a href="http://pastie.org/3376881" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/3376881</a></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/13</link>
        <pubDate>Tue, 14 Feb 2012 21:28:00 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-13</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@Fsig Fsig]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/fsig">@Fsig</a> wrote:</p>
          <blockquote>
              <p>Yeah it entirely depends on the size of the area you are checking and the amount of letters in that area.</p>
<p>For eg in the video you will see I am getting around 70-90ms on my POS dual core.</p>
<p>Edit: And the area it was checking was 300x20<br>
Also found I was still debugging so that included saving the image as well. But like I said really depends on the size you are checking etc… even if you have more programs running in the background that will slow you down.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/12</link>
        <pubDate>Wed, 04 Jan 2012 02:28:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-12</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@n3ss3s n3ss3s]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/n3ss3s">@n3ss3s</a> wrote:</p>
          <blockquote>
              <p>Have you done any speed tests with how you currently have it, I’m wondering if it’s even worth it checking for e.g 5 instead of 20 points speedwise… (I couldn’t give a fuck less if reading the uptext takes 30 instead of 20 ms)</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/11</link>
        <pubDate>Wed, 04 Jan 2012 00:45:19 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-11</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@Fsig Fsig]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/fsig">@Fsig</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="9" data-topic="426924">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/n3ss3s/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> n3ss3s:</div>
<blockquote>
<p>Thing is, I used a few small handmade point arrays to test it, no fuckups, then I fed it the UpCharsEx font from Simba and got a bunch of dupes so there’s got to be something wrong… (Well, the main thing wrong in the posted code is that it thinks it found a unique combo after checking one array in the Point[][] to be searched, but I fixed that and still got issues)</p>
</blockquote>
</aside>
<p>This is what I am doing.</p>
<p>Works just fine, just need to finish getting the rest of the letters.<br>
Video of it in action: [youtube]<a href="http://www.youtube.com/watch?v=S1uMVlwuM5c%5B/youtube%5D" rel="nofollow noopener">http://www.youtube.com/watch?v=S1uMVlwuM5c[/youtube]</a></p>
<pre><code class="lang-auto">package org.core.ocr;

import java.awt.Color;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;

import org.core.ColourBot;
import org.core.ImageUtils;
import org.core.V;
import org.gui.GUI;

/**
 * 
 * @author Fsig
 * 
 * Testing OCR.
 * Of sorts...
 * 
 * I will try to make a array of images which will
 * be compared to the captured area of the screen.
 * 
 * If a certain image fits then the images ID or string
 * etc will be added to the return array.
 * 
 * Possibly add tolerance to allow for the font changes.
 * 
 * If this works we will be able to get a array of strings
 * or id's back to correspond to letters.
 * 
 * If we get this far we can then use the matched point of
 * each letter to calculate which order they are in.
 *
 */
public class OCR extends ImageUtils{
	private static int count = 26;
	private static BufferedImage[] tt = new BufferedImage[count];
	private static BufferedImage[] ttC = new BufferedImage[count];
	
	private static Point[] pArray = new Point[count];
	private static int[] sArray = new int[count];
	private static int[] cArray = new int[count];
	private static String[] lArray = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"};
	private static String[] lArrayC = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"};
	
	private static int removeMe = 0;
	
	static int cRmin = 0;
	static int cGmin = 0;
	static int cBmin = 0;
	static int cRmax = 0;
	static int cGmax = 0;
	static int cBmax = 0;
	
	/**
	 * Load all our default letters.
	 */
	public static void loadLetters(){
		for(int i = 0; i &lt; count; i++){
			tt[i] = loadImage("org/scapegoat/images/tt/" + i + ".png");
			ttC[i] = loadImage("org/scapegoat/images/ttCap/" + i + ".png");
		}
	}
	
	/**
	 * Check the letters within a certain rectangle.
	 * 
	 * @param r
	 * @throws InterruptedException
	 */
	public static String checkLetters(Rectangle r, int tolerance) throws InterruptedException{
		BufferedImage src = ColourBot.capture(r);
		int count = 0;
		
		for(int i = 0; i &lt; tt.length; i++){
			Point p = FindImage(src,tt[i],new Color(255,0,255),tolerance);
			
			if(p != null){
				GUI.log("Found!: " + p + " letter: " + i);
				pArray[count] = p;
				sArray[count] = i;
				cArray[count] = -1;
				count++;
			}
			
		}
		
		for(int i = 0; i &lt; ttC.length; i++){
			Point p = FindImage(src,ttC[i],new Color(255,0,255),tolerance);
			
			if(p != null){
				GUI.log("Found!: " + p + "  cap letter: " + i);
				pArray[count] = p;
				sArray[count] = i;
				cArray[count] = i;
				count++;
			}
			
		}
		
		//We have all the letters now lets put them in order and make real words.
		return sortArrays();
	}
	
	/**
	 * This will sort our arrays into the correct order
	 * and return the letters.
	 * 
	 * @return String
	 */
	public static String sortArrays(){
		String yourWord = "";
		
		for(int i = 0; i &lt; sArray.length; i++){
			String s = getClosest(pArray);
			if(s != null){
				yourWord += s;
				pArray[removeMe] = null;
			}
		}
		
		return yourWord;
	}
	
	/**
	 * This will return the closest letter going
	 * by the points.
	 * 
	 * @param p
	 * @return String
	 */
	public static String getClosest(Point[] p){
		String closest = "";
		int nearest = 9999;
		
		for(int i = 0; i &lt; p.length; i++){
			if(p[i] != null &amp;&amp; p[i].distance(new Point(V.getPlayArea().x, V.getPlayArea().y)) &lt; nearest){
				nearest = (int) p[i].distance(new Point(V.getPlayArea().x, V.getPlayArea().y));
				if(cArray[i] != -1)
					closest = lArrayC[cArray[i]];
				else
					closest = lArray[sArray[i]];
				removeMe = i;
			}
		}
		
		return closest;
	}
	
	/**
	 * Attempt to find a letter within a image
	 * 
	 * @param src
	 * @param toFind
	 * @param text
	 * @return
	 * @throws InterruptedException
	 */
	public static Point FindImage(BufferedImage src, BufferedImage toFind, Color text1, int tolerance) throws InterruptedException {
		if(src == null || toFind == null){
			return null;
		}
		
		for(int y = 0; y &lt;= (src.getHeight() - toFind.getHeight()) - 1; y++) {
			for(int x = 0; x &lt;= (src.getWidth() - toFind.getWidth()) - 1; x++) {
				if(compareImage(src, toFind, x, y, text1, tolerance))
					return new Point((int)V.getScreenArea().getX() + x, (int)V.getScreenArea().getY() + y);
			}
		}

		return null;
	}
	
	/**
	 * Compare the images and return true or false.
	 * 
	 * @param src
	 * @param toFind
	 * @param x
	 * @param y
	 * @param text
	 * @return boolean
	 */
	public static boolean compareImage(BufferedImage src, BufferedImage toFind, int x, int y, Color background, int tolerance) {
		int sclr = 0;
		int fclr = 0;
		for(int y2 = 0; y2 &lt;= toFind.getHeight() -1; y2++) {
			for(int x2 = 0; x2 &lt;= toFind.getWidth() -1; x2++) {
				fclr = toFind.getRGB(x2, y2);
				Color c = new Color(fclr);
				
				if(fclr != background.getRGB()) {
					cRmin = c.getRed() - tolerance;
					cGmin = c.getGreen() - tolerance;
					cBmin = c.getBlue() - tolerance;
					cRmax = c.getRed() + tolerance;
					cGmax = c.getGreen() + tolerance;
					cBmax = c.getBlue() + tolerance;
					
					sclr = src.getRGB(x + x2, y + y2);
					Color cc = new Color(sclr);
					if(cc.getRed() &gt;= cRmin &amp;&amp; cc.getRed() &lt;= cRmax &amp;&amp; cc.getGreen() &gt;= cGmin &amp;&amp; cc.getGreen() &lt;= cGmax &amp;&amp; cc.getBlue() &gt;= cBmin &amp;&amp; cc.getBlue() &lt;= cBmax){
						//Colour matches
					}else{
						return false;
					}
				}else{
					sclr = src.getRGB(x + x2, y + y2);
					Color cc = new Color(sclr);
					if(cc.getRed() &gt;= cRmin &amp;&amp; cc.getRed() &lt;= cRmax &amp;&amp; cc.getGreen() &gt;= cGmin &amp;&amp; cc.getGreen() &lt;= cGmax &amp;&amp; cc.getBlue() &gt;= cBmin &amp;&amp; cc.getBlue() &lt;= cBmax){
						return false;
					}else{
						//Colour doesn't match, no wrong letters ;)
					}
				}
			}
		}
		return true;
	}

}</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/10</link>
        <pubDate>Tue, 03 Jan 2012 12:42:02 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-10</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@n3ss3s n3ss3s]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/n3ss3s">@n3ss3s</a> wrote:</p>
          <blockquote>
              <p>Thing is, I used a few small handmade point arrays to test it, no fuckups, then I fed it the UpCharsEx font from Simba and got a bunch of dupes so there’s got to be something wrong… (Well, the main thing wrong in the posted code is that it thinks it found a unique combo after checking one array in the Point[][] to be searched, but I fixed that and still got issues)</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/9</link>
        <pubDate>Tue, 03 Jan 2012 07:35:32 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-9</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@Ollie Ollie]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ollie">@Ollie</a> wrote:</p>
          <blockquote>
              <p>sorry, must have been high posting that without reading  <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"> sorry</p>
<p>have you tried splitting up the characters and then converting each character into black &amp; white and getting a white pixel count and match it using kNN?</p>
<p>it seems pretty accurate for me</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/8</link>
        <pubDate>Mon, 02 Jan 2012 09:00:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-8</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@n3ss3s n3ss3s]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/n3ss3s">@n3ss3s</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="6" data-topic="426924">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/ollie/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> Ollie:</div>
<blockquote>
<p>maybe find unique control points to search</p>
</blockquote>
</aside>
<p>That’s exactly what the posted code does, but now I’m suspecting a fuckup in FindUniquePoints…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/7</link>
        <pubDate>Sun, 01 Jan 2012 21:44:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-7</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@Ollie Ollie]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ollie">@Ollie</a> wrote:</p>
          <blockquote>
              <p>maybe find unique control points to search</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/6</link>
        <pubDate>Sun, 01 Jan 2012 11:55:59 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-6</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@n3ss3s n3ss3s]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/n3ss3s">@n3ss3s</a> wrote:</p>
          <blockquote>
              <p>I’m going to have it start searching from most points to least points, so if it’s not d, it’ll check if it’s o, if it’s c, if it’s i etc… Also you can do exclusion by the area the letter takes up…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/5</link>
        <pubDate>Sun, 01 Jan 2012 09:10:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-5</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@Fsig Fsig]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/fsig">@Fsig</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="3" data-topic="426924">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/n3ss3s/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> n3ss3s:</div>
<blockquote>
<p>Well, if there’s no reflection you gotta read dem textz somehow… Btw I’m suspecting a fuckup in FindUniquePoints, gives me duplicates. I’m just gonna use the full points of the characters for finding shit rather than trying to do tricks with 2-3 pt arrays…</p>
</blockquote>
</aside>
<p>I think you may run into a issue I currently have.</p>
<p>Some letters fit into other letters…<br>
For eg: c,o,i and l all fit into d.</p>
<p>So not only will you have to check the points of the letter but check some points around the letter as well to confirm it is the correct letter you are finding.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/4</link>
        <pubDate>Sun, 01 Jan 2012 08:37:19 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-4</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@n3ss3s n3ss3s]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/n3ss3s">@n3ss3s</a> wrote:</p>
          <blockquote>
              <p>Well, if there’s no reflection you gotta read dem textz somehow… Btw I’m suspecting a fuckup in FindUniquePoints, gives me duplicates. I’m just gonna use the full points of the characters for finding shit rather than trying to do tricks with 2-3 pt arrays…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/3</link>
        <pubDate>Sun, 01 Jan 2012 07:44:38 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-3</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@Pwnd Pwnd]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/pwnd">@Pwnd</a> wrote:</p>
          <blockquote>
              <p>For some reason people are caring less for OCR</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/2</link>
        <pubDate>Sat, 31 Dec 2011 07:57:33 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-2</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
      <item>
        <title>My OCR</title>
        <dc:creator><![CDATA[@n3ss3s n3ss3s]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/n3ss3s">@n3ss3s</a> wrote:</p>
          <blockquote>
              <p>First off a few things. It’s made in C# (burn me at stake), it should translate pretty smoothly to Java. It doesn’t go under client hacking, but there’s a bunch of other shit here that doesn’t.</p>
<p>The concept - <span class="bbcode-i">Identifier</span> is used to find an unique set of points in the point array of each character, that won’t be found in any of the arrays of the other characters of the same font. What you would do is e.g feed Simba/SCAR’s font files to some sort of a program that’ll parse out the mask, find the unique arrays and save them to a text file paired with the corresponding letter.</p>
<p><span class="bbcode-i">Finder</span> will split a provided point array of the assumed text into sections (vertical splits, you’re assumed to input a single line), and then match a letter of the instance’s font with the point array of each section. Spaces work (sort of?) by counting empty lines between characters, if the count is greater than the provided min spacing, the gap is a space. This is useful for only scenarios like RuneScape or other computer generated text that is not meant to be challenging to read. I made this because I think using neural networks and all sorts of shit for RuneScape is stupid, where the fonts are constant and you do not have to attempt to recognize prior unseen text. I’m probably going to try to come up with one of those standalone autofighters (or miners, or whatever) (hopefully a non-shit one) that the scene was floating with a few years back.</p>
<p>Credits for the Combination class which is basically responsible for creating each possible combination of an array’s elements go to some dude on daniweb.</p>
<p>Identifier -</p>
<p>Points.cs</p>
<p>[code=csharp]/*</p>
<ul>
<li>Created by SharpDevelop.</li>
<li>User: Owner</li>
<li>Date: 12/21/2011</li>
<li>Time: 1:41 AM</li>
<li>
</li>
<li>To change this template use Tools | Options | Coding | Edit Standard Headers.<br>
*/<br>
using System;<br>
using System.Drawing;<br>
using System.Collections.Generic;</li>
</ul>
<p>namespace Identifier<br>
{<br>
/// <summary><br>
/// Description of Points.<br>
/// </summary><br>
public static class Points<br>
{<br>
private static bool ContainsPoint(Point p, Point[] pts)<br>
{<br>
foreach (Point pp in pts)<br>
{<br>
if (pp.Equals§)<br>
return true;<br>
}<br>
return false;<br>
}</p>
<pre><code>	public static Point[] FindUniqueSet(Point[] arr, Point[][] total, int max)
	{
		for (int i = 2; i &lt; max; i++)
		{
			Combination&lt;Point&gt; c = new Combination&lt;Point&gt;(arr, i);
			foreach (Point[] pts in c)
			{
				foreach (Point[] t in total)
				{
					Boolean success = true;
					foreach (Point p in pts)
					{
						if (ContainsPoint(p, t))
						{
							success = false;
							break;
						}
					}
					if (success)
						return pts;
				}
			}
		}
		return new Point[] {};
	}
	
	private static Point[] Crop(Point[] p) 
	{
		int minX = p[0].X;
		int minY = p[0].Y;
		foreach (Point point in p)
		{
			if (point.X &lt; minX)
				minX = point.X;
			if (point.Y &lt; minY)
				minY = point.Y;
		}
		List&lt;Point&gt; n = new List&lt;Point&gt;();
		foreach (Point point in p)
		{
			n.Add(new Point(point.X - minX, point.Y - minY));
		}
		return n.ToArray();
	}
}
</code></pre>
<p>}[/code]</p>
<p>Combination.cs</p>
<p>[code=csharp]/*</p>
<ul>
<li>Created by SharpDevelop.</li>
<li>User: Owner</li>
<li>Date: 12/21/2011</li>
<li>Time: 12:45 AM</li>
<li>
</li>
<li>To change this template use Tools | Options | Coding | Edit Standard Headers.<br>
*/<br>
using System;<br>
using System.Collections;</li>
</ul>
<p>namespace Identifier {<br>
/// <summary><br>
/// Class to generate all the combinations of an array of objects. This code<br>
/// is released under the GPL v3 license with the aditional restriction that<br>
/// any use in a public product requires notification of the author.<br>
/// </summary><br>
/// The type of objects<br>
public class Combination : IEnumerable, IEnumerator {<br>
private T[] items;<br>
private int atATime;<br>
private int current = -1;<br>
private long count;</p>
<pre><code>    /// &lt;summary&gt;
    /// Constructor for the Combination class
    /// &lt;/summary&gt;
    /// &lt;param name="list"&gt;Array of objects used to build combinations&lt;/param&gt;
    /// &lt;param name="n"&gt;Number of items in each combination&lt;/param&gt;
    public Combination(T[] list, int n) {
        this.items = list;
        this.atATime = n;
        this.count = Choose(this.items.Length, this.atATime);
    }

    /// &lt;summary&gt;
    /// Gets the specific lexical combination. Note that combinations are numbered from 0 to NumberOfCombinations - 1
    /// &lt;/summary&gt;
    /// &lt;param name="n"&gt;Lexical combination to return&lt;/param&gt;
    /// &lt;returns&gt;Array containing the nth lexical combination&lt;/returns&gt;
    public T[] GetCombination(long n) {
        if (n &gt;= count) {
            throw new ArgumentOutOfRangeException(String.Format("Requested combination ({0}) exceeds number of combinations ({1})", n, count));
        }

        T[] result = new T[this.atATime];
        int[] ans = new int[this.atATime];

        int a = this.items.Length;
        int b = this.atATime;
        long x = (Choose(a, b) - 1) - n;

        for (int i = 0; i &lt; this.atATime; i++) {
            ans[i] = LargestV(a, b, x);
            x -= Choose(ans[i], b);
            a = ans[i];
            b--;
        }

        for (int i = 0; i &lt; this.atATime; i++) {
            result[i] = items[items.Length - 1 - ans[i]];
        }

        return result;
    }

    /// &lt;summary&gt;
    /// Number of combinations for this specific set of objects and grouping size
    /// &lt;/summary&gt;
    public long NumberOfCombinations {
        get {
            return count;
        }
    }

    /// &lt;summary&gt;
    /// Method to allow indexing into combinations. 
    /// &lt;/summary&gt;
    /// &lt;param name="n"&gt;Lexical combination to return&lt;/param&gt;
    /// &lt;returns&gt;Array containing the nth lexical combination&lt;/returns&gt;
    public T[] this[int n] {
        get {
            return GetCombination(n);
        }
    }

    // The next two methods are used to calculate the combinadic. See
    // Wikipedia article at http://en.wikipedia.org/wiki/Combinatorial_number_system
    // and the 2006 MSDN Article "Test Run" by Dr. James McCaffrey
    private int LargestV(int a, int b, long x) {
        int v = a - 1;
        while (Choose(v, b) &gt; x) {
            v--;
        }
        return v;
    }

    private long Choose(int n, int k) {
        long result = 0;
        int delta;
        int max;

        if (n &lt; 0 || k &lt; 0) {
            throw new ArgumentOutOfRangeException("Invalid negative parameter in Choose()");
        }
        if (n &lt; k) {
            result = 0;
        } else if (n == k) {
            result = 1;
        } else {
            if (k &lt; n - k) {
                delta = n - k;
                max = k;
            } else {
                delta = k;
                max = n - k;
            }
            result = delta + 1;
            for (int i = 2; i &lt;= max; i++) {
                checked {
                    result = (result * (delta + i)) / i;
                }
            }
        }

        return result;
    }

    #region IEnumerator &amp; IEnumerable methods
    IEnumerator IEnumerable.GetEnumerator() {
        return this;
    }

    object IEnumerator.Current {
        get {
            return GetCombination(current);
        }
    }

    bool IEnumerator.MoveNext() {
        current++;
        return (current &lt; count);
    }

    void IEnumerator.Reset() {
        current = -1;
    }
    #endregion
}
</code></pre>
<p>}<br>
[/code]</p>
<p>Finder -</p>
<p>CR.cs</p>
<p>[code=csharp]/*</p>
<ul>
<li>Created by SharpDevelop.</li>
<li>User: Owner</li>
<li>Date: 12/21/2011</li>
<li>Time: 9:05 PM</li>
<li>
</li>
<li>To change this template use Tools | Options | Coding | Edit Standard Headers.<br>
*/</li>
</ul>
<p>using System;<br>
using System.Diagnostics;<br>
using System.Drawing;<br>
using System.Collections.Generic;</p>
<p>namespace Finder<br>
{<br>
public class CR<br>
{</p>
<pre><code>	private List&lt;List&lt;Point&gt;&gt; pts;
	private string[] chars;
	private int spacing;
	
	public CR(Point[][] idPts, string[] characters, int spacing)
	{
		this.pts = new List&lt;List&lt;Point&gt;&gt;();
		foreach (Point[] x in idPts)
			this.pts.Add(new List&lt;Point&gt;(x));
		this.chars = characters;
		this.spacing = spacing;
	}
	
	public string PointsToText(Point[] textPoints)
	{
		if (textPoints.Length &lt; 1 || chars.Length &lt; 1)
			return "";
		string n = "";
		List&lt;List&lt;Point&gt;&gt; split = Split(textPoints, spacing);
		foreach (List&lt;Point&gt; pp in split)
		{
			List&lt;Point&gt; lp = new List&lt;Point&gt;(Crop(pp.ToArray()));
			if (lp.Count == 0)
			{
				n += "[]";
			} else
			{
				for (int i = 0; i &lt; pts.Count; i++)
				{
					bool d = false;
					foreach (Point rP in lp)
					{
						bool b = true;
						foreach (Point nP in pts[i])
						{
							if (!ContainsPoint(new Point(nP.X + rP.X, nP.Y + rP.Y), lp.ToArray()))
							{
								b = false;
								break;
							}
						}
						if (b)
						{
							n += chars[i];
							d = true;
							break;
						}
					}
					if (d)
						break;
				}
			}
		}
		return n;
	}
	
	private Point[] Crop(Point[] p)
	{
		if (p.Length &lt; 1)
			return new Point[] {};
		int minX = p[0].X;
		int minY = p[0].Y;
		foreach (Point point in p)
		{
			if (point.X &lt; minX)
				minX = point.X;
			if (point.Y &lt; minY)
				minY = point.Y;
		}
		List&lt;Point&gt; n = new List&lt;Point&gt;();
		foreach (Point point in p)
		{
			n.Add(new Point(point.X - minX, point.Y - minY));
		}
		return n.ToArray();
	}
	
	private int GetWidth(Point[] pts)
	{
		Point[] n = Crop(pts);
		int max = 0;
		foreach (Point p in n)
		{
			if (p.X &gt; max)
				max = p.X;
		}
		return max;
	}
	
	private int GetHeight(Point[] pts)
	{
		Point[] n = Crop(pts);
		int max = 0;
		foreach (Point p in n)
		{
			if (p.Y &gt; max)
				max = p.Y;
		}
		return max;
	}
	
	private bool ContainsPoint(Point p, Point[] pts)
	{
		foreach (Point pp in pts)
		{
			if (pp.Equals(p))
				return true;
		}
		return false;
	}
	
	public List&lt;List&lt;Point&gt;&gt; Split(Point[] pts, int minSpaceWidth)
	{
		List&lt;List&lt;Point&gt;&gt; chars = new List&lt;List&lt;Point&gt;&gt;();
		int width = GetWidth(pts) + 1;
		int height = GetHeight(pts) + 1;
		Point[] n = Crop(pts);
		List&lt;Point&gt; p = new List&lt;Point&gt;();
		int empties = 0;;
		for (int x = 0; x &lt; width; x++)
		{
			int count = 0;
			for (int y = 0; y &lt; height; y++)
			{
				if (ContainsPoint(new Point(x, y), n))
				{
					p.Add(new Point(x, y));
					count++;
				}
			}
			if (count != 0)
				empties = 0;
			if (count == 0)
			{
				empties++;
			}
			if (empties == 1 || empties == minSpaceWidth)
			{
				chars.Add(p);
				p = new List&lt;Point&gt;();
				if (empties == minSpaceWidth)
					empties = 0;
			}
			if (x + 1 == width)
			{
				chars.Add(p);
			}
			
		}
		return chars;
	}
}
</code></pre>
<p>}</p>
<p>[/code]</p>
<p>Program.cs - A small example</p>
<p>[code=csharp]/*</p>
<ul>
<li>Created by SharpDevelop.</li>
<li>User: Owner</li>
<li>Date: 12/21/2011</li>
<li>Time: 8:51 PM</li>
<li>
</li>
<li>To change this template use Tools | Options | Coding | Edit Standard Headers.<br>
*/<br>
using System;<br>
using System.Drawing;</li>
</ul>
<p>namespace Finder<br>
{<br>
class Program<br>
{<br>
public static void Main(string[] args)<br>
{<br>
// In this example a square is shown as [], because counting spaces is superhuman.<br>
Point[] pts = new Point[] {new Point(5, 4), new Point(6, 4), new Point(7, 4), new Point(8, 4), new Point(17, 4), new Point(18, 4), new Point(7, 5), new Point(9, 5), new Point(17, 5), new Point(18, 5)};<br>
Point[] v = new Point[] {new Point(0, 0), new Point(2, 0), new Point(1, 1)}; //a crude letter “v”.<br>
Point[] s = new Point[] {new Point(0, 0), new Point(1, 0), new Point(0, 1), new Point(1, 1)}; // s for square<br>
CR cr = new CR(new Point[][] {v, s}, new string[] {“v”, “s”}, 4);<br>
string str = cr.PointsToText(pts);<br>
Console.WriteLine(str);<br>
Console.ReadKey(true);<br>
}<br>
}[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/my-ocr/426924/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/my-ocr/426924/1</link>
        <pubDate>Tue, 27 Dec 2011 09:38:05 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-426924-1</guid>
        <source url="https://forum.moparisthebest.com/t/my-ocr/426924.rss">My OCR</source>
      </item>
  </channel>
</rss>
