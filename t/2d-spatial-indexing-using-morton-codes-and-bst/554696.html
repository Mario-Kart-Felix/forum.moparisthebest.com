<!DOCTYPE html>
<html lang="en-US">
  
<!-- Mirrored from forum.moparisthebest.com/t/2d-spatial-indexing-using-morton-codes-and-bst/554696 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>2D spatial indexing using morton codes and BST - General Programming - moparisthebest.com</title>
    <meta name="description" content="Might be useful for some. 

About a month ago I had to solve an engineering problem where I had to efficiently find elements within a 2D coordinate space. This is the solution I created that followed in the footsteps of &amp;hellip;">
    <meta name="generator" content="Discourse 2.3.2 - https://github.com/discourse/discourse version c587df7e2a03c2962f4c8cefd6f03969bb87d525">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/1/1f0dc167bcf798bdbd70b03bf0fd1bc836e54e1a_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff_2_180x180.png">
<meta name="theme-color" content="#0088cc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="554696.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.moparisthebest.com","potentialAction":{"@type":"SearchAction","target":"https://forum.moparisthebest.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="moparisthebest.com Search">

      <link href="../../stylesheets/desktop_1_ec9f75e3d0b2a904642ce53663991837b70cda3334fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="../../stylesheets/desktop_theme_2_6707e7ee46ac9f2f0510c29ddd10e8f6ce21c1ae34fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;2D spatial indexing using morton codes and BST&#39;" href="554696.rss" />
  <meta property="og:site_name" content="moparisthebest.com" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:url" content="https://forum.moparisthebest.com/t/2d-spatial-indexing-using-morton-codes-and-bst/554696" />
<meta name="twitter:url" content="https://forum.moparisthebest.com/t/2d-spatial-indexing-using-morton-codes-and-bst/554696" />
<meta property="og:title" content="2D spatial indexing using morton codes and BST" />
<meta name="twitter:title" content="2D spatial indexing using morton codes and BST" />
<meta property="og:description" content="Might be useful for some.  About a month ago I had to solve an engineering problem where I had to efficiently find elements within a 2D coordinate space. This is the solution I created that followed in the footsteps of this paper written by Tropf and Herzog located here . Instead of using BIGMIN, and MAX I aggregated pages.  This implementation utilizes TreeMap. Searches over ranges which have absolute coordinates and dimensions that are powers of two are very efficient. Searches over spaces up ..." />
<meta name="twitter:description" content="Might be useful for some.  About a month ago I had to solve an engineering problem where I had to efficiently find elements within a 2D coordinate space. This is the solution I created that followed in the footsteps of this paper written by Tropf and Herzog located here . Instead of using BIGMIN, and MAX I aggregated pages.  This implementation utilizes TreeMap. Searches over ranges which have absolute coordinates and dimensions that are powers of two are very efficient. Searches over spaces up ..." />
<meta property="article:published_time" content="2016-02-11T00:34:42+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html">
          <img src="../../uploads/default/original/2X/3/37bba8fb3bd06c372ab54fa72ec38bf9f8f40b37.gif" alt="moparisthebest.com" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1 class="crawler-topic-title">
  <a href="554696.html">2D spatial indexing using morton codes and BST</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/general-programming.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>General Programming</span>
      </a>
    </div>
</div>





  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/sinisoul.html'><span itemprop='name'>sinisoul</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2016-02-11T00:34:42Z'>
            <time itemprop='dateModified' datetime='2016-08-04T17:50:11Z' class='post-time'>
              August 4, 2016,  5:50pm
            </time>
        <span itemprop='position'>#1</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Might be useful for some.</p>
<p>About a month ago I had to solve an engineering problem where I had to efficiently find elements within a 2D coordinate space. This is the solution I created that followed in the footsteps of this paper written by Tropf and Herzog located <a href="http://www.vision-tools.com/h-tropf/multidimensionalrangequery.pdf" data-bbcode="true" rel="nofollow noopener">here</a> . Instead of using BIGMIN, and MAX I aggregated pages.</p>
<p>This implementation utilizes TreeMap. Searches over ranges which have absolute coordinates and dimensions that are powers of two are very efficient. Searches over spaces up to densities of 5.0 entries/unit yield benchmarks of approximately 1 MS.</p>
<p><a href="https://en.wikipedia.org/wiki/Z-order_curve" data-bbcode="true" rel="nofollow noopener">Z-Order Curves</a></p>
<p>I left out the multimap which stored entities at specific coordinate spaces, you can either use that solution or lookup at those coordinates using the BST.</p>
<p>Another optimization depending on your use may be to use this structure where a lookup is responsible for a certain space so that there are less entries to search through. Although for my situation, it wasn’t much of an issue with the amount of expected entries.</p>
<pre><code class="lang-auto">private TreeMap&lt;Integer, Set&lt;T&gt;&gt; lookup = new TreeMap&lt;&gt;();

public Set&lt;T&gt; get(int x, int z, int width, int length) {
  Set&lt;T&gt; results = new HashSet&lt;&gt;();

  // Calculate the maximum page size of pages that may be contained within the area.
  // This is provided from the rectangle search area. Ceiling of log2(n).
  int maximumPageSizeN = Math.max(log2(width), log2(length));
  searchPages(results, x, z, x + width - 1, z + length - 1,
          x, z, x + width, z + length, maximumPageSizeN);
  return results;
}

private void searchPages(Set&lt;T&gt; results, int searchX, int searchY,
                         int maximumSearchX, int maximumSearchY,
                         int boundsX, int boundsY, int maximumBoundsX, int maximumBoundsY,
                         int pageSizeN) {
  // Search within the pages for the bounded area for the provided size.
  for (int pageX = searchX &gt;&gt; pageSizeN; pageX &lt;= maximumSearchX &gt;&gt; pageSizeN; pageX++) {
    for (int pageY = searchY &gt;&gt; pageSizeN; pageY &lt;= maximumSearchY &gt;&gt; pageSizeN; pageY++) {
      int absolutePageX = pageX &lt;&lt; pageSizeN;
      int absolutePageY = pageY &lt;&lt; pageSizeN;
      int pageSize = 1 &lt;&lt; pageSizeN;

      // Check and see if the specified page is within the boundaries of the area we are
      // searching for. If so then we can assume then that is a partition of the area
      // we are searching through.
      if (isContainedWithin(absolutePageX, absolutePageY,
              absolutePageX + pageSize - 1, absolutePageY + pageSize - 1,
              boundsX, boundsY, maximumBoundsX, maximumBoundsY)) {
        aggregateSubmap(results, absolutePageX, absolutePageY,
                absolutePageX + pageSize - 1, absolutePageY + pageSize - 1);
        continue;
      }

      // Special case for page sizes of a boundary of one:
      // - Check for intersections, intersections can then be divided into special cases depending
      //   on the intersection area.
      // - If the page intersects with the boundary, and it is a partial z-order curve then
      //   query the subset of the elements for the continuity.
      // - If the page is not a partial z-order curve then for each element query the element
      //   at the given coordinates.
      if (pageSizeN == 1) {
        if (isIntersecting(absolutePageX, absolutePageY, absolutePageX + pageSize,
                absolutePageY + pageSize, boundsX, boundsY, maximumBoundsX, maximumBoundsY)) {

          // Case One: Horizontal.
          // Case Two: Vertical.
          // Case Three: Corner.
          if (absolutePageX &gt;= boundsX &amp;&amp; absolutePageX + 1 &lt; maximumBoundsX) {
            if (absolutePageY &lt; boundsY) {
              for (int i = 0; i &lt; 2; i++) {
                results.addAll(getElements(absolutePageX + i, absolutePageY + 1));
              }
            } else {
              for (int i = 0; i &lt; 2; i++) {
                results.addAll(getElements(absolutePageX + i, absolutePageY));
              }
            }
          } else if (absolutePageY &gt;= boundsY &amp;&amp; absolutePageY + 1 &lt; maximumBoundsY) {
            if (absolutePageX &lt; boundsX) {
              for (int i = 0; i &lt; 2; i++) {
                results.addAll(getElements(absolutePageX + 1, absolutePageY + i));
              }
            } else {
              for (int i = 0; i &lt; 2; i++) {
                results.addAll(getElements(absolutePageX, absolutePageY + i));
              }
            }
          } else {
            // Left quadrant/Right quadrant.
            if (absolutePageX &lt; boundsX) {
              // Bottom left corner/Top left corner.
              if (absolutePageY &lt; boundsY) {
                results.addAll(getElements(boundsX, boundsY));
              } else {
                results.addAll(getElements(boundsX, maximumBoundsY - 1));
              }
            } else {
              // Bottom right corner/Top right corner.
              if (absolutePageY &lt; boundsY) {
                results.addAll(getElements(maximumBoundsX - 1, boundsY));
              } else {
                results.addAll(getElements(maximumBoundsX - 1, maximumBoundsY - 1));
              }
            }
          }
        }
      } else {
        // Search all subpages of this page for pages that may intersect with or be contained
        // in the search boundaries.
        searchPages(results, absolutePageX, absolutePageY, absolutePageX + pageSize - 1,
                absolutePageY + pageSize - 1, boundsX, boundsY,
                maximumBoundsX, maximumBoundsY, pageSizeN - 1);
      }
    }
  }
}

private void aggregateSubmap(Set&lt;T&gt; results, int fromX, int fromZ, int toX, int toZ) {
  int fromCode = MortonCode.encode2(fromX, fromZ);
  int toCode = MortonCode.encode2(toX, toZ);
  NavigableMap&lt;Integer, Set&lt;T&gt;&gt; map = lookup.subMap(fromCode, true, toCode, true);
  for (Set&lt;T&gt; set : map.values()) {
    results.addAll(set);
  }
}

private static boolean isContainedWithin(int x, int z, int maximumX, int maximumY, int boundsX,
                                         int boundsZ, int maximumBoundsX, int maximumBoundsZ) {

  return x &gt;= boundsX &amp;&amp; z &gt;= boundsZ &amp;&amp; x &lt; maximumBoundsX &amp;&amp; z &lt; maximumBoundsZ &amp;&amp;
          maximumX &gt;= boundsX &amp;&amp; maximumY &gt;= boundsZ &amp;&amp; maximumX &lt; maximumBoundsX
          &amp;&amp; maximumY &lt; maximumBoundsZ;
}

private static boolean isIntersecting(int x, int z, int maximumX, int maximumY, int boundsX,
                                      int boundsY, int maximumBoundsX, int maximumBoundsY) {
  return (x &gt;= boundsX &amp;&amp; x &lt; maximumBoundsX || maximumX &gt; boundsX &amp;&amp; maximumX - 1 &lt; maximumBoundsX) &amp;&amp;
          (z &gt;= boundsY &amp;&amp; z &lt; maximumBoundsY || maximumY &gt; boundsY &amp;&amp; maximumY - 1 &lt; maximumBoundsY);
}

// ceil(log2(x))
private static int log2(int x) {
  return 32 - Integer.numberOfLeadingZeros(x - 1);
}</code></pre>
      </div>

      <meta itemprop='headline' content='2D spatial indexing using morton codes and BST'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>

          <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
          </div>

  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/justaguy.html'><span itemprop='name'>justaguy</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2016-02-11T03:38:39Z'>
            <time itemprop='dateModified' datetime='2016-08-04T17:50:12Z' class='post-time'>
              August 4, 2016,  5:50pm
            </time>
        <span itemprop='position'>#2</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Interesting problem. I’m currently reading the paper now but I noticed this statement: “The k-d tree has been known to be well adapted to range searching. Unfortunately, there is one disadvantage: there is no technique known to rebalance the trees when inserting or deleting an element.” (Page 1 of the PDF). Now that those exist, have you gotten the chance to try them? If so, were there any major speed differences?</p>
<p>PS: For anybody wanting to choose the BST option, you would be better off using an AVL tree since balance is important for fast-lookups.</p>
      </div>

      <meta itemprop='headline' content='2D spatial indexing using morton codes and BST'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/sinisoul.html'><span itemprop='name'>sinisoul</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2016-02-11T04:00:21Z'>
            <time itemprop='dateModified' datetime='2016-08-04T17:50:12Z' class='post-time'>
              August 4, 2016,  5:50pm
            </time>
        <span itemprop='position'>#3</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Yes. They are usually harder to implement, and rebalancing the tree is very difficult. I have not compared speeds. I’d imagine this technique is faster. If I get the chance I’ll check! <img src="../../images/emoji/twitter/slight_smileae52.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
      </div>

      <meta itemprop='headline' content='2D spatial indexing using morton codes and BST'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav' itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <ul>
        <li itemprop="name"><a href='../../index.html' itemprop="url">Home </a></li>
        <li itemprop="name"><a href='../../categories.html' itemprop="url">Categories </a></li>
        <li itemprop="name"><a href='../../guidelines.html' itemprop="url">FAQ/Guidelines </a></li>
        <li itemprop="name"><a href='../../tos.html' itemprop="url">Terms of Service </a></li>
        <li itemprop="name"><a href='../../privacy.html' itemprop="url">Privacy Policy </a></li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
  </body>
  

<!-- Mirrored from forum.moparisthebest.com/t/2d-spatial-indexing-using-morton-codes-and-bst/554696 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:09 GMT -->
</html>
