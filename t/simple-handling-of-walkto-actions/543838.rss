<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Simple handling of WalkTo actions</title>
    <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838</link>
    <description>[size=15pt][b]Intro:[/b][/size]
When you click an object as example a tree, you do not want your player to start cutting already before the player reached the tree.
Most servers have a very overcomplicated way of handling it, only working for a part of the situations it should be, don&#39;t even have it,
or it&#39;s all copy pasted code from one of grahams task schedulers.

Not that the last one is that bad, but it&#39;s much cleaner to have an apart system for it right?



[size=15pt][b]Adding the system:[/b][/size]

[size=13pt][b]Step 1:[/b][/size]
Create a new class called: [b]WalkToAction[/b]
Add this code to it, it&#39;s documented but don&#39;t hesitate to ask if you have questions.
This class holds the data for our walkTo action.

[code=java]package yourpackage;

import yourpackage.Player;

public abstract class WalkToAction {
	
	/**
	 * The player we&#39;re following.
	 */
	private final Player player;
	
	/**
	 * The target location of the player.
	 */
	private final Location targetLocation;
	
	
	/**
	 * The constructor.
	 * 
	 * @param player The assigned player.
	 * 
	 * @param targetLocation The location to walk to.
	 */
	public WalkToAction(Player player, Location targetLocation) {
		this.player = player;
		this.targetLocation = targetLocation;
	}
	
	/**
	 * The acting of the player once reached it&#39;s target location.
	 */
	protected abstract void act();
	
	
	/**
	 * Retrieves the assigned player.
	 * 
	 * @return The player object.
	 */
	public Player getPlayer() {
		return player;
	}
	
	/**
	 * Retrieves the target location.
	 * 
	 * @return The target location.
	 */
	public Location getTargetLocation() {
		return targetLocation;
	}

}
[/code]


[size=13pt][b]Step 2:[/b][/size]
Now we are going to create the class that is going to handle the walkTo actions.
Name that class: [b]WalkToHandler[/b]
And add the following code in it, same counts here, it&#39;s documented but ask if you have more questions.

[code=java]package yourpackage;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import yourpackage.taks.Task;
import yourpackage.taks.TaskScheduler ? Server; //Could be server class not sure
import yourpackage.Player;

public final class WalkToHandler {
	
	/**
	 * Holds the walk to actions currently being processed.
	 */
	private static List&lt;WalkToAction&gt; walkToActions = new LinkedList&lt;&gt;();

	
	/**
	 * Starts a new walk to process.
	 * 
	 * @param action The walk to action.
	 */
	public static void walkTo(final WalkToAction action) {
		walkToActions.add(action);
	}
	
	/**
	 * Processes the walk to actions.
	 */
	public static void process() {
		TaskFactory.getTaskScheduler().schedule(new Task() {
			@Override
			protected void execute() {
				for (Iterator&lt;WalkToAction&gt; it = walkToActions.iterator(); it.hasNext();) {
					WalkToAction action = it.next();
					//When the player reached it&#39;s target location...
					if (action.getPlayer().getLocation() == action.getTargetLocation()) {
						action.act(); //It&#39;s requested acting is executed.
						it.remove(); //The walk to action gets removed from the actives.
					}
				}
			}
		});
	}
	
	/**
	 * Resets any actions that should be reset when forcefully moving.
	 * 
	 * @param player the player object.
	 */
	public static void reset(Player2 player) {
		//Clears the active tasks of the player as they are not valid anymore due the changed situation.
		for (Iterator&lt;WalkToAction&gt; it = walkToActions.iterator(); it.hasNext();) {
			WalkToAction action = it.next();
			
			if (action.getPlayer() == player)
				it.remove();
		}
	}
	
}
[/code]

[i]As most PI&#39;s will have this task scheduler, and PI is still the most used base, I used it here.
It&#39;s not a biggy to convert it to another system if you&#39;d like to.[/i]
[code=java]
TaskFactory.getTaskScheduler().schedule(new Task(600) {[/code]
This should be edited by how your base is set up.
It could be Server.getTaskScheduler().schedule or TaskScheduler.schedule or any similar.
Or your own task/event system obviously.


[b]Reset should be used in your packet 98, which is forced movement.
As the player&#39;s target position will be changed our walkTo actions are not valid anymore.[/b]


[size=13pt][b]Step 4:[/b][/size]
Now when we launch our server we want the walkTo actions to start being processed.
So in Server.java in your launching method (probably &quot;static void main(..&quot;) add this:
[code=java]WalkToHandler.process()[/code]


[size=13pt][b]Example of usage:[/b][/size]
[code=java]
public void clickObject(Player player, int objectId, Location objLocation) {
		WalkToHandler.walkTo(new WalkToAction(player, objLocation) {
			@Override
			protected void act() {
				for (int treeId : TreeIds) {
					if (objectId == treeId) {
						Woodcutting.cutTree(player);
						return;
					}
				}
				Mining.ProspectRocks(player);
			}
		});
	}
[/code]



[b]Extra notes/possible issues:[/b]
* If you&#39;re using a regular PI/Delta/WL you are probably going to be easier to replace Player everywhere with Client.
* If you do not have the &quot;Location&quot; class, it might be named &quot;Position&quot;. If you don&#39;t have that one either,
you will have to change location to absx, absy, absz.
e.g.:
[code=java]
private final int x;
...

public WalkToAction(Client client, int absX, int absY, int absZ)
   this.x = absx;
...

public int getX() {
   return x;
...
//_____________________
//WalkToHandler where the process checks if we&#39;re at our target location, check the coordinates..

if (action.getClient().absX == action.getX() &amp;&amp; action.getClient().absY == action.getY()...) {

[/code]</description>
    
    <lastBuildDate>Mon, 16 Jun 2014 23:17:08 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@Clawz_fury lare69]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/clawz_fury">@Clawz_fury</a> wrote:</p>
          <blockquote>
              <p>[quote=“Davidi2, post:7, topic:543838”][quote author=RandQm link=topic=662717.msg4430208#msg4430208 date=1402936503]</p>
<aside class="quote">
<blockquote>
<p>Why do you have a collection of movement tasks? When will you be moving to more than one place at a time?</p>
</blockquote>
</aside>
<p>It’s not handled by the player but by the server, the server holds the movement requests of all players and handles them<br>
[/quote]That really shouldn’t be the case.[/quote]<br>
yeah, a better idea would be to give each player their own individual movement queue listener and use it for walking to actions</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/8</link>
        <pubDate>Mon, 16 Jun 2014 23:17:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-8</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@davidi2 Davidi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/davidi2">@davidi2</a> wrote:</p>
          <blockquote>
              <p>[quote=“RandQm, post:6, topic:543838”][quote author=AtomicInt_ link=topic=662717.msg4429978#msg4429978 date=1402787936]<br>
Why do you have a collection of movement tasks? When will you be moving to more than one place at a time?<br>
[/quote]<br>
It’s not handled by the player but by the server, the server holds the movement requests of all players and handles them[/quote]That really shouldn’t be the case.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/7</link>
        <pubDate>Mon, 16 Jun 2014 16:57:19 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-7</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@RandQm RandQm]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/randqm">@RandQm</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="5" data-topic="543838">
<div class="title">
<div class="quote-controls"></div>
 AtomicInt_:</div>
<blockquote>
<p>Why do you have a collection of movement tasks? When will you be moving to more than one place at a time?</p>
</blockquote>
</aside>
<p>It’s not handled by the player but by the server, the server holds the movement requests of all players and handles them</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/6</link>
        <pubDate>Mon, 16 Jun 2014 16:35:03 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-6</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@ExtremeX-Scape Ryley]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/extremex-scape">@ExtremeX-Scape</a> wrote:</p>
          <blockquote>
              <p>Why do you have a collection of movement tasks? When will you be moving to more than one place at a time?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/5</link>
        <pubDate>Sat, 14 Jun 2014 23:18:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-5</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@RandQm RandQm]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/randqm">@RandQm</a> wrote:</p>
          <blockquote>
              <p>[quote=“lare69, post:3, topic:543838”]i dont mean to sound like a pretentious prick, but this is a lot more complicated than it has to be. you shouldn’t have to use lists and tons of abstraction and doesn’t even look like it would work in some situations either… you’re making the actions execute when they have reached the exact position which won’t work for things like objects (you can cut trees from 1/2 squares away). you’re also comparing the positions wrong lol</p>
<p><code>                                        //When the player reached it's target location...
                                        if (action.getPlayer().getLocation() == action.getTargetLocation()) {
                                                action.act(); //It's requested acting is executed.
                                                it.remove(); //The walk to action gets removed from the actives.
                                        }</code></p>
<p>using ‘==’  is comparing the references and not the actual data within the objects. use <span class="bbcode-i">equals(Object obj)</span> instead. Not to mention, you’re looping every 600ms checking for actions when you can just do it on-demand and only listen for actions when needed (see below vv)</p>
<p>all you have to do is write a listener implementation based off of your task system and make the listener listen for the walking queue to end</p>
<p>the listener</p>
<p>[code=java]package server.core.worker.listener;</p>
<p>import server.core.worker.Worker;</p>
<p>/**</p>
<ul>
<li>
<p>A listener that fires logic after some sort of event occurs.</p>
</li>
<li>
</li>
<li>
<p><span class="mention">@author</span> lare96<br>
*/<br>
public abstract class EventListener extends Worker {</p>
<p>/** Determines if the listener should be shut down once the logic has fired. */<br>
private boolean shutdownOnFire = true;</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener}.</li>
<li>
</li>
<li>
<a class="mention" href="/u/param">@param</a> shutdownOnFire</li>
<li>
<pre><code>   if the listener should be shut down once the logic has fired.
</code></pre>
</li>
<li>
<a class="mention" href="/u/param">@param</a> rateOfFire</li>
<li>
<pre><code>   the rate in which the event will be checked and the logic will be
</code></pre>
</li>
<li>
<pre><code>   fired in ticks.
</code></pre>
</li>
</ul>
<p>*/<br>
public EventListener(boolean shutdownOnFire, int rateOfFire) {<br>
super(rateOfFire, true);<br>
this.shutdownOnFire = shutdownOnFire;<br>
}</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener}.</li>
<li>
</li>
<li>
<a class="mention" href="/u/param">@param</a> shutdownOnFire</li>
<li>
<pre><code>   if the listener should be shut down once the logic has fired.
</code></pre>
</li>
</ul>
<p>*/<br>
public EventListener(boolean shutdownOnFire) {<br>
super(1, false);<br>
this.shutdownOnFire = shutdownOnFire;<br>
}</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener}.</li>
<li>
</li>
<li>
<a class="mention" href="/u/param">@param</a> rateOfFire</li>
<li>
<pre><code>   the rate in which the event will be checked and the logic will be
</code></pre>
</li>
<li>
<pre><code>   fired in ticks.
</code></pre>
</li>
</ul>
<p>*/<br>
public EventListener(int rateOfFire) {<br>
super(rateOfFire, true);<br>
}</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener} with the default settings.<br>
*/<br>
public EventListener() {<br>
super(1, true);<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>Will block from firing the logic until this condition is flagged false.</li>
<li>
</li>
<li>
<a class="mention" href="/u/return">@return</a> true if this listener should keep listening, false if the event</li>
<li>
<pre><code>    has occurred and the listener should fire the logic.
</code></pre>
</li>
</ul>
<p>*/<br>
public abstract boolean listenForEvent();</p>
<p>/**</p>
<ul>
<li>The actual logic that will be fired once <code>listenForEvent</code> is</li>
<li>unflagged.<br>
*/<br>
public abstract void run();</li>
</ul>
<p><a class="mention" href="/u/override">@Override</a><br>
public void fire() {</p>
<pre><code> /** Block if the event has not yet occurred. */
 if (listenForEvent()) {
     return;
 }

 /** Fire the logic once the event has occurred. */
 run();

 /**
  * Shutdown the listener once the task has been ran if it is set to do
  * so, if not it will keep listening and will execute the logic every
  * 600ms (as long as the condition is unflagged).
  */
 if (shutdownOnFire) {
     this.cancel();
 }
</code></pre>
<p>}<br>
}[/code]</p>
</li>
</ul>
<p>submitting new actions</p>
<p>[code=java]<br>
/**<br>
* Creates a new {<a class="mention" href="/u/link">@link</a> EventListener} that will execute the<br>
* {<a class="mention" href="/u/link">@link</a> Runnable} action once the walking queue is finished. If a new<br>
* action is submitted while the current one hasn’t finished, the existing<br>
* {<a class="mention" href="/u/link">@link</a> EventListener} is stopped and a new one is created to carry out<br>
* the new action.<br>
*<br>
* <a class="mention" href="/u/param">@param</a> action<br>
*        the action to run once the walking queue is finished.<br>
*/<br>
public void submit(final Runnable action) {</p>
<pre><code>    /** Stop any existing actions. */
    if (listener != null) {
        if (listener.isRunning()) {
            listener.cancel();
        }
    }

    /** And begin listening for a new action. */
    listener = new EventListener() {

        @Override
        public boolean listenForEvent() {
            return entity.getMovementQueue().isMovementDone() || entity.isUnregistered() ? false : true;

        }

        @Override
        public void run() {

            /** Attempt to run the action. */
            try {
                if (entity.isUnregistered()) {
                    return;
                }

                action.run();

                /** Handle any errors we may come across. */
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };

    /** Schedule the listener. */
    TaskFactory.getFactory().submit(listener);
}[/code]
</code></pre>
<p>usage</p>
<p><code>player.getMovementQueueListener().submit(new Runnable() {
     @Override
     public void run() {
          player.getPacketBuilder().sendMessage("This will execute when the walking queue is finished!");
          player.getPacketBuilder().sendMessage("Check if the player is close enough to do the action.");
     }
});</code></p>
<p>done: neater, cleaner, and more efficient[/quote]</p>
<p>Lol everytime I write something in Java I get complaints about using “==” to compare,<br>
it’s a habit from c# where they rather use == than comparing methods.</p>
<p>Thanks for the other input I will look it in, always open to improve</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/4</link>
        <pubDate>Sat, 14 Jun 2014 23:06:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-4</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@Clawz_fury lare69]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/clawz_fury">@Clawz_fury</a> wrote:</p>
          <blockquote>
              <p>i dont mean to sound like a pretentious prick, but this is a lot more complicated than it has to be. you shouldn’t have to use lists and tons of abstraction and doesn’t even look like it would work in some situations either… you’re making the actions execute when they have reached the exact position which won’t work for things like objects (you can cut trees from 1/2 squares away). you’re also comparing the positions wrong lol</p>
<p><code>                                        //When the player reached it's target location...
                                        if (action.getPlayer().getLocation() == action.getTargetLocation()) {
                                                action.act(); //It's requested acting is executed.
                                                it.remove(); //The walk to action gets removed from the actives.
                                        }</code></p>
<p>using ‘==’  is comparing the references and not the actual data within the objects. use <span class="bbcode-i">equals(Object obj)</span> instead. Not to mention, you’re looping every 600ms checking for actions when you can just do it on-demand and only listen for actions when needed (see below vv)</p>
<p>all you have to do is write a listener implementation based off of your task system and make the listener listen for the walking queue to end</p>
<p>the listener</p>
<p>[code=java]package server.core.worker.listener;</p>
<p>import server.core.worker.Worker;</p>
<p>/**</p>
<ul>
<li>
<p>A listener that fires logic after some sort of event occurs.</p>
</li>
<li>
</li>
<li>
<p><span class="mention">@author</span> lare96<br>
*/<br>
public abstract class EventListener extends Worker {</p>
<p>/** Determines if the listener should be shut down once the logic has fired. */<br>
private boolean shutdownOnFire = true;</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener}.</li>
<li>
</li>
<li>
<a class="mention" href="/u/param">@param</a> shutdownOnFire</li>
<li>
<pre><code>   if the listener should be shut down once the logic has fired.
</code></pre>
</li>
<li>
<a class="mention" href="/u/param">@param</a> rateOfFire</li>
<li>
<pre><code>   the rate in which the event will be checked and the logic will be
</code></pre>
</li>
<li>
<pre><code>   fired in ticks.
</code></pre>
</li>
</ul>
<p>*/<br>
public EventListener(boolean shutdownOnFire, int rateOfFire) {<br>
super(rateOfFire, true);<br>
this.shutdownOnFire = shutdownOnFire;<br>
}</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener}.</li>
<li>
</li>
<li>
<a class="mention" href="/u/param">@param</a> shutdownOnFire</li>
<li>
<pre><code>   if the listener should be shut down once the logic has fired.
</code></pre>
</li>
</ul>
<p>*/<br>
public EventListener(boolean shutdownOnFire) {<br>
super(1, false);<br>
this.shutdownOnFire = shutdownOnFire;<br>
}</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener}.</li>
<li>
</li>
<li>
<a class="mention" href="/u/param">@param</a> rateOfFire</li>
<li>
<pre><code>   the rate in which the event will be checked and the logic will be
</code></pre>
</li>
<li>
<pre><code>   fired in ticks.
</code></pre>
</li>
</ul>
<p>*/<br>
public EventListener(int rateOfFire) {<br>
super(rateOfFire, true);<br>
}</p>
<p>/**</p>
<ul>
<li>Create a new {<a class="mention" href="/u/link">@link</a> EventListener} with the default settings.<br>
*/<br>
public EventListener() {<br>
super(1, true);<br>
}</li>
</ul>
<p>/**</p>
<ul>
<li>Will block from firing the logic until this condition is flagged false.</li>
<li>
</li>
<li>
<a class="mention" href="/u/return">@return</a> true if this listener should keep listening, false if the event</li>
<li>
<pre><code>    has occurred and the listener should fire the logic.
</code></pre>
</li>
</ul>
<p>*/<br>
public abstract boolean listenForEvent();</p>
<p>/**</p>
<ul>
<li>The actual logic that will be fired once <code>listenForEvent</code> is</li>
<li>unflagged.<br>
*/<br>
public abstract void run();</li>
</ul>
<p><a class="mention" href="/u/override">@Override</a><br>
public void fire() {</p>
<pre><code> /** Block if the event has not yet occurred. */
 if (listenForEvent()) {
     return;
 }

 /** Fire the logic once the event has occurred. */
 run();

 /**
  * Shutdown the listener once the task has been ran if it is set to do
  * so, if not it will keep listening and will execute the logic every
  * 600ms (as long as the condition is unflagged).
  */
 if (shutdownOnFire) {
     this.cancel();
 }
</code></pre>
<p>}<br>
}[/code]</p>
</li>
</ul>
<p>submitting new actions</p>
<p>[code=java]<br>
/**<br>
* Creates a new {<a class="mention" href="/u/link">@link</a> EventListener} that will execute the<br>
* {<a class="mention" href="/u/link">@link</a> Runnable} action once the walking queue is finished. If a new<br>
* action is submitted while the current one hasn’t finished, the existing<br>
* {<a class="mention" href="/u/link">@link</a> EventListener} is stopped and a new one is created to carry out<br>
* the new action.<br>
*<br>
* <a class="mention" href="/u/param">@param</a> action<br>
*        the action to run once the walking queue is finished.<br>
*/<br>
public void submit(final Runnable action) {</p>
<pre><code>    /** Stop any existing actions. */
    if (listener != null) {
        if (listener.isRunning()) {
            listener.cancel();
        }
    }

    /** And begin listening for a new action. */
    listener = new EventListener() {

        @Override
        public boolean listenForEvent() {
            return entity.getMovementQueue().isMovementDone() || entity.isUnregistered() ? false : true;

        }

        @Override
        public void run() {

            /** Attempt to run the action. */
            try {
                if (entity.isUnregistered()) {
                    return;
                }

                action.run();

                /** Handle any errors we may come across. */
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };

    /** Schedule the listener. */
    TaskFactory.getFactory().submit(listener);
}[/code]
</code></pre>
<p>usage</p>
<p><code>player.getMovementQueueListener().submit(new Runnable() {
     @Override
     public void run() {
          player.getPacketBuilder().sendMessage("This will execute when the walking queue is finished!");
          player.getPacketBuilder().sendMessage("Check if the player is close enough to do the action.");
     }
});</code></p>
<p>done: neater, cleaner, and more efficient</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/3</link>
        <pubDate>Wed, 11 Jun 2014 05:04:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-3</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@jummppy jummppy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jummppy">@jummppy</a> wrote:</p>
          <blockquote>
              <p>very nice system. I’ll into it later</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/2</link>
        <pubDate>Tue, 10 Jun 2014 19:06:51 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-2</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
      <item>
        <title>Simple handling of WalkTo actions</title>
        <dc:creator><![CDATA[@RandQm RandQm]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/randqm">@RandQm</a> wrote:</p>
          <blockquote>
              <p>[size=15pt]<span class="bbcode-b">Intro:</span>[/size]<br>
When you click an object as example a tree, you do not want your player to start cutting already before the player reached the tree.<br>
Most servers have a very overcomplicated way of handling it, only working for a part of the situations it should be, don’t even have it,<br>
or it’s all copy pasted code from one of grahams task schedulers.</p>
<p>Not that the last one is that bad, but it’s much cleaner to have an apart system for it right?</p>
<p>[size=15pt]<span class="bbcode-b">Adding the system:</span>[/size]</p>
<p>[size=13pt]<span class="bbcode-b">Step 1:</span>[/size]<br>
Create a new class called: <span class="bbcode-b">WalkToAction</span><br>
Add this code to it, it’s documented but don’t hesitate to ask if you have questions.<br>
This class holds the data for our walkTo action.</p>
<p>[code=java]package yourpackage;</p>
<p>import yourpackage.Player;</p>
<p>public abstract class WalkToAction {</p>
<pre><code>/**
 * The player we're following.
 */
private final Player player;

/**
 * The target location of the player.
 */
private final Location targetLocation;


/**
 * The constructor.
 * 
 * @param player The assigned player.
 * 
 * @param targetLocation The location to walk to.
 */
public WalkToAction(Player player, Location targetLocation) {
	this.player = player;
	this.targetLocation = targetLocation;
}

/**
 * The acting of the player once reached it's target location.
 */
protected abstract void act();


/**
 * Retrieves the assigned player.
 * 
 * @return The player object.
 */
public Player getPlayer() {
	return player;
}

/**
 * Retrieves the target location.
 * 
 * @return The target location.
 */
public Location getTargetLocation() {
	return targetLocation;
}
</code></pre>
<p>}<br>
[/code]</p>
<p>[size=13pt]<span class="bbcode-b">Step 2:</span>[/size]<br>
Now we are going to create the class that is going to handle the walkTo actions.<br>
Name that class: <span class="bbcode-b">WalkToHandler</span><br>
And add the following code in it, same counts here, it’s documented but ask if you have more questions.</p>
<p>[code=java]package yourpackage;</p>
<p>import java.util.Iterator;<br>
import java.util.LinkedList;<br>
import java.util.List;</p>
<p>import yourpackage.taks.Task;<br>
import yourpackage.taks.TaskScheduler ? Server; //Could be server class not sure<br>
import yourpackage.Player;</p>
<p>public final class WalkToHandler {</p>
<pre><code>/**
 * Holds the walk to actions currently being processed.
 */
private static List&lt;WalkToAction&gt; walkToActions = new LinkedList&lt;&gt;();


/**
 * Starts a new walk to process.
 * 
 * @param action The walk to action.
 */
public static void walkTo(final WalkToAction action) {
	walkToActions.add(action);
}

/**
 * Processes the walk to actions.
 */
public static void process() {
	TaskFactory.getTaskScheduler().schedule(new Task() {
		@Override
		protected void execute() {
			for (Iterator&lt;WalkToAction&gt; it = walkToActions.iterator(); it.hasNext();) {
				WalkToAction action = it.next();
				//When the player reached it's target location...
				if (action.getPlayer().getLocation() == action.getTargetLocation()) {
					action.act(); //It's requested acting is executed.
					it.remove(); //The walk to action gets removed from the actives.
				}
			}
		}
	});
}

/**
 * Resets any actions that should be reset when forcefully moving.
 * 
 * @param player the player object.
 */
public static void reset(Player2 player) {
	//Clears the active tasks of the player as they are not valid anymore due the changed situation.
	for (Iterator&lt;WalkToAction&gt; it = walkToActions.iterator(); it.hasNext();) {
		WalkToAction action = it.next();
		
		if (action.getPlayer() == player)
			it.remove();
	}
}
</code></pre>
<p>}<br>
[/code]</p>
<p><span class="bbcode-i">As most PI’s will have this task scheduler, and PI is still the most used base, I used it here.<br>
It’s not a biggy to convert it to another system if you’d like to.</span></p>
<p><code>
TaskFactory.getTaskScheduler().schedule(new Task(600) {</code><br>
This should be edited by how your base is set up.<br>
It could be Server.getTaskScheduler().schedule or TaskScheduler.schedule or any similar.<br>
Or your own task/event system obviously.</p>
<p><span class="bbcode-b">Reset should be used in your packet 98, which is forced movement.<br>
As the player’s target position will be changed our walkTo actions are not valid anymore.</span></p>
<p>[size=13pt]<span class="bbcode-b">Step 4:</span>[/size]<br>
Now when we launch our server we want the walkTo actions to start being processed.<br>
So in Server.java in your launching method (probably “static void main(…”) add this:</p>
<pre><code class="lang-auto"></code></pre>
<p>[size=13pt]<span class="bbcode-b">Example of usage:</span>[/size]</p>
<pre><code class="lang-auto">public void clickObject(Player player, int objectId, Location objLocation) {
		WalkToHandler.walkTo(new WalkToAction(player, objLocation) {
			@Override
			protected void act() {
				for (int treeId : TreeIds) {
					if (objectId == treeId) {
						Woodcutting.cutTree(player);
						return;
					}
				}
				Mining.ProspectRocks(player);
			}
		});
	}</code></pre>
<p><span class="bbcode-b">Extra notes/possible issues:</span></p>
<ul>
<li>If you’re using a regular PI/Delta/WL you are probably going to be easier to replace Player everywhere with Client.</li>
<li>If you do not have the “Location” class, it might be named “Position”. If you don’t have that one either,<br>
you will have to change location to absx, absy, absz.<br>
e.g.:</li>
</ul>
<pre><code class="lang-auto">private final int x;
...

public WalkToAction(Client client, int absX, int absY, int absZ)
   this.x = absx;
...

public int getX() {
   return x;
...
//_____________________
//WalkToHandler where the process checks if we're at our target location, check the coordinates..

if (action.getClient().absX == action.getX() &amp;&amp; action.getClient().absY == action.getY()...) {
</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838/1</link>
        <pubDate>Tue, 10 Jun 2014 19:03:34 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-543838-1</guid>
        <source url="https://forum.moparisthebest.com/t/simple-handling-of-walkto-actions/543838.rss">Simple handling of WalkTo actions</source>
      </item>
  </channel>
</rss>
