<!DOCTYPE html>
<html lang="en-US">
  
<!-- Mirrored from forum.moparisthebest.com/t/which-way-is-more-oop-like/547713?page=2 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>Which way is more OOP-like - General Programming - moparisthebest.com</title>
    <meta name="description" content="I have an Entity class and I have the Player and the Enemy as subclasses of the Entity class. 

The Entity class has the variables x, y, and z. Should these variables be private or protected? Is it more OOP-like to acces&amp;hellip;">
    <meta name="generator" content="Discourse 2.3.2 - https://github.com/discourse/discourse version c587df7e2a03c2962f4c8cefd6f03969bb87d525">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/1/1f0dc167bcf798bdbd70b03bf0fd1bc836e54e1a_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff_2_180x180.png">
<meta name="theme-color" content="#0088cc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="5477134658.html?page=2" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.moparisthebest.com","potentialAction":{"@type":"SearchAction","target":"https://forum.moparisthebest.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="moparisthebest.com Search">

      <link href="../../stylesheets/desktop_1_ec9f75e3d0b2a904642ce53663991837b70cda3334fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="../../stylesheets/desktop_theme_2_6707e7ee46ac9f2f0510c29ddd10e8f6ce21c1ae34fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;Which way is more OOP-like&#39;" href="547713.rss" />
  <meta property="og:site_name" content="moparisthebest.com" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:url" content="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713?page=2" />
<meta name="twitter:url" content="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713?page=2" />
<meta property="og:title" content="Which way is more OOP-like" />
<meta name="twitter:title" content="Which way is more OOP-like" />
<meta property="og:description" content="b o i l e r p l a t e  üôÇ" />
<meta name="twitter:description" content="b o i l e r p l a t e  üôÇ" />
<meta property="article:published_time" content="2014-11-13T22:02:54+00:00" />
<meta property="og:ignore_canonical" content="true" />

      <link rel="prev" href="547713.html">
      <link rel="next" href="5477139ba9.html?page=3">


    
  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html">
          <img src="../../uploads/default/original/2X/3/37bba8fb3bd06c372ab54fa72ec38bf9f8f40b37.gif" alt="moparisthebest.com" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1 class="crawler-topic-title">
  <a href="547713.html">Which way is more OOP-like</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/general-programming.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>General Programming</span>
      </a>
    </div>
</div>





  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/whackatre.html'><span itemprop='name'>whackatre</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-13T22:02:54Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:14Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#21</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>b o i l e r p l a t e  <img src="../../images/emoji/twitter/slight_smileae52.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/T41.html'><span itemprop='name'>T41</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-14T00:23:57Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:16Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#22</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚Äúsanga282, post:20, topic:547713‚Äù][quote author=Zymus link=topic=666617.msg4457154#msg4457154 date=1415567995]<br>
To conform more to OOP, I would encapsulate that as it‚Äôs own class. Location, Position, Tile, Point, etc.</p>
<pre><code class="lang-auto">public final class Location {

    public Location(final int x, final int y, final int z) {
        // NOTE: if there are any restrictions on the values (ie. must be non-negative)
        // do that here.
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int getZ() {
        return z;
    }

    private final int x;
    private final int y;
    private final int z;
}</code></pre>
<p>Then in your Entity class:</p>
<pre><code class="lang-auto">public class Entity {

    public Location getLocation() {
        return location;
    }

    public Location setLocation(final Location location) {
        // NOTE: Do any input validation
        this.location = location;
    }

    private Location location;
}</code></pre>
<p>That would be more OOP. However, I don‚Äôt really see a problem in making the Location field in Entity protected. The only thing that might come up is if someone else is looking at the code from a black-box perspective, they might not know where the location field is defined:</p>
<pre><code class="lang-auto">public class Player extends Entity {

    public void doSomething() {
        location = null;
    }

    // These are the only fields declared
    private String name;
    private int health;
}</code></pre>
<p>In this context, it might not click immediately that location is actually defined in Entity, rather and Player. Now, in modern programming, most people are using IDEs, and if they select location, there‚Äôs usually a ‚ÄúGo to definition‚Äù action, and it will bring them to it, so it‚Äôs still not that big of a deal. Try to program for the most common denominator.<br>
[/quote]<br>
why the fudge would you do this[/quote]<br>
I like to call malloc every time a player moves too!!!</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/eXemplar.html'><span itemprop='name'>eXemplar</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-14T00:33:39Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:16Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#23</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Ignore everyone in this thread. Your first example of encapsulating the private fields and providing public accessor methods is totally fine. If you go any further down the rabbit hole of a simple object to hold primitive types, you‚Äôll end up with problems everyone has mentioned from creation, access and destruction.</p>
<p>also, t4 is crasee <img src="../../images/emoji/twitter/winkae52.png?v=5" title=":wink:" class="emoji" alt=":wink:"></p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/zyle1992.html'><span itemprop='name'>zyle1992</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-14T07:36:21Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:21Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#24</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚Äút4, post:22, topic:547713‚Äù][quote author=sanga282 link=topic=666617.msg4457812#msg4457812 date=1415912125]</p>
<aside class="quote">
<blockquote>
<p>To conform more to OOP, I would encapsulate that as it‚Äôs own class. Location, Position, Tile, Point, etc.</p>
<pre><code class="lang-auto">public final class Location {

    public Location(final int x, final int y, final int z) {
        // NOTE: if there are any restrictions on the values (ie. must be non-negative)
        // do that here.
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int getZ() {
        return z;
    }

    private final int x;
    private final int y;
    private final int z;
}</code></pre>
<p>Then in your Entity class:</p>
<pre><code class="lang-auto">public class Entity {

    public Location getLocation() {
        return location;
    }

    public Location setLocation(final Location location) {
        // NOTE: Do any input validation
        this.location = location;
    }

    private Location location;
}</code></pre>
<p>That would be more OOP. However, I don‚Äôt really see a problem in making the Location field in Entity protected. The only thing that might come up is if someone else is looking at the code from a black-box perspective, they might not know where the location field is defined:</p>
<pre><code class="lang-auto">public class Player extends Entity {

    public void doSomething() {
        location = null;
    }

    // These are the only fields declared
    private String name;
    private int health;
}</code></pre>
<p>In this context, it might not click immediately that location is actually defined in Entity, rather and Player. Now, in modern programming, most people are using IDEs, and if they select location, there‚Äôs usually a ‚ÄúGo to definition‚Äù action, and it will bring them to it, so it‚Äôs still not that big of a deal. Try to program for the most common denominator.</p>
</blockquote>
</aside>
<p>why the fudge would you do this<br>
[/quote]<br>
I like to call malloc every time a player moves too!!![/quote]</p>
<p>The performance cost is negligible in nearly every system that has a modern JVM, and more than 1GB of RAM. There is no reason not to create a class to represent something like this. You get many benefits from doing it this way, including maintainability, code clarity, and thread safety. Now, I‚Äôm not advocating that everything should be immutable, as it‚Äôs just one side of the whole picture. In this case though, it makes more sense. Washington, DC will always (as a location) be Washington, DC. There will not come a day that Washington, DC will be redefined to Kansas City, Missouri. Just as Lat 42¬∞ 41‚Äô 58" Long -120¬∞ 3‚Äô 30" will always be Lat 42¬∞ 41‚Äô 58" Long -120¬∞ 3‚Äô 30". The Player‚Äôs location will change, but the location itself is constant.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/sanga282.html'><span itemprop='name'>sanga282</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-14T12:25:58Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:21Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#25</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚ÄúZymus, post:24, topic:547713‚Äù][quote author=t4 link=topic=666617.msg4457845#msg4457845 date=1415924637]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>To conform more to OOP, I would encapsulate that as it‚Äôs own class. Location, Position, Tile, Point, etc.</p>
<pre><code class="lang-auto">public final class Location {

    public Location(final int x, final int y, final int z) {
        // NOTE: if there are any restrictions on the values (ie. must be non-negative)
        // do that here.
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int getZ() {
        return z;
    }

    private final int x;
    private final int y;
    private final int z;
}</code></pre>
<p>Then in your Entity class:</p>
<pre><code class="lang-auto">public class Entity {

    public Location getLocation() {
        return location;
    }

    public Location setLocation(final Location location) {
        // NOTE: Do any input validation
        this.location = location;
    }

    private Location location;
}</code></pre>
<p>That would be more OOP. However, I don‚Äôt really see a problem in making the Location field in Entity protected. The only thing that might come up is if someone else is looking at the code from a black-box perspective, they might not know where the location field is defined:</p>
<pre><code class="lang-auto">public class Player extends Entity {

    public void doSomething() {
        location = null;
    }

    // These are the only fields declared
    private String name;
    private int health;
}</code></pre>
<p>In this context, it might not click immediately that location is actually defined in Entity, rather and Player. Now, in modern programming, most people are using IDEs, and if they select location, there‚Äôs usually a ‚ÄúGo to definition‚Äù action, and it will bring them to it, so it‚Äôs still not that big of a deal. Try to program for the most common denominator.</p>
</blockquote>
</aside>
<p>why the fudge would you do this</p>
</blockquote>
</aside>
<p>I like to call malloc every time a player moves too!!!<br>
[/quote]</p>
<p>The performance cost is negligible in nearly every system that has a modern JVM, and more than 1GB of RAM. There is no reason not to create a class to represent something like this. You get many benefits from doing it this way, including maintainability, code clarity, and thread safety. Now, I‚Äôm not advocating that everything should be immutable, as it‚Äôs just one side of the whole picture. In this case though, it makes more sense. Washington, DC will always (as a location) be Washington, DC. There will not come a day that Washington, DC will be redefined to Kansas City, Missouri. Just as Lat 42¬∞ 41‚Äô 58" Long -120¬∞ 3‚Äô 30" will always be Lat 42¬∞ 41‚Äô 58" Long -120¬∞ 3‚Äô 30". The Player‚Äôs location will change, but the location itself is constant.[/quote]<br>
this is still a terrible idea</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Ashi.html'><span itemprop='name'>Ashi</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-14T13:03:20Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:31Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#26</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>It‚Äôs not so much a terrible idea.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/T41.html'><span itemprop='name'>T41</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-14T22:30:21Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:37Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#27</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>It‚Äôs not the fact it‚Äôs a class, it‚Äôs the fact it‚Äôs immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote" data-post="26" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="../../letter_avatar/ashi/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> Ashi:</div>
<blockquote>
<p>It‚Äôs not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you‚Äôre adding overhead for no good reason.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/zyle1992.html'><span itemprop='name'>zyle1992</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-14T22:41:36Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:37Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#28</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚Äút4, post:27, topic:547713‚Äù]It‚Äôs not the fact it‚Äôs a class, it‚Äôs the fact it‚Äôs immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote">
<blockquote>
<p>It‚Äôs not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you‚Äôre adding overhead for no good reason.[/quote]</p>
<p>This is how it‚Äôs been in every corporate environment I‚Äôve worked in. The benefit of having an class rather than a set of primitives out-weigh the negligible performance cost. Here is an excerpt of an article written by IBM about the performance of immutable objects:</p>
<blockquote>No installment of Java theory and practice would be complete without some sort of plug for immutability. Making objects immutable eliminates entire classes of programming errors. One of the most common reasons given for not making a class immutable is the belief that doing so would compromise performance. While this is true sometimes, it is often not -- and sometimes the use of immutable objects has significant, and perhaps surprising, performance advantages.
<p>Many objects function as containers for references to other objects. When the referenced object needs to change, we have two choices: update the reference (as we would in a mutable container class) or re-create the container to hold a new reference (as we would in an immutable container class). Listing 5 shows two ways to implement a simple holder class. Assuming the containing object is small, which is often the case (such as a Map.Entry element in a Map or a linked list element), allocating a new immutable object has some hidden performance advantages that come from the way generational garbage collectors work, having to do with the relative age of objects.<br>
Listing 5. Mutable and immutable object holders</p>
<pre><code class="lang-auto">public class MutableHolder {
  private Object value;
  public Object getValue() { return value; }
  public void setValue(Object o) { value = o; }
}</code></pre>
<p><code>
public class ImmutableHolder {
  private final Object value;
  public ImmutableHolder(Object o) { value = o; }
  public Object getValue() { return value; }
}</code></p>
<p>In most cases, when a holder object is updated to reference a different object, the new referent is a young object. If we update a MutableHolder by calling setValue(), we have created a situation where an older object references a younger one. On the other hand, by creating a new ImmutableHolder object instead, a younger object is referencing an older one. The latter situation, where most objects point to older objects, is much more gentle on a generational garbage collector. If a MutableHolder that lives in the old generation is mutated, all the objects on the card that contain the MutableHolder must be scanned for old-to-young references at the next minor collection. The use of mutable references for long-lived container objects increases the work done to track old-to-young references at collection time. (See last month‚Äôs article and this month‚Äôs Resources, which explain the card-marking algorithm used to implement the write barrier in the generational collector used by current Sun JVMs).</p>
</blockquote>
<p>Found <a href="http://www.ibm.com/developerworks/java/library/j-jtp01274/index.html" data-bbcode="true">here</a>. And the article was accurate as of Jan 27 2004.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>

          <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
          </div>

  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/T41.html'><span itemprop='name'>T41</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T01:16:55Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:38Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#29</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚ÄúZymus, post:28, topic:547713‚Äù][quote author=t4 link=topic=666617.msg4457992#msg4457992 date=1416004221]<br>
It‚Äôs not the fact it‚Äôs a class, it‚Äôs the fact it‚Äôs immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote">
<blockquote>
<p>It‚Äôs not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you‚Äôre adding overhead for no good reason.<br>
[/quote]</p>
<p>This is how it‚Äôs been in every corporate environment I‚Äôve worked in. The benefit of having an class rather than a set of primitives out-weigh the negligible performance cost. Here is an excerpt of an article written by IBM about the performance of immutable objects:</p>
<aside class="quote">
<blockquote>
<p>No installment of Java theory and practice would be complete without some sort of plug for immutability. Making objects immutable eliminates entire classes of programming errors. One of the most common reasons given for not making a class immutable is the belief that doing so would compromise performance. While this is true sometimes, it is often not ‚Äì and sometimes the use of immutable objects has significant, and perhaps surprising, performance advantages.</p>
<p>Many objects function as containers for references to other objects. When the referenced object needs to change, we have two choices: update the reference (as we would in a mutable container class) or re-create the container to hold a new reference (as we would in an immutable container class). Listing 5 shows two ways to implement a simple holder class. Assuming the containing object is small, which is often the case (such as a Map.Entry element in a Map or a linked list element), allocating a new immutable object has some hidden performance advantages that come from the way generational garbage collectors work, having to do with the relative age of objects.<br>
Listing 5. Mutable and immutable object holders</p>
<pre><code class="lang-auto">public class MutableHolder {
  private Object value;
  public Object getValue() { return value; }
  public void setValue(Object o) { value = o; }
}</code></pre>
<p><code>
public class ImmutableHolder {
  private final Object value;
  public ImmutableHolder(Object o) { value = o; }
  public Object getValue() { return value; }
}</code></p>
<p>In most cases, when a holder object is updated to reference a different object, the new referent is a young object. If we update a MutableHolder by calling setValue(), we have created a situation where an older object references a younger one. On the other hand, by creating a new ImmutableHolder object instead, a younger object is referencing an older one. The latter situation, where most objects point to older objects, is much more gentle on a generational garbage collector. If a MutableHolder that lives in the old generation is mutated, all the objects on the card that contain the MutableHolder must be scanned for old-to-young references at the next minor collection. The use of mutable references for long-lived container objects increases the work done to track old-to-young references at collection time. (See last month‚Äôs article and this month‚Äôs Resources, which explain the card-marking algorithm used to implement the write barrier in the generational collector used by current Sun JVMs).</p>
</blockquote>
</aside>
<p>Found <a href="http://www.ibm.com/developerworks/java/library/j-jtp01274/index.html" data-bbcode="true" rel="nofollow noopener">here</a>. And the article was accurate as of Jan 27 2004.[/quote]</p>
<blockquote>testImmutable:	48070515ns	219136 kbytes
testImmutable:	51471351ns	210944 kbytes
testImmutable:	47096725ns	202752 kbytes
testImmutable:	49465237ns	206336 kbytes
testImmutable:	48414874ns	205312 kbytes</blockquote>
<blockquote>testMutable:	24166644ns	147456 kbytes
testMutable:	25280271ns	152064 kbytes
testMutable:	22732076ns	152576 kbytes
testMutable:	23517686ns	152576 kbytes
testMutable:	23391368ns	150016 kbytes</blockquote>
<p>Well what do you know, immutable object manipulation requires more clock time and memory, it‚Äôs almost like it‚Äôs common sense or something! :eek:</p>
<pre><code class="lang-auto">/**
 * Created by t4 on 11/14/14.
 */
public class Benchmarker {

    public static class ImmutablePoint {
        private final int x, y;

        public ImmutablePoint(final int x, final int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return this.x;
        }

        public int getY() {
            return this.y;
        }

        public ImmutablePoint move(final int deltaX, final int deltaY) {
            return new ImmutablePoint(this.x + deltaX, this.y + deltaY);
        }
    }

    public static class MutablePoint {
        private int x, y;

        public MutablePoint(final int x, final int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return this.x;
        }

        public int getY() {
            return this.y;
        }

        public MutablePoint move(final int deltaX, final int deltaY) {
            this.x += deltaX;
            this.y += deltaY;
            return this;
        }
    }

    private static long[] testImmutable(final int[][] delta) {
        final long startTime = System.nanoTime();
        ImmutablePoint immutablePoint = new ImmutablePoint(0, 0);
        for(int i = 0; i &lt; delta.length; ++i) {
            for(int j = 0; j &lt; delta[i].length; j += 2) {
                immutablePoint = immutablePoint.move(delta[i][j], delta[i][j + 1]);
            }
        }
        return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};
    }

    private static long[] testMutable(final int[][] delta) {
        final long startTime = System.nanoTime();
        MutablePoint mutablePoint = new MutablePoint(0, 0);
        for(int i = 0; i &lt; delta.length; ++i) {
            for(int j = 0; j &lt; delta[i].length; j += 2) {
                mutablePoint.move(delta[i][j], delta[i][j + 1]);
            }
        }
        return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};
    }

    //Usage Benchmarker 0 for immutable, 1 for mutable
    public static void main(String[] args) {
        if(args.length != 1) {
            return;
        }

        final int deltaSize = 4096;
        int[][] delta = new int[deltaSize][deltaSize];
        for(int i = 0; i &lt; delta.length; ++i) {
            for(int j = 0; j &lt; delta[i].length; ++j) {
                delta[i][j] = (int) Math.random() * 999;
            }
        }

        switch(Integer.parseInt(args[0])) {
            case 0: {
                long[] immutableRes = testImmutable(delta);
                System.out.printf("testImmutable:\t%dns\t%d kbytes\n", immutableRes[0], immutableRes[1] / 1024);
            }
                break;
            case 1: {
                long[] mutableRes = testMutable(delta);
                System.out.printf("testMutable:\t%dns\t%d kbytes\n", mutableRes[0], mutableRes[1] / 1024);
            }
                break;
            default:
                return;
        }
    }
}</code></pre>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>

          <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
          </div>

  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Docent.html'><span itemprop='name'>Docent</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T01:18:08Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:38Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#30</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Alright, good to know!</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/zyle1992.html'><span itemprop='name'>zyle1992</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T02:40:04Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:39Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#31</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚Äút4, post:29, topic:547713‚Äù][quote author=Zymus link=topic=666617.msg4457997#msg4457997 date=1416004896]</p>
<aside class="quote">
<blockquote>
<p>It‚Äôs not the fact it‚Äôs a class, it‚Äôs the fact it‚Äôs immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote">
<blockquote>
<p>It‚Äôs not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you‚Äôre adding overhead for no good reason.</p>
</blockquote>
</aside>
<p>This is how it‚Äôs been in every corporate environment I‚Äôve worked in. The benefit of having an class rather than a set of primitives out-weigh the negligible performance cost. Here is an excerpt of an article written by IBM about the performance of immutable objects:</p>
<aside class="quote">
<blockquote>
<p>No installment of Java theory and practice would be complete without some sort of plug for immutability. Making objects immutable eliminates entire classes of programming errors. One of the most common reasons given for not making a class immutable is the belief that doing so would compromise performance. While this is true sometimes, it is often not ‚Äì and sometimes the use of immutable objects has significant, and perhaps surprising, performance advantages.</p>
<p>Many objects function as containers for references to other objects. When the referenced object needs to change, we have two choices: update the reference (as we would in a mutable container class) or re-create the container to hold a new reference (as we would in an immutable container class). Listing 5 shows two ways to implement a simple holder class. Assuming the containing object is small, which is often the case (such as a Map.Entry element in a Map or a linked list element), allocating a new immutable object has some hidden performance advantages that come from the way generational garbage collectors work, having to do with the relative age of objects.<br>
Listing 5. Mutable and immutable object holders</p>
<pre><code class="lang-auto">public class MutableHolder {
  private Object value;
  public Object getValue() { return value; }
  public void setValue(Object o) { value = o; }
}</code></pre>
<p><code>
public class ImmutableHolder {
  private final Object value;
  public ImmutableHolder(Object o) { value = o; }
  public Object getValue() { return value; }
}</code></p>
<p>In most cases, when a holder object is updated to reference a different object, the new referent is a young object. If we update a MutableHolder by calling setValue(), we have created a situation where an older object references a younger one. On the other hand, by creating a new ImmutableHolder object instead, a younger object is referencing an older one. The latter situation, where most objects point to older objects, is much more gentle on a generational garbage collector. If a MutableHolder that lives in the old generation is mutated, all the objects on the card that contain the MutableHolder must be scanned for old-to-young references at the next minor collection. The use of mutable references for long-lived container objects increases the work done to track old-to-young references at collection time. (See last month‚Äôs article and this month‚Äôs Resources, which explain the card-marking algorithm used to implement the write barrier in the generational collector used by current Sun JVMs).</p>
</blockquote>
</aside>
<p>Found <a href="http://www.ibm.com/developerworks/java/library/j-jtp01274/index.html" data-bbcode="true">here</a>. And the article was accurate as of Jan 27 2004.<br>
[/quote]</p>
<aside class="quote">
<blockquote>
<p>testImmutable:	48070515ns	219136 kbytes<br>
testImmutable:	51471351ns	210944 kbytes<br>
testImmutable:	47096725ns	202752 kbytes<br>
testImmutable:	49465237ns	206336 kbytes<br>
testImmutable:	48414874ns	205312 kbytes</p>
</blockquote>
</aside>
<aside class="quote">
<blockquote>
<p>testMutable:	24166644ns	147456 kbytes<br>
testMutable:	25280271ns	152064 kbytes<br>
testMutable:	22732076ns	152576 kbytes<br>
testMutable:	23517686ns	152576 kbytes<br>
testMutable:	23391368ns	150016 kbytes</p>
</blockquote>
</aside>
<p>Well what do you know, immutable object manipulation requires more clock time and memory, it‚Äôs almost like it‚Äôs common sense or something! :eek:</p>
<p>[code=Java]<br>
/**</p>
<ul>
<li>
<p>Created by t4 on 11/14/14.<br>
*/<br>
public class Benchmarker {</p>
<p>public static class ImmutablePoint {<br>
private final int x, y;</p>
<pre><code> public ImmutablePoint(final int x, final int y) {
     this.x = x;
     this.y = y;
 }

 public int getX() {
     return this.x;
 }

 public int getY() {
     return this.y;
 }

 public ImmutablePoint move(final int deltaX, final int deltaY) {
     return new ImmutablePoint(this.x + deltaX, this.y + deltaY);
 }
</code></pre>
<p>}</p>
<p>public static class MutablePoint {<br>
private int x, y;</p>
<pre><code> public MutablePoint(final int x, final int y) {
     this.x = x;
     this.y = y;
 }

 public int getX() {
     return this.x;
 }

 public int getY() {
     return this.y;
 }

 public MutablePoint move(final int deltaX, final int deltaY) {
     this.x += deltaX;
     this.y += deltaY;
     return this;
 }
</code></pre>
<p>}</p>
<p>private static long[] testImmutable(final int[][] delta) {<br>
final long startTime = System.nanoTime();<br>
ImmutablePoint immutablePoint = new ImmutablePoint(0, 0);<br>
for(int i = 0; i &lt; delta.length; ++i) {<br>
for(int j = 0; j &lt; delta[i].length; j += 2) {<br>
immutablePoint = immutablePoint.move(delta[i][j], delta[i][j + 1]);<br>
}<br>
}<br>
return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};<br>
}</p>
<p>private static long[] testMutable(final int[][] delta) {<br>
final long startTime = System.nanoTime();<br>
MutablePoint mutablePoint = new MutablePoint(0, 0);<br>
for(int i = 0; i &lt; delta.length; ++i) {<br>
for(int j = 0; j &lt; delta[i].length; j += 2) {<br>
mutablePoint.move(delta[i][j], delta[i][j + 1]);<br>
}<br>
}<br>
return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};<br>
}</p>
<p>//Usage Benchmarker 0 for immutable, 1 for mutable<br>
public static void main(String[] args) {<br>
if(args.length != 1) {<br>
return;<br>
}</p>
<pre><code> final int deltaSize = 4096;
 int[][] delta = new int[deltaSize][deltaSize];
 for(int i = 0; i &lt; delta.length; ++i) {
     for(int j = 0; j &lt; delta[i].length; ++j) {
         delta[i][j] = (int) Math.random() * 999;
     }
 }

 switch(Integer.parseInt(args[0])) {
     case 0: {
         long[] immutableRes = testImmutable(delta);
         System.out.printf("testImmutable:\t%dns\t%d kbytes\n", immutableRes[0], immutableRes[1] / 1024);
     }
         break;
     case 1: {
         long[] mutableRes = testMutable(delta);
         System.out.printf("testMutable:\t%dns\t%d kbytes\n", mutableRes[0], mutableRes[1] / 1024);
     }
         break;
     default:
         return;
 }
</code></pre>
<p>}<br>
}<br>
[/code][/quote]</p>
</li>
</ul>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that‚Äôs being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we‚Äôre REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don‚Äôt really need it that bad</span>. Also, this was a very edge case scenario. I don‚Äôt think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>

          <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
          </div>

  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/T41.html'><span itemprop='name'>T41</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T03:02:21Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:39Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#32</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <aside class="quote" data-post="31" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
 Zymus:</div>
<blockquote>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that‚Äôs being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we‚Äôre REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don‚Äôt really need it that bad</span>. Also, this was a very edge case scenario. I don‚Äôt think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
</blockquote>
</aside>
<p>Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here‚Äôs the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can‚Äôt go and say immutable objects are the ‚Äòbest way‚Äô/‚Äòmost proper way‚Äô to design something because you don‚Äôt have a context (ex: performance constrains or the constraints on the object‚Äôs mutability).</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="2" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Docent.html'><span itemprop='name'>Docent</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T03:04:22Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:39Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#33</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚Äút4, post:32, topic:547713‚Äù][quote author=Zymus link=topic=666617.msg4458029#msg4458029 date=1416019204]<br>
I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that‚Äôs being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we‚Äôre REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don‚Äôt really need it that bad</span>. Also, this was a very edge case scenario. I don‚Äôt think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.<br>
[/quote]<br>
Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here‚Äôs the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can‚Äôt go and say immutable objects are the ‚Äòbest way‚Äô/‚Äòmost proper way‚Äô to design something because you don‚Äôt have a context (ex: performance constrains or the constraints on the object‚Äôs mutability).[/quote]<br>
I removed the Location class and put the x, y, and z values in the Entity superclass.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/zyle1992.html'><span itemprop='name'>zyle1992</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T04:24:14Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:39Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#34</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚Äút4, post:32, topic:547713‚Äù][quote author=Zymus link=topic=666617.msg4458029#msg4458029 date=1416019204]<br>
I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that‚Äôs being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we‚Äôre REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don‚Äôt really need it that bad</span>. Also, this was a very edge case scenario. I don‚Äôt think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.<br>
[/quote]<br>
Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here‚Äôs the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can‚Äôt go and say immutable objects are the ‚Äòbest way‚Äô/‚Äòmost proper way‚Äô to design something because you don‚Äôt have a context (ex: performance constrains or the constraints on the object‚Äôs mutability).[/quote]</p>
<p>I never said it was the best way, or the most proper way. As I stated before, there are some cases where it‚Äôs necessary, and some where the benefits of having it that way out-weigh the performance hit. As you said, it was 2x the clock time, and 1.3x the memory; when processing 16 <span class="bbcode-b">million</span> more objects. A situation that will never come up during normal, or even extremely heavy load. Also, ‚Äúgiven a context‚Äù, any operation, or set of operations, can take an infinite amount of time, and consume an infinite amount of memory. Does that mean that we shouldn‚Äôt do it that way, because ‚Äúgiven a context‚Äù it exceeds our constraints? No. Because the constraints for an RSPS, under normal load, the difference between the two methods is perhaps 10ms longer, and perhaps 500KB of RAM.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/T41.html'><span itemprop='name'>T41</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T05:04:02Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:39Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#35</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚ÄúZymus, post:34, topic:547713‚Äù][quote author=t4 link=topic=666617.msg4458031#msg4458031 date=1416020541]</p>
<aside class="quote">
<blockquote>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that‚Äôs being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we‚Äôre REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don‚Äôt really need it that bad</span>. Also, this was a very edge case scenario. I don‚Äôt think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
</blockquote>
</aside>
<p>Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here‚Äôs the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can‚Äôt go and say immutable objects are the ‚Äòbest way‚Äô/‚Äòmost proper way‚Äô to design something because you don‚Äôt have a context (ex: performance constrains or the constraints on the object‚Äôs mutability).<br>
[/quote]</p>
<p>I never said it was the best way, or the most proper way. As I stated before, there are some cases where it‚Äôs necessary, and some where the benefits of having it that way out-weigh the performance hit. As you said, it was 2x the clock time, and 1.3x the memory; when processing 16 <span class="bbcode-b">million</span> more objects. A situation that will never come up during normal, or even extremely heavy load. Also, ‚Äúgiven a context‚Äù, any operation, or set of operations, can take an infinite amount of time, and consume an infinite amount of memory. Does that mean that we shouldn‚Äôt do it that way, because ‚Äúgiven a context‚Äù it exceeds our constraints? No. Because the constraints for an RSPS, under normal load, the difference between the two methods is perhaps 10ms longer, and perhaps 500KB of RAM.[/quote]<br>
The example I provided is actually 8.38 million objects (not that it matters). Regardless, what makes you think that 16 million objects will never come up during normal, or even extremely heavy load? Have you ever dealt with code that needs to scale to thousands or more concurrent users? What if the object you plan to make immutable encapsulates more than just two or three 32 bit values?</p>
<aside class="quote" data-post="8" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
 Zymus:</div>
<blockquote>
<p>To conform more to OOP</p>
</blockquote>
</aside>
<p>You‚Äôre implying that the immutable Point example conforms to object oriented programming.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/zyle1992.html'><span itemprop='name'>zyle1992</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T05:26:25Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:40Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#36</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚Äút4, post:35, topic:547713‚Äù][quote author=Zymus link=topic=666617.msg4458040#msg4458040 date=1416025454]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that‚Äôs being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we‚Äôre REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don‚Äôt really need it that bad</span>. Also, this was a very edge case scenario. I don‚Äôt think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
</blockquote>
</aside>
<p>Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here‚Äôs the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can‚Äôt go and say immutable objects are the ‚Äòbest way‚Äô/‚Äòmost proper way‚Äô to design something because you don‚Äôt have a context (ex: performance constrains or the constraints on the object‚Äôs mutability).</p>
</blockquote>
</aside>
<p>I never said it was the best way, or the most proper way. As I stated before, there are some cases where it‚Äôs necessary, and some where the benefits of having it that way out-weigh the performance hit. As you said, it was 2x the clock time, and 1.3x the memory; when processing 16 <span class="bbcode-b">million</span> more objects. A situation that will never come up during normal, or even extremely heavy load. Also, ‚Äúgiven a context‚Äù, any operation, or set of operations, can take an infinite amount of time, and consume an infinite amount of memory. Does that mean that we shouldn‚Äôt do it that way, because ‚Äúgiven a context‚Äù it exceeds our constraints? No. Because the constraints for an RSPS, under normal load, the difference between the two methods is perhaps 10ms longer, and perhaps 500KB of RAM.<br>
[/quote]<br>
The example I provided is actually 8.38 million objects (not that it matters). Regardless, what makes you think that 16 million objects will never come up during normal, or even extremely heavy load? Have you ever dealt with code that needs to scale to thousands or more concurrent users? What if the object you plan to make immutable encapsulates more than just two or three 32 bit values?</p>
<aside class="quote">
<blockquote>
<p>To conform more to OOP</p>
</blockquote>
</aside>
<p>You‚Äôre implying that the immutable Point example conforms to object oriented programming.[/quote]</p>
<p>4096^2 is ~16 million. And yes, I deal with hundreds of thousands of concurrent users literally on a day-to-day basis at my job. And we have immutable classes everywhere; even the most used classes. Granted, we inherited a system that was utter garbage in terms of maintainability, and there is only about 2% of the code covered during unit testing. But that‚Äôs another matter.</p>
<p>The point is, he asked which way is more OO. Having it immutable is more OO. It follows all pillars of OOP, and the SOLID principles (not all of them, obviously).</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Docent.html'><span itemprop='name'>Docent</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T05:29:10Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:40Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#37</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>I asked whether protected variables in the superclass are more OO than private variables in the superclass with getters</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/zyle1992.html'><span itemprop='name'>zyle1992</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T05:36:56Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:40Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#38</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <aside class="quote" data-post="37" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
 Limits:</div>
<blockquote>
<p>I asked whether protected variables in the superclass are more OO than private variables in the superclass with getters</p>
</blockquote>
</aside>
<p>Private variables with getters.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Docent.html'><span itemprop='name'>Docent</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T05:37:43Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:40Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#39</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=‚ÄúZymus, post:38, topic:547713‚Äù][quote author=Limits link=topic=666617.msg4458047#msg4458047 date=1416029350]<br>
I asked whether protected variables in the superclass are more OO than private variables in the superclass with getters<br>
[/quote]</p>
<p>Private variables with getters.[/quote]<br>
Alright thanks</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Mopman.html'><span itemprop='name'>Mopman</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-11-15T14:23:17Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:58:41Z' class='post-time'>
              August 4, 2016,  1:58pm
            </time>
        <span itemprop='position'>#40</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>What use is a term like ‚Äòmore OO‚Äô? It‚Äôs not like we have an OO Qur‚Äôan to base this on.</p>
      </div>

      <meta itemprop='headline' content='Which way is more OOP-like'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>

  <div role='navigation' itemscope itemtype='http://schema.org/SiteNavigationElement' class="topic-body crawler-post">
      <span itemprop='name'><a rel="prev" itemprop="url" href="547713.html">‚Üê previous page</a></span>
      <span itemprop='name'><b><a rel="next" itemprop="url" href="5477139ba9.html?page=3">next page ‚Üí</a></b></span>
  </div>





    </div>
    <footer class="container wrap">
      <nav class='crawler-nav' itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <ul>
        <li itemprop="name"><a href='../../index.html' itemprop="url">Home </a></li>
        <li itemprop="name"><a href='../../categories.html' itemprop="url">Categories </a></li>
        <li itemprop="name"><a href='../../guidelines.html' itemprop="url">FAQ/Guidelines </a></li>
        <li itemprop="name"><a href='../../tos.html' itemprop="url">Terms of Service </a></li>
        <li itemprop="name"><a href='../../privacy.html' itemprop="url">Privacy Policy </a></li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
  </body>
  

<!-- Mirrored from forum.moparisthebest.com/t/which-way-is-more-oop-like/547713?page=2 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:59 GMT -->
</html>
