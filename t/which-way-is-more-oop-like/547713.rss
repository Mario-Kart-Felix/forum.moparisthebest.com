<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Which way is more OOP-like</title>
    <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713</link>
    <description>I have an Entity class and I have the Player and the Enemy as subclasses of the Entity class.


The Entity class has the variables x, y, and z. Should these variables be private or protected? Is it more OOP-like to access these variables from its subclasses using getters or to access them directly?


Ex:
[code=java5]
public class Entity {
     private double x, y, z;
     public double getX() {
          return x;
     }

     public double getY() {
          return y;
     }

     public double getZ() {
          return z;
     }
}[/code]



[code=java5]
public class Player extends Entity {
     private void doStuff() {
          player.move(getX() + 50, getY(), getZ());
     }
}[/code]


OR



[code=java5]
public class Entity {
     protected double x, y, z;
     public double getX() {
          return x;
     }

     public double getY() {
          return y;
     }

     public double getZ() {
          return z;
     }
}[/code]



[code=java5]
public class Player extends Entity {
     private void doStuff() {
          player.move(x + 50, y, z);
     }
}[/code]</description>
    
    <lastBuildDate>Sun, 16 Nov 2014 17:22:12 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Yz85Racer, post:47, topic:547713”][quote author=t4 link=topic=666617.msg4458218#msg4458218 date=1416121416]</p>
<aside class="quote">
<blockquote>
<p>tl;dr on what scale is object oriented measured on anyway?</p>
</blockquote>
</aside>
<p>What scale? Do you mean what are the metrics to determine if something is of the object-oriented paradigm?<br>
[/quote]<br>
no I mean, oop is somewhat just a design pattern, correct? is it really a matter of which is “more oop”?[/quote]<br>
It’s not exactly a design pattern, a design pattern is a solution to a common problem. OO is a programming paradigm (a programming style).</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/50">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/50</link>
        <pubDate>Sun, 16 Nov 2014 17:22:12 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-50</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Ashi Ashi]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ashi">@Ashi</a> wrote:</p>
          <blockquote>
              <p>[quote=“Yz85Racer, post:47, topic:547713”][quote author=t4 link=topic=666617.msg4458218#msg4458218 date=1416121416]</p>
<aside class="quote">
<blockquote>
<p>tl;dr on what scale is object oriented measured on anyway?</p>
</blockquote>
</aside>
<p>What scale? Do you mean what are the metrics to determine if something is of the object-oriented paradigm?<br>
[/quote]<br>
no I mean, oop is somewhat just a design pattern, correct? is it really a matter of which is “more oop”?[/quote]<br>
That’s pretty much what everybody is talking about. It is just a matter of how you design your app. Hence Zymus’s example.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/49">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/49</link>
        <pubDate>Sun, 16 Nov 2014 11:05:03 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-49</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@HcoJustin HcoJustin]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/hcojustin">@HcoJustin</a> wrote:</p>
          <blockquote>
              <p>Maybe you could measure it on how closely it follows those design principles</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/48">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/48</link>
        <pubDate>Sun, 16 Nov 2014 08:41:15 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-48</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Yz85Racer Yz85Racer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yz85racer">@Yz85Racer</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:46, topic:547713”][quote author=Yz85Racer link=topic=666617.msg4458203#msg4458203 date=1416117374]<br>
tl;dr on what scale is object oriented measured on anyway?<br>
[/quote]<br>
What scale? Do you mean what are the metrics to determine if something is of the object-oriented paradigm?[/quote]<br>
no I mean, oop is somewhat just a design pattern, correct? is it really a matter of which is “more oop”?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/47">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/47</link>
        <pubDate>Sun, 16 Nov 2014 07:19:59 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-47</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="45" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/yz85racer/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> Yz85Racer:</div>
<blockquote>
<p>tl;dr on what scale is object oriented measured on anyway?</p>
</blockquote>
</aside>
<p>What scale? Do you mean what are the metrics to determine if something is of the object-oriented paradigm?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/46">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/46</link>
        <pubDate>Sun, 16 Nov 2014 07:03:36 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-46</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Yz85Racer Yz85Racer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yz85racer">@Yz85Racer</a> wrote:</p>
          <blockquote>
              <p>tl;dr on what scale is object oriented measured on anyway?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/45">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/45</link>
        <pubDate>Sun, 16 Nov 2014 05:56:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-45</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Zymus, post:36, topic:547713”]4096^2 is ~16 million. And yes, I deal with hundreds of thousands of concurrent users literally on a day-to-day basis at my job. And we have immutable classes everywhere; even the most used classes. Granted, we inherited a system that was utter garbage in terms of maintainability, and there is only about 2% of the code covered during unit testing. But that’s another matter.</p>
<p>The point is, he asked which way is more OO. Having it immutable is more OO. It follows all pillars of OOP, and the SOLID principles (not all of them, obviously).[/quote]<br>
4096*(4096/2) is about 8 million. OO programming does not imply immutability, OO simply means object-oriented design which means that the structure of the applications is broken up into function/data containers that mimic the real world (ex: a Stove can turnOn(), turnOff(), and cook()).</p>
<p>Oh look, <a href="https://en.wikipedia.org/wiki/Object-oriented_design" rel="nofollow noopener">https://en.wikipedia.org/wiki/Object-oriented_design</a> does not contain the word mutable.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/44">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/44</link>
        <pubDate>Sat, 15 Nov 2014 16:43:01 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-44</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Mopman Mopman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mopman">@Mopman</a> wrote:</p>
          <blockquote>
              <p>But it’s entirely subjective!</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/43">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/43</link>
        <pubDate>Sat, 15 Nov 2014 15:29:55 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-43</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Docent Limits]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/docent">@Docent</a> wrote:</p>
          <blockquote>
              <p>Hard to explain lol. Basically how to write it like a java god would.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/42">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/42</link>
        <pubDate>Sat, 15 Nov 2014 15:11:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-42</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Ashi Ashi]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ashi">@Ashi</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="40" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/user_avatar/forum.moparisthebest.com/mopman/40/33_1.png" class="avatar"> Mopman:</div>
<blockquote>
<p>What use is a term like ‘more OO’? It’s not like we have an OO Qur’an to base this on.</p>
</blockquote>
</aside>
<p>oreilly</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/41">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/41</link>
        <pubDate>Sat, 15 Nov 2014 14:29:18 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-41</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Mopman Mopman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mopman">@Mopman</a> wrote:</p>
          <blockquote>
              <p>What use is a term like ‘more OO’? It’s not like we have an OO Qur’an to base this on.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/40">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/40</link>
        <pubDate>Sat, 15 Nov 2014 14:23:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-40</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Docent Limits]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/docent">@Docent</a> wrote:</p>
          <blockquote>
              <p>[quote=“Zymus, post:38, topic:547713”][quote author=Limits link=topic=666617.msg4458047#msg4458047 date=1416029350]<br>
I asked whether protected variables in the superclass are more OO than private variables in the superclass with getters<br>
[/quote]</p>
<p>Private variables with getters.[/quote]<br>
Alright thanks</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/39">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/39</link>
        <pubDate>Sat, 15 Nov 2014 05:37:43 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-39</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@zyle1992 Zymus]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/zyle1992">@zyle1992</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="37" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
 Limits:</div>
<blockquote>
<p>I asked whether protected variables in the superclass are more OO than private variables in the superclass with getters</p>
</blockquote>
</aside>
<p>Private variables with getters.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/38">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/38</link>
        <pubDate>Sat, 15 Nov 2014 05:36:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-38</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Docent Limits]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/docent">@Docent</a> wrote:</p>
          <blockquote>
              <p>I asked whether protected variables in the superclass are more OO than private variables in the superclass with getters</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/37">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/37</link>
        <pubDate>Sat, 15 Nov 2014 05:29:10 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-37</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@zyle1992 Zymus]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/zyle1992">@zyle1992</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:35, topic:547713”][quote author=Zymus link=topic=666617.msg4458040#msg4458040 date=1416025454]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that’s being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we’re REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don’t really need it that bad</span>. Also, this was a very edge case scenario. I don’t think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
</blockquote>
</aside>
<p>Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here’s the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can’t go and say immutable objects are the ‘best way’/‘most proper way’ to design something because you don’t have a context (ex: performance constrains or the constraints on the object’s mutability).</p>
</blockquote>
</aside>
<p>I never said it was the best way, or the most proper way. As I stated before, there are some cases where it’s necessary, and some where the benefits of having it that way out-weigh the performance hit. As you said, it was 2x the clock time, and 1.3x the memory; when processing 16 <span class="bbcode-b">million</span> more objects. A situation that will never come up during normal, or even extremely heavy load. Also, “given a context”, any operation, or set of operations, can take an infinite amount of time, and consume an infinite amount of memory. Does that mean that we shouldn’t do it that way, because “given a context” it exceeds our constraints? No. Because the constraints for an RSPS, under normal load, the difference between the two methods is perhaps 10ms longer, and perhaps 500KB of RAM.<br>
[/quote]<br>
The example I provided is actually 8.38 million objects (not that it matters). Regardless, what makes you think that 16 million objects will never come up during normal, or even extremely heavy load? Have you ever dealt with code that needs to scale to thousands or more concurrent users? What if the object you plan to make immutable encapsulates more than just two or three 32 bit values?</p>
<aside class="quote">
<blockquote>
<p>To conform more to OOP</p>
</blockquote>
</aside>
<p>You’re implying that the immutable Point example conforms to object oriented programming.[/quote]</p>
<p>4096^2 is ~16 million. And yes, I deal with hundreds of thousands of concurrent users literally on a day-to-day basis at my job. And we have immutable classes everywhere; even the most used classes. Granted, we inherited a system that was utter garbage in terms of maintainability, and there is only about 2% of the code covered during unit testing. But that’s another matter.</p>
<p>The point is, he asked which way is more OO. Having it immutable is more OO. It follows all pillars of OOP, and the SOLID principles (not all of them, obviously).</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/36">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/36</link>
        <pubDate>Sat, 15 Nov 2014 05:26:25 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-36</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Zymus, post:34, topic:547713”][quote author=t4 link=topic=666617.msg4458031#msg4458031 date=1416020541]</p>
<aside class="quote">
<blockquote>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that’s being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we’re REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don’t really need it that bad</span>. Also, this was a very edge case scenario. I don’t think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
</blockquote>
</aside>
<p>Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here’s the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can’t go and say immutable objects are the ‘best way’/‘most proper way’ to design something because you don’t have a context (ex: performance constrains or the constraints on the object’s mutability).<br>
[/quote]</p>
<p>I never said it was the best way, or the most proper way. As I stated before, there are some cases where it’s necessary, and some where the benefits of having it that way out-weigh the performance hit. As you said, it was 2x the clock time, and 1.3x the memory; when processing 16 <span class="bbcode-b">million</span> more objects. A situation that will never come up during normal, or even extremely heavy load. Also, “given a context”, any operation, or set of operations, can take an infinite amount of time, and consume an infinite amount of memory. Does that mean that we shouldn’t do it that way, because “given a context” it exceeds our constraints? No. Because the constraints for an RSPS, under normal load, the difference between the two methods is perhaps 10ms longer, and perhaps 500KB of RAM.[/quote]<br>
The example I provided is actually 8.38 million objects (not that it matters). Regardless, what makes you think that 16 million objects will never come up during normal, or even extremely heavy load? Have you ever dealt with code that needs to scale to thousands or more concurrent users? What if the object you plan to make immutable encapsulates more than just two or three 32 bit values?</p>
<aside class="quote" data-post="8" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
 Zymus:</div>
<blockquote>
<p>To conform more to OOP</p>
</blockquote>
</aside>
<p>You’re implying that the immutable Point example conforms to object oriented programming.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/35">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/35</link>
        <pubDate>Sat, 15 Nov 2014 05:04:02 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-35</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@zyle1992 Zymus]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/zyle1992">@zyle1992</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:32, topic:547713”][quote author=Zymus link=topic=666617.msg4458029#msg4458029 date=1416019204]<br>
I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that’s being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we’re REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don’t really need it that bad</span>. Also, this was a very edge case scenario. I don’t think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.<br>
[/quote]<br>
Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here’s the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can’t go and say immutable objects are the ‘best way’/‘most proper way’ to design something because you don’t have a context (ex: performance constrains or the constraints on the object’s mutability).[/quote]</p>
<p>I never said it was the best way, or the most proper way. As I stated before, there are some cases where it’s necessary, and some where the benefits of having it that way out-weigh the performance hit. As you said, it was 2x the clock time, and 1.3x the memory; when processing 16 <span class="bbcode-b">million</span> more objects. A situation that will never come up during normal, or even extremely heavy load. Also, “given a context”, any operation, or set of operations, can take an infinite amount of time, and consume an infinite amount of memory. Does that mean that we shouldn’t do it that way, because “given a context” it exceeds our constraints? No. Because the constraints for an RSPS, under normal load, the difference between the two methods is perhaps 10ms longer, and perhaps 500KB of RAM.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/34">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/34</link>
        <pubDate>Sat, 15 Nov 2014 04:24:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-34</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Docent Limits]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/docent">@Docent</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:32, topic:547713”][quote author=Zymus link=topic=666617.msg4458029#msg4458029 date=1416019204]<br>
I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that’s being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we’re REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don’t really need it that bad</span>. Also, this was a very edge case scenario. I don’t think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.<br>
[/quote]<br>
Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here’s the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can’t go and say immutable objects are the ‘best way’/‘most proper way’ to design something because you don’t have a context (ex: performance constrains or the constraints on the object’s mutability).[/quote]<br>
I removed the Location class and put the x, y, and z values in the Entity superclass.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/33">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/33</link>
        <pubDate>Sat, 15 Nov 2014 03:04:22 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-33</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="31" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
 Zymus:</div>
<blockquote>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that’s being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we’re REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don’t really need it that bad</span>. Also, this was a very edge case scenario. I don’t think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
</blockquote>
</aside>
<p>Is 2x the clock time and 1.3x more memory negligible? Given a context, it may or may not be; however, the cost is certainty not negligible as the performance is impacted by a significant multiplier. See, here’s the thing: the decision to make the object immutable is the same design decision process as deciding that 111ms or 100MB of memory matters given a context. You can’t go and say immutable objects are the ‘best way’/‘most proper way’ to design something because you don’t have a context (ex: performance constrains or the constraints on the object’s mutability).</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/32">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/32</link>
        <pubDate>Sat, 15 Nov 2014 03:02:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-32</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@zyle1992 Zymus]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/zyle1992">@zyle1992</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:29, topic:547713”][quote author=Zymus link=topic=666617.msg4457997#msg4457997 date=1416004896]</p>
<aside class="quote">
<blockquote>
<p>It’s not the fact it’s a class, it’s the fact it’s immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote">
<blockquote>
<p>It’s not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you’re adding overhead for no good reason.</p>
</blockquote>
</aside>
<p>This is how it’s been in every corporate environment I’ve worked in. The benefit of having an class rather than a set of primitives out-weigh the negligible performance cost. Here is an excerpt of an article written by IBM about the performance of immutable objects:</p>
<aside class="quote">
<blockquote>
<p>No installment of Java theory and practice would be complete without some sort of plug for immutability. Making objects immutable eliminates entire classes of programming errors. One of the most common reasons given for not making a class immutable is the belief that doing so would compromise performance. While this is true sometimes, it is often not – and sometimes the use of immutable objects has significant, and perhaps surprising, performance advantages.</p>
<p>Many objects function as containers for references to other objects. When the referenced object needs to change, we have two choices: update the reference (as we would in a mutable container class) or re-create the container to hold a new reference (as we would in an immutable container class). Listing 5 shows two ways to implement a simple holder class. Assuming the containing object is small, which is often the case (such as a Map.Entry element in a Map or a linked list element), allocating a new immutable object has some hidden performance advantages that come from the way generational garbage collectors work, having to do with the relative age of objects.<br>
Listing 5. Mutable and immutable object holders</p>
<pre><code class="lang-auto">public class MutableHolder {
  private Object value;
  public Object getValue() { return value; }
  public void setValue(Object o) { value = o; }
}</code></pre>
<p><code>
public class ImmutableHolder {
  private final Object value;
  public ImmutableHolder(Object o) { value = o; }
  public Object getValue() { return value; }
}</code></p>
<p>In most cases, when a holder object is updated to reference a different object, the new referent is a young object. If we update a MutableHolder by calling setValue(), we have created a situation where an older object references a younger one. On the other hand, by creating a new ImmutableHolder object instead, a younger object is referencing an older one. The latter situation, where most objects point to older objects, is much more gentle on a generational garbage collector. If a MutableHolder that lives in the old generation is mutated, all the objects on the card that contain the MutableHolder must be scanned for old-to-young references at the next minor collection. The use of mutable references for long-lived container objects increases the work done to track old-to-young references at collection time. (See last month’s article and this month’s Resources, which explain the card-marking algorithm used to implement the write barrier in the generational collector used by current Sun JVMs).</p>
</blockquote>
</aside>
<p>Found <a href="http://www.ibm.com/developerworks/java/library/j-jtp01274/index.html" data-bbcode="true">here</a>. And the article was accurate as of Jan 27 2004.<br>
[/quote]</p>
<aside class="quote">
<blockquote>
<p>testImmutable:	48070515ns	219136 kbytes<br>
testImmutable:	51471351ns	210944 kbytes<br>
testImmutable:	47096725ns	202752 kbytes<br>
testImmutable:	49465237ns	206336 kbytes<br>
testImmutable:	48414874ns	205312 kbytes</p>
</blockquote>
</aside>
<aside class="quote">
<blockquote>
<p>testMutable:	24166644ns	147456 kbytes<br>
testMutable:	25280271ns	152064 kbytes<br>
testMutable:	22732076ns	152576 kbytes<br>
testMutable:	23517686ns	152576 kbytes<br>
testMutable:	23391368ns	150016 kbytes</p>
</blockquote>
</aside>
<p>Well what do you know, immutable object manipulation requires more clock time and memory, it’s almost like it’s common sense or something! :eek:</p>
<p>[code=Java]<br>
/**</p>
<ul>
<li>
<p>Created by t4 on 11/14/14.<br>
*/<br>
public class Benchmarker {</p>
<p>public static class ImmutablePoint {<br>
private final int x, y;</p>
<pre><code> public ImmutablePoint(final int x, final int y) {
     this.x = x;
     this.y = y;
 }

 public int getX() {
     return this.x;
 }

 public int getY() {
     return this.y;
 }

 public ImmutablePoint move(final int deltaX, final int deltaY) {
     return new ImmutablePoint(this.x + deltaX, this.y + deltaY);
 }
</code></pre>
<p>}</p>
<p>public static class MutablePoint {<br>
private int x, y;</p>
<pre><code> public MutablePoint(final int x, final int y) {
     this.x = x;
     this.y = y;
 }

 public int getX() {
     return this.x;
 }

 public int getY() {
     return this.y;
 }

 public MutablePoint move(final int deltaX, final int deltaY) {
     this.x += deltaX;
     this.y += deltaY;
     return this;
 }
</code></pre>
<p>}</p>
<p>private static long[] testImmutable(final int[][] delta) {<br>
final long startTime = System.nanoTime();<br>
ImmutablePoint immutablePoint = new ImmutablePoint(0, 0);<br>
for(int i = 0; i &lt; delta.length; ++i) {<br>
for(int j = 0; j &lt; delta[i].length; j += 2) {<br>
immutablePoint = immutablePoint.move(delta[i][j], delta[i][j + 1]);<br>
}<br>
}<br>
return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};<br>
}</p>
<p>private static long[] testMutable(final int[][] delta) {<br>
final long startTime = System.nanoTime();<br>
MutablePoint mutablePoint = new MutablePoint(0, 0);<br>
for(int i = 0; i &lt; delta.length; ++i) {<br>
for(int j = 0; j &lt; delta[i].length; j += 2) {<br>
mutablePoint.move(delta[i][j], delta[i][j + 1]);<br>
}<br>
}<br>
return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};<br>
}</p>
<p>//Usage Benchmarker 0 for immutable, 1 for mutable<br>
public static void main(String[] args) {<br>
if(args.length != 1) {<br>
return;<br>
}</p>
<pre><code> final int deltaSize = 4096;
 int[][] delta = new int[deltaSize][deltaSize];
 for(int i = 0; i &lt; delta.length; ++i) {
     for(int j = 0; j &lt; delta[i].length; ++j) {
         delta[i][j] = (int) Math.random() * 999;
     }
 }

 switch(Integer.parseInt(args[0])) {
     case 0: {
         long[] immutableRes = testImmutable(delta);
         System.out.printf("testImmutable:\t%dns\t%d kbytes\n", immutableRes[0], immutableRes[1] / 1024);
     }
         break;
     case 1: {
         long[] mutableRes = testMutable(delta);
         System.out.printf("testMutable:\t%dns\t%d kbytes\n", mutableRes[0], mutableRes[1] / 1024);
     }
         break;
     default:
         return;
 }
</code></pre>
<p>}<br>
}<br>
[/code][/quote]</p>
</li>
</ul>
<p>I never said it was faster, nor did I say it used less memory. What I said was, the performance cost is negligible when compared to the benefits of having it immutable. And all of that memory that’s being used will be garbage collected once it falls out of scope, and the garbage collector runs. So what we’re REALLY measuring here is <span class="bbcode-i">how bad do I really need those 100ms</span>. And the general consensus from people that have worked in the field longer than you and I, and have done more to progress the field, is that <span class="bbcode-u">you don’t really need it that bad</span>. Also, this was a very edge case scenario. I don’t think that the server will need to handle 16 million movement updates in one tick. BUT, if it does, it will use 100MB of RAM more, and take approximately 111ms longer.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/31">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/31</link>
        <pubDate>Sat, 15 Nov 2014 02:40:04 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-31</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Docent Limits]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/docent">@Docent</a> wrote:</p>
          <blockquote>
              <p>Alright, good to know!</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/30">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/30</link>
        <pubDate>Sat, 15 Nov 2014 01:18:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-30</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Zymus, post:28, topic:547713”][quote author=t4 link=topic=666617.msg4457992#msg4457992 date=1416004221]<br>
It’s not the fact it’s a class, it’s the fact it’s immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote">
<blockquote>
<p>It’s not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you’re adding overhead for no good reason.<br>
[/quote]</p>
<p>This is how it’s been in every corporate environment I’ve worked in. The benefit of having an class rather than a set of primitives out-weigh the negligible performance cost. Here is an excerpt of an article written by IBM about the performance of immutable objects:</p>
<aside class="quote">
<blockquote>
<p>No installment of Java theory and practice would be complete without some sort of plug for immutability. Making objects immutable eliminates entire classes of programming errors. One of the most common reasons given for not making a class immutable is the belief that doing so would compromise performance. While this is true sometimes, it is often not – and sometimes the use of immutable objects has significant, and perhaps surprising, performance advantages.</p>
<p>Many objects function as containers for references to other objects. When the referenced object needs to change, we have two choices: update the reference (as we would in a mutable container class) or re-create the container to hold a new reference (as we would in an immutable container class). Listing 5 shows two ways to implement a simple holder class. Assuming the containing object is small, which is often the case (such as a Map.Entry element in a Map or a linked list element), allocating a new immutable object has some hidden performance advantages that come from the way generational garbage collectors work, having to do with the relative age of objects.<br>
Listing 5. Mutable and immutable object holders</p>
<pre><code class="lang-auto">public class MutableHolder {
  private Object value;
  public Object getValue() { return value; }
  public void setValue(Object o) { value = o; }
}</code></pre>
<p><code>
public class ImmutableHolder {
  private final Object value;
  public ImmutableHolder(Object o) { value = o; }
  public Object getValue() { return value; }
}</code></p>
<p>In most cases, when a holder object is updated to reference a different object, the new referent is a young object. If we update a MutableHolder by calling setValue(), we have created a situation where an older object references a younger one. On the other hand, by creating a new ImmutableHolder object instead, a younger object is referencing an older one. The latter situation, where most objects point to older objects, is much more gentle on a generational garbage collector. If a MutableHolder that lives in the old generation is mutated, all the objects on the card that contain the MutableHolder must be scanned for old-to-young references at the next minor collection. The use of mutable references for long-lived container objects increases the work done to track old-to-young references at collection time. (See last month’s article and this month’s Resources, which explain the card-marking algorithm used to implement the write barrier in the generational collector used by current Sun JVMs).</p>
</blockquote>
</aside>
<p>Found <a href="http://www.ibm.com/developerworks/java/library/j-jtp01274/index.html" data-bbcode="true" rel="nofollow noopener">here</a>. And the article was accurate as of Jan 27 2004.[/quote]</p>
<blockquote>testImmutable:	48070515ns	219136 kbytes
testImmutable:	51471351ns	210944 kbytes
testImmutable:	47096725ns	202752 kbytes
testImmutable:	49465237ns	206336 kbytes
testImmutable:	48414874ns	205312 kbytes</blockquote>
<blockquote>testMutable:	24166644ns	147456 kbytes
testMutable:	25280271ns	152064 kbytes
testMutable:	22732076ns	152576 kbytes
testMutable:	23517686ns	152576 kbytes
testMutable:	23391368ns	150016 kbytes</blockquote>
<p>Well what do you know, immutable object manipulation requires more clock time and memory, it’s almost like it’s common sense or something! :eek:</p>
<pre><code class="lang-auto">/**
 * Created by t4 on 11/14/14.
 */
public class Benchmarker {

    public static class ImmutablePoint {
        private final int x, y;

        public ImmutablePoint(final int x, final int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return this.x;
        }

        public int getY() {
            return this.y;
        }

        public ImmutablePoint move(final int deltaX, final int deltaY) {
            return new ImmutablePoint(this.x + deltaX, this.y + deltaY);
        }
    }

    public static class MutablePoint {
        private int x, y;

        public MutablePoint(final int x, final int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return this.x;
        }

        public int getY() {
            return this.y;
        }

        public MutablePoint move(final int deltaX, final int deltaY) {
            this.x += deltaX;
            this.y += deltaY;
            return this;
        }
    }

    private static long[] testImmutable(final int[][] delta) {
        final long startTime = System.nanoTime();
        ImmutablePoint immutablePoint = new ImmutablePoint(0, 0);
        for(int i = 0; i &lt; delta.length; ++i) {
            for(int j = 0; j &lt; delta[i].length; j += 2) {
                immutablePoint = immutablePoint.move(delta[i][j], delta[i][j + 1]);
            }
        }
        return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};
    }

    private static long[] testMutable(final int[][] delta) {
        final long startTime = System.nanoTime();
        MutablePoint mutablePoint = new MutablePoint(0, 0);
        for(int i = 0; i &lt; delta.length; ++i) {
            for(int j = 0; j &lt; delta[i].length; j += 2) {
                mutablePoint.move(delta[i][j], delta[i][j + 1]);
            }
        }
        return new long[] {System.nanoTime() - startTime, Runtime.getRuntime().totalMemory()};
    }

    //Usage Benchmarker 0 for immutable, 1 for mutable
    public static void main(String[] args) {
        if(args.length != 1) {
            return;
        }

        final int deltaSize = 4096;
        int[][] delta = new int[deltaSize][deltaSize];
        for(int i = 0; i &lt; delta.length; ++i) {
            for(int j = 0; j &lt; delta[i].length; ++j) {
                delta[i][j] = (int) Math.random() * 999;
            }
        }

        switch(Integer.parseInt(args[0])) {
            case 0: {
                long[] immutableRes = testImmutable(delta);
                System.out.printf("testImmutable:\t%dns\t%d kbytes\n", immutableRes[0], immutableRes[1] / 1024);
            }
                break;
            case 1: {
                long[] mutableRes = testMutable(delta);
                System.out.printf("testMutable:\t%dns\t%d kbytes\n", mutableRes[0], mutableRes[1] / 1024);
            }
                break;
            default:
                return;
        }
    }
}</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/29">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/29</link>
        <pubDate>Sat, 15 Nov 2014 01:16:55 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-29</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@zyle1992 Zymus]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/zyle1992">@zyle1992</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:27, topic:547713”]It’s not the fact it’s a class, it’s the fact it’s immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote">
<blockquote>
<p>It’s not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you’re adding overhead for no good reason.[/quote]</p>
<p>This is how it’s been in every corporate environment I’ve worked in. The benefit of having an class rather than a set of primitives out-weigh the negligible performance cost. Here is an excerpt of an article written by IBM about the performance of immutable objects:</p>
<blockquote>No installment of Java theory and practice would be complete without some sort of plug for immutability. Making objects immutable eliminates entire classes of programming errors. One of the most common reasons given for not making a class immutable is the belief that doing so would compromise performance. While this is true sometimes, it is often not -- and sometimes the use of immutable objects has significant, and perhaps surprising, performance advantages.
<p>Many objects function as containers for references to other objects. When the referenced object needs to change, we have two choices: update the reference (as we would in a mutable container class) or re-create the container to hold a new reference (as we would in an immutable container class). Listing 5 shows two ways to implement a simple holder class. Assuming the containing object is small, which is often the case (such as a Map.Entry element in a Map or a linked list element), allocating a new immutable object has some hidden performance advantages that come from the way generational garbage collectors work, having to do with the relative age of objects.<br>
Listing 5. Mutable and immutable object holders</p>
<pre><code class="lang-auto">public class MutableHolder {
  private Object value;
  public Object getValue() { return value; }
  public void setValue(Object o) { value = o; }
}</code></pre>
<p><code>
public class ImmutableHolder {
  private final Object value;
  public ImmutableHolder(Object o) { value = o; }
  public Object getValue() { return value; }
}</code></p>
<p>In most cases, when a holder object is updated to reference a different object, the new referent is a young object. If we update a MutableHolder by calling setValue(), we have created a situation where an older object references a younger one. On the other hand, by creating a new ImmutableHolder object instead, a younger object is referencing an older one. The latter situation, where most objects point to older objects, is much more gentle on a generational garbage collector. If a MutableHolder that lives in the old generation is mutated, all the objects on the card that contain the MutableHolder must be scanned for old-to-young references at the next minor collection. The use of mutable references for long-lived container objects increases the work done to track old-to-young references at collection time. (See last month’s article and this month’s Resources, which explain the card-marking algorithm used to implement the write barrier in the generational collector used by current Sun JVMs).</p>
</blockquote>
<p>Found <a href="http://www.ibm.com/developerworks/java/library/j-jtp01274/index.html" data-bbcode="true">here</a>. And the article was accurate as of Jan 27 2004.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/28">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/28</link>
        <pubDate>Fri, 14 Nov 2014 22:41:36 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-28</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>It’s not the fact it’s a class, it’s the fact it’s immutable and operations cannot be performed on the encapsulated data without instantiating another object. there is a performance cost, a huge one in fact if you consider a scenario like a runescape game server. there will be a metric fudgeton of objects allocated on the heap just for positioning of players that need to wait to be freed when gc decides to get to them (not to mention that malloc is a more expensive operation than just simple arithmetic). go ahead, try it yourself: have an immutable location class and mutable one and do random operations to many at once while looking at the JVM memory usage and compare the two scenarios. I also wager that the mutable location object operations will execute faster.</p>
<aside class="quote" data-post="26" data-topic="547713">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/ashi/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> Ashi:</div>
<blockquote>
<p>It’s not so much a terrible idea.</p>
</blockquote>
</aside>
<p>Yes it is, you’re adding overhead for no good reason.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/27">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/27</link>
        <pubDate>Fri, 14 Nov 2014 22:30:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-27</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
      <item>
        <title>Which way is more OOP-like</title>
        <dc:creator><![CDATA[@Ashi Ashi]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ashi">@Ashi</a> wrote:</p>
          <blockquote>
              <p>It’s not so much a terrible idea.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/26">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713/26</link>
        <pubDate>Fri, 14 Nov 2014 13:03:20 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-547713-26</guid>
        <source url="https://forum.moparisthebest.com/t/which-way-is-more-oop-like/547713.rss">Which way is more OOP-like</source>
      </item>
  </channel>
</rss>
