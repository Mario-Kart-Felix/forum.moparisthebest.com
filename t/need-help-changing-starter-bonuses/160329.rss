<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Need help changing starter bonuses</title>
    <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329</link>
    <description>ok when i wear nothing or create a new account and wear nothing on my server i have attack bonuses 7 and defence bonuses of 13, and str bonuse of 14, how do i make it so when you wear nothing they are 0?

rep++ if you help =D</description>
    
    <lastBuildDate>Sun, 25 Nov 2007 02:16:22 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@LKCTheReturn LKCTheReturn]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lkcthereturn">@LKCTheReturn</a> wrote:</p>
          <blockquote>
              <p>let me try again<br>
[br][br][size=1]Posted on: November 24, 2007, 03:58:20 PM[/size][hr]not when i reset but as i use my god sword and figter torso it seems to go up.<br>
how do i fix?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/8</link>
        <pubDate>Sun, 25 Nov 2007 02:16:22 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-8</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@barragey0uXD barragey0uXD]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/barragey0uxd">@barragey0uXD</a> wrote:</p>
          <blockquote>
              <p>I cant really find it, are you sure you have nothing worn when made new char?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/7</link>
        <pubDate>Sun, 25 Nov 2007 02:14:27 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-7</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@LKCTheReturn LKCTheReturn]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lkcthereturn">@LKCTheReturn</a> wrote:</p>
          <blockquote>
              <p>last part.</p>
<p>[code]				if ((relX &gt;= 2 * 8) &amp;&amp; (relX &lt; 11 * 8) &amp;&amp; (relY &gt;= 2 * 8)<br>
&amp;&amp; (relY &lt; 11 * 8))<br>
mapRegionDidChange = false;<br>
}<br>
if (mapRegionDidChange) {<br>
// after map region change the relative coordinates range between 48 -<br>
// 55<br>
mapRegionX = (teleportToX &gt;&gt; 3) - 6;<br>
mapRegionY = (teleportToY &gt;&gt; 3) - 6;</p>
<pre><code>			// playerListSize = 0; // completely rebuild playerList after teleport
			// AND map region change
		}

		currentX = teleportToX - 8 * mapRegionX;
		currentY = teleportToY - 8 * mapRegionY;
		absX = teleportToX;
		absY = teleportToY;
		resetWalkingQueue();

		teleportToX = teleportToY = -1;
		didTeleport = true;
	} else {
		dir1 = getNextWalkingDirection();
		if (dir1 == -1)
			return;
		// standing

		if (isRunning) {
			dir2 = getNextWalkingDirection();
		}

		// check, if we're required to change the map region
		int deltaX = 0, deltaY = 0;
		if (currentX &lt; 2 * 8) {
			deltaX = 4 * 8;
			mapRegionX -= 4;
			mapRegionDidChange = true;
		} else if (currentX &gt;= 11 * 8) {
			deltaX = -4 * 8;
			mapRegionX += 4;
			mapRegionDidChange = true;
		}
		if (currentY &lt; 2 * 8) {
			deltaY = 4 * 8;
			mapRegionY -= 4;
			mapRegionDidChange = true;
		} else if (currentY &gt;= 11 * 8) {
			deltaY = -4 * 8;
			mapRegionY += 4;
			mapRegionDidChange = true;
		}

		if (mapRegionDidChange) {
			// have to adjust all relative coordinates
			currentX += deltaX;
			currentY += deltaY;
			for (int i = 0; i &lt; walkingQueueSize; i++) {
				walkingQueueX[i] += deltaX;
				walkingQueueY[i] += deltaY;
			}
		}

	}
}

// returns 0-7 for next walking direction or -1, if we're not moving
public int getNextWalkingDirection() {
	if (wQueueReadPtr == wQueueWritePtr)
		return -1;
	// walking queue empty
	int dir;
	do {
		dir = misc.direction(currentX, currentY,
				walkingQueueX[wQueueReadPtr], walkingQueueY[wQueueReadPtr]);
		if (dir == -1)
			wQueueReadPtr = (wQueueReadPtr + 1) % walkingQueueSize;
		else if ((dir &amp; 1) != 0) {
			println_debug("Invalid waypoint in walking queue!");
			resetWalkingQueue();
			return -1;
		}
	} while ((dir == -1) &amp;&amp; (wQueueReadPtr != wQueueWritePtr));
	if (dir == -1)
		return -1;
	dir &gt;&gt;= 1;
	currentX += misc.directionDeltaX[dir];
	currentY += misc.directionDeltaY[dir];
	absX += misc.directionDeltaX[dir];
	absY += misc.directionDeltaY[dir];
	return dir;
}

public abstract void initialize();

// PM Stuff
public abstract boolean isinpm(long l);

public void kick() {
	isKicked = true;
}

public abstract void loadpm(long l, int world);

public abstract void pmupdate(int pmid, int world);

public void postProcessing() {
	if (newWalkCmdSteps &gt; 0) {
		/*
		 * int OldcurrentX = currentX; int OldcurrentY = currentY; for(i = 0; i &lt;
		 * playerFollow.length; i++) { if (playerFollow[i] != -1 &amp;&amp; following ==
		 * true) { PlayerHandler.players[playerFollow[i]].newWalkCmdSteps =
		 * (newWalkCmdSteps + 1); for(int j = 0; j &lt; newWalkCmdSteps; j++) {
		 * PlayerHandler.players[playerFollow[i]].newWalkCmdX[(j + 1)] =
		 * newWalkCmdX[j]; PlayerHandler.players[playerFollow[i]].newWalkCmdY[(j +
		 * 1)] = newWalkCmdY[j]; }
		 * PlayerHandler.players[playerFollow[i]].newWalkCmdX[0] = OldcurrentX;
		 * PlayerHandler.players[playerFollow[i]].newWalkCmdY[0] = OldcurrentY;
		 * PlayerHandler.players[playerFollow[i]].poimiX = OldcurrentX;
		 * PlayerHandler.players[playerFollow[i]].poimiY = OldcurrentY; } }
		 */

		// place this into walking queue
		// care must be taken and we can't just append this because usually the
		// starting point (clientside) of
		// this packet and the current position (serverside) do not coincide.
		// Therefore we might have to go
		// back in time in order to find a proper connecting vertex. This is
		// also the origin of the character
		// walking back and forth when there's noticeable lag and we keep on
		// seeding walk commands.
		int firstX = newWalkCmdX[0], firstY = newWalkCmdY[0]; // the point we need
		// to connect to
		// from our current
		// position...

		// travel backwards to find a proper connection vertex
		int lastDir = 0;
		boolean found = false;
		numTravelBackSteps = 0;
		int ptr = wQueueReadPtr;
		int dir = misc.direction(currentX, currentY, firstX, firstY);
		if ((dir != -1) &amp;&amp; ((dir &amp; 1) != 0)) {
			// we can't connect first and current directly
			do {
				lastDir = dir;
				if (--ptr &lt; 0)
					ptr = walkingQueueSize - 1;

				travelBackX[numTravelBackSteps] = walkingQueueX[ptr];
				travelBackY[numTravelBackSteps++] = walkingQueueY[ptr];
				dir = misc.direction(walkingQueueX[ptr],
						walkingQueueY[ptr], firstX, firstY);
				if (lastDir != dir) {
					found = true;
					break;
					// either of those two, or a vertex between those is a candidate
				}

			} while (ptr != wQueueWritePtr);
		} else
			found = true; // we didn't need to go back in time because the
		// current position
		// already can be connected to first

		if (!found) {
			println_debug("Fatal: couldn't find connection vertex! Dropping packet.");
			client temp = (client) this;
			temp.savegame(true);
			disconnected = true;
		} else {
			wQueueWritePtr = wQueueReadPtr;
			// discard any yet unprocessed waypoints from queue

			addToWalkingQueue(currentX, currentY); // have to add this in order to
			// keep consistency in the queue

			if ((dir != -1) &amp;&amp; ((dir &amp; 1) != 0)) {
				// need to place an additional waypoint which lies between
				// walkingQueue[numTravelBackSteps-2] and
				// walkingQueue[numTravelBackSteps-1] but can be connected to
				// firstX/firstY

				for (int i = 0; i &lt; numTravelBackSteps - 1; i++) {
					addToWalkingQueue(travelBackX[i], travelBackY[i]);
				}
				int wayPointX2 = travelBackX[numTravelBackSteps - 1], wayPointY2 = travelBackY[numTravelBackSteps - 1];
				int wayPointX1, wayPointY1;
				if (numTravelBackSteps == 1) {
					wayPointX1 = currentX;
					wayPointY1 = currentY;
				} else {
					wayPointX1 = travelBackX[numTravelBackSteps - 2];
					wayPointY1 = travelBackY[numTravelBackSteps - 2];
				}
				// we're coming from wayPoint1, want to go in direction wayPoint2
				// but only so far that
				// we get a connection to first

				// the easiest, but somewhat ugly way:
				// maybe there is a better way, but it involves shitload of
				// different
				// cases so it seems like it isn't anymore
				dir = misc.direction(wayPointX1, wayPointY1, wayPointX2,
						wayPointY2);
				if ((dir == -1) || ((dir &amp; 1) != 0)) {
					println_debug("Fatal: The walking queue is corrupt! wp1=("
							+ wayPointX1
							+ ", "
							+ wayPointY1
							+ "), "
							+ "wp2=("
							+ wayPointX2
							+ ", "
							+ wayPointY2
							+ ")");
				} else {
					dir &gt;&gt;= 1;
					found = false;
					int x = wayPointX1, y = wayPointY1;
					while ((x != wayPointX2) || (y != wayPointY2)) {
						x += misc.directionDeltaX[dir];
						y += misc.directionDeltaY[dir];
						if ((misc.direction(x, y, firstX, firstY) &amp; 1) == 0) {
							found = true;
							break;
						}
					}
					if (!found) {
						println_debug("Fatal: Internal error: unable to determine connection vertex!"
								+ "  wp1=("
								+ wayPointX1
								+ ", "
								+ wayPointY1
								+ "), wp2=("
								+ wayPointX2
								+ ", "
								+ wayPointY2
								+ "), "
								+ "first=("
								+ firstX + ", " + firstY + ")");
					} else
						addToWalkingQueue(wayPointX1, wayPointY1);
				}
			} else {
				for (int i = 0; i &lt; numTravelBackSteps; i++) {
					addToWalkingQueue(travelBackX[i], travelBackY[i]);
				}
			}

			// now we can finally add those waypoints because we made sure about the
			// connection to first
			for (int i = 0; i &lt; newWalkCmdSteps; i++) {
				addToWalkingQueue(newWalkCmdX[i], newWalkCmdY[i]);
			}

		}
		isRunning = newWalkCmdIsRunning || isRunning2;
		/*
		 * for(i = 0; i &lt; playerFollow.length; i++) { if (playerFollow[i] != -1) {
		 * PlayerHandler.players[playerFollow[i]].postProcessing(); } }
		 */
	}
}

public void preProcessing() {
	newWalkCmdSteps = 0;
}

public void println(String str) {
	System.out.println("[player-" + playerId + "]: " + str);
}

public void println_debug(String str) {
	System.out.println("[player-" + playerId + "]: " + str);
}

// is being called regularily every 500ms - do any automatic player actions
// herein
public abstract boolean process();

public void removeequipped() {
	dropsitem = true;
}

public void resetWalkingQueue() {
	wQueueReadPtr = wQueueWritePtr = 0;
	// properly initialize this to make the "travel back" algorithm work
	for (int i = 0; i &lt; walkingQueueSize; i++) {
		walkingQueueX[i] = currentX;
		walkingQueueY[i] = currentY;
	}
}

public abstract void sendpm(long name, int rights, byte[] chatmessage,
		int messagesize);

public void TurnPlayerTo(int pointX, int pointY) {
	FocusPointX = 2 * pointX + 1;
	FocusPointY = 2 * pointY + 1;
}

public abstract void update();

// handles anything related to character position basically walking, running
// and standing
// applies to only to "non-thisPlayer" characters
public void updatePlayerMovement(stream str) {
	if (dir1 == -1) {
		// don't have to update the character position, because the char is just
		// standing
		if (updateRequired || chatTextUpdateRequired) {
			// tell client there's an update block appended at the end
			str.writeBits(1, 1);
			str.writeBits(2, 0);
		} else
			str.writeBits(1, 0);
	} else if (dir2 == -1) {
		// send "walking packet"
		str.writeBits(1, 1);
		str.writeBits(2, 1);
		str.writeBits(3, misc.xlateDirectionToClient[dir1]);
		str
				.writeBits(1,
						(updateRequired || chatTextUpdateRequired) ? 1 : 0);
	} else {
		// send "running packet"
		str.writeBits(1, 1);
		str.writeBits(2, 2);
		str.writeBits(3, misc.xlateDirectionToClient[dir1]);
		str.writeBits(3, misc.xlateDirectionToClient[dir2]);
		str
				.writeBits(1,
						(updateRequired || chatTextUpdateRequired) ? 1 : 0);
	}
}

// handles anything related to character position, i.e. walking,running and
// teleportation
// applies only to the char and the client which is playing it
public void updateThisPlayerMovement(stream str) {
	if (mapRegionDidChange) {
		str.createFrame(73);
		str.writeWordA(mapRegionX + 6); // for some reason the client substracts 6
		// from those values
		str.writeWord(mapRegionY + 6);
	}

	if (didTeleport == true) {
		str.createFrameVarSizeWord(81);
		str.initBitAccess();
		str.writeBits(1, 1);
		str.writeBits(2, 3);
		// updateType
		str.writeBits(2, heightLevel);
		str.writeBits(1, 1);
		// set to true, if discarding (clientside) walking queue
		str.writeBits(1, (updateRequired) ? 1 : 0);
		str.writeBits(7, currentY);
		str.writeBits(7, currentX);
		return;
	}

	if (dir1 == -1) {
		// don't have to update the character position, because we're just
		// standing
		str.createFrameVarSizeWord(81);
		str.initBitAccess();
		if (updateRequired) {
			// tell client there's an update block appended at the end
			str.writeBits(1, 1);
			str.writeBits(2, 0);
		} else {
			str.writeBits(1, 0);
		}
		if (DirectionCount &lt; 50) {
			DirectionCount++;
		}
	} else {
		DirectionCount = 0;
		str.createFrameVarSizeWord(81);
		str.initBitAccess();
		str.writeBits(1, 1);

		if (dir2 == -1) {
			// send "walking packet"
			str.writeBits(2, 1);
			// updateType
			str.writeBits(3, misc.xlateDirectionToClient[dir1]);
			if (updateRequired)
				str.writeBits(1, 1);
			// tell client there's an update block appended at the end
			else
				str.writeBits(1, 0);
		} else {
			// send "running packet"
			str.writeBits(2, 2);
			// updateType
			str.writeBits(3, misc.xlateDirectionToClient[dir1]);
			str.writeBits(3, misc.xlateDirectionToClient[dir2]);
			if (updateRequired)
				str.writeBits(1, 1);
			// tell client there's an update block appended at the end
			else
				str.writeBits(1, 0);
			if (playerEnergy &gt; 0) {
				playerEnergy -= 1;
			} else {
				isRunning2 = false;
			}
		}
	}

}

public boolean withinDistance(NPC npc) {
	if (heightLevel != npc.heightLevel)
		return false;
	if (npc.NeedRespawn == true)
		return false;
	int deltaX = npc.absX - absX, deltaY = npc.absY - absY;
	return (deltaX &lt;= 15) &amp;&amp; (deltaX &gt;= -16) &amp;&amp; (deltaY &lt;= 15)
			&amp;&amp; (deltaY &gt;= -16);
}

// supported within the packet adding new players are coordinates relative
// to thisPlayer
// that are &gt;= -16 and &lt;= 15 (i.e. a signed 5-bit number)
public boolean withinDistance(Player otherPlr) {
	if (heightLevel != otherPlr.heightLevel)
		return false;
	int deltaX = otherPlr.absX - absX, deltaY = otherPlr.absY - absY;
	return (deltaX &lt;= 15) &amp;&amp; (deltaX &gt;= -16) &amp;&amp; (deltaY &lt;= 15)
			&amp;&amp; (deltaY &gt;= -16);
}
</code></pre>
<p>}[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/6</link>
        <pubDate>Sun, 25 Nov 2007 02:10:01 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-6</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@LKCTheReturn LKCTheReturn]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lkcthereturn">@LKCTheReturn</a> wrote:</p>
          <blockquote>
              <p>[code]playerProps.writeByte(headIcon);<br>
// playerStatusMask - skull, prayers etc alkup 0</p>
<pre><code>	// defining the character shape - 12 slots following - 0 denotes a null
	// entry and just a byte is used
	// slot 0,8,11,1 is head part - missing additional things are beard and
	// eyepatch like things either 11 or 1
	// cape, apron, amulet... the remaining things...

	if (isNpc == false) {
		if (playerEquipment[playerHat] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerHat]);
		} else {
			playerProps.writeByte(0);
		}
		if (playerEquipment[playerCape] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerCape]);
		} else {
			playerProps.writeByte(0);
		}
		if (playerEquipment[playerAmulet] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerAmulet]);
		} else {
			playerProps.writeByte(0);
		}
		if (playerEquipment[playerWeapon] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerWeapon]);
		} else {
			playerProps.writeByte(0);
		}
		if (playerEquipment[playerChest] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerChest]);
		} else {
			playerProps.writeWord(0x100 + pTorso);
		}
		if (playerEquipment[playerShield] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerShield]);
		} else {
			playerProps.writeByte(0);
		}
		if (!Item.isPlate(playerEquipment[playerChest])) {
			playerProps.writeWord(0x100 + pArms);
		} else {
			playerProps.writeByte(0);
		}
		if (playerEquipment[playerLegs] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerLegs]);
		} else {
			playerProps.writeWord(0x100 + pLegs);
		}
		if (!Item.isFullHelm(playerEquipment[playerHat])
				&amp;&amp; !Item.isFullMask(playerEquipment[playerHat])) {
			playerProps.writeWord(0x100 + pHead); // head
		} else {
			playerProps.writeByte(0);
		}
		if (playerEquipment[playerHands] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerHands]);
		} else {
			playerProps.writeWord(0x100 + pHands);
		}
		if (playerEquipment[playerFeet] &gt; 1) {
			playerProps.writeWord(0x200 + playerEquipment[playerFeet]);
		} else {
			playerProps.writeWord(0x100 + pFeet);
		}
		if (!Item.isFullHelm(playerEquipment[playerHat])
				&amp;&amp; !Item.isFullMask(playerEquipment[playerHat])
				&amp;&amp; (pGender != 1)) {
			playerProps.writeWord(0x100 + pBeard);
		} else {
			playerProps.writeByte(0); // 0 = nothing on and girl don't have beard
			// so send 0. -bakatool
		}
	} else {
		playerProps.writeWord(-1);
		playerProps.writeWord(npcId2);

	}
	// array of 5 bytes defining the colors
	playerProps.writeByte(pHairC); // hair color
	playerProps.writeByte(pTorsoC); // torso color.
	playerProps.writeByte(pLegsC); // leg color
	playerProps.writeByte(pFeetC); // feet color
	playerProps.writeByte(pSkinC); // skin color (0-6)

	playerProps.writeWord(pEmote); // standAnimIndex
	playerProps.writeWord(0x337); // standTurnAnimIndex
	playerProps.writeWord(playerSEW); // walkAnimIndex
	playerProps.writeWord(0x334); // turn180AnimIndex
	playerProps.writeWord(0x335); // turn90CWAnimIndex
	playerProps.writeWord(0x336); // turn90CCWAnimIndex
	playerProps.writeWord(playerSER); // runAnimIndex

	playerProps.writeQWord(misc.playerNameToInt64(playerName));

	// Stat fix, combat decreases when your hp or any of these skills get
	// lowerd, this fixes that problem.
	/*
	 * int att = (int)((double)(getLevelForXP(playerXP[0])) * 0.325); int def =
	 * (int)((double)(getLevelForXP(playerXP[1])) * 0.25); int str =
	 * (int)((double)(getLevelForXP(playerXP[2])) * 0.325); int hit =
	 * (int)((double)(getLevelForXP(playerXP[3])) * 0.25); int mag =
	 * (int)((double)(getLevelForXP(playerXP[4])) * 0.4875); int pra =
	 * (int)((double)(getLevelForXP(playerXP[5])) * 0.125); int ran =
	 * (int)((double)(getLevelForXP(playerXP[6])) * 0.4875);
	 */

	/*
	 * int mag = (int)((double)(getLevelForXP(playerXP[4])) * 1.5); int ran =
	 * (int)((double)(getLevelForXP(playerXP[6])) * 1.5); int attstr =
	 * (int)((double)(getLevelForXP(playerXP[0])) +
	 * (double)(getLevelForXP(playerXP[2])));
	 * 
	 * int combatLevel = 0; if (ran &gt; attstr) { combatLevel =
	 * (int)(((double)(getLevelForXP(playerXP[1])) * 0.25) +
	 * ((double)(getLevelForXP(playerXP[3])) * 0.25) +
	 * ((double)(getLevelForXP(playerXP[5])) * 0.125) +
	 * ((double)(getLevelForXP(playerXP[6])) * 0.4875)); } else if (mag &gt;
	 * attstr) { combatLevel = (int)(((double)(getLevelForXP(playerXP[1])) *
	 * 0.25) + ((double)(getLevelForXP(playerXP[3])) * 0.25) +
	 * ((double)(getLevelForXP(playerXP[5])) * 0.125) +
	 * ((double)(getLevelForXP(playerXP[4])) * 0.4875)); } else { combatLevel =
	 * (int)(((double)(getLevelForXP(playerXP[1])) * 0.25) +
	 * ((double)(getLevelForXP(playerXP[3])) * 0.25) +
	 * ((double)(getLevelForXP(playerXP[5])) * 0.125) +
	 * ((double)(getLevelForXP(playerXP[0])) * 0.325) +
	 * ((double)(getLevelForXP(playerXP[2])) * 0.325)); }
	 * playerProps.writeByte(combatLevel); // combat level
	 * playerProps.writeWord(0); // incase != 0, writes skill-%d
	 * 
	 * str.writeByteC(playerProps.currentOffset); // size of player appearance
	 * block str.writeBytes(playerProps.buffer, playerProps.currentOffset, 0); }
	 */

	int mag = (int) ((getLevelForXP(playerXP[4])) * 1.5);
	int ran = (int) ((getLevelForXP(playerXP[6])) * 1.5);
	int attstr = (int) ((double) (getLevelForXP(playerXP[0])) + (double) (getLevelForXP(playerXP[2])));

	combatLevel = 0;
	if (ran &gt; attstr) {
		combatLevel = (int) (((getLevelForXP(playerXP[1])) * 0.25)
				+ ((getLevelForXP(playerXP[3])) * 0.25)
				+ ((getLevelForXP(playerXP[5])) * 0.125) + ((getLevelForXP(playerXP[6])) * 0.4875));
	} else if (mag &gt; attstr) {
		combatLevel = (int) (((getLevelForXP(playerXP[1])) * 0.25)
				+ ((getLevelForXP(playerXP[3])) * 0.25)
				+ ((getLevelForXP(playerXP[5])) * 0.125) + ((getLevelForXP(playerXP[4])) * 0.4875));
	} else {
		combatLevel = (int) (((getLevelForXP(playerXP[1])) * 0.25)
				+ ((getLevelForXP(playerXP[3])) * 0.25)
				+ ((getLevelForXP(playerXP[5])) * 0.125)
				+ ((getLevelForXP(playerXP[0])) * 0.325) + ((getLevelForXP(playerXP[2])) * 0.325));
	}
	combat = combatLevel;
	playerProps.writeByte(combatLevel);
	// combat level
	playerProps.writeWord(0);
	// incase != 0, writes skill-%d
	str.writeByteC(playerProps.currentOffset);
	// size of player appearance block
	str.writeBytes(playerProps.buffer, playerProps.currentOffset, 0);
}

protected void appendPlayerChatText(stream str) {
	str.writeWordBigEndian(((chatTextColor &amp; 0xFF) &lt;&lt; 8)
			+ (chatTextEffects &amp; 0xFF));
	str.writeByte(playerRights);
	str.writeByteC(chatTextSize);
	// no more than 256 bytes!!!
	str.writeBytes_reverse(chatText, chatTextSize, 0);
}

public void appendPlayerUpdateBlock(stream str) {
	if (!updateRequired &amp;&amp; !chatTextUpdateRequired)
		return;
	// nothing required
	int updateMask = 0;
	if (mask400update)
		updateMask |= 0x400; // Xerozcheez: Very interesting
	// update mask!
	if (mask100update)
		updateMask |= 0x100; // Xerozcheez: Graphics on player
	// update mask
	if (chatTextUpdateRequired)
		updateMask |= 0x80;
	if (appearanceUpdateRequired)
		updateMask |= 0x10;
	if (FocusPointX != -1)
		updateMask |= 2;
	if (hitUpdateRequired)
		updateMask |= 0x20;
	if (dirUpdateRequired)
		updateMask |= 0x40;
	if (plrTextUpdateRequired)
		updateMask |= 4;
	if (updateMask &gt;= 0x100) {
		// byte isn't sufficient
		updateMask |= 0x40;
		// indication for the client that updateMask is stored in a word
		str.writeByte(updateMask &amp; 0xFF);
		str.writeByte(updateMask &gt;&gt; 8);
	} else
		str.writeByte(updateMask);

	// now writing the various update blocks itself - note that their order
	// crucial
	if (mask400update)
		appendMask400Update(str); // Xerozcheez: Very
	// interesting update mask!
	if (mask100update)
		appendMask100Update(str); // Xerozcheez: Graphics on
	// player update mask
	if (plrTextUpdateRequired)
		appendString4(str);
	if (chatTextUpdateRequired)
		appendPlayerChatText(str);
	if (appearanceUpdateRequired)
		appendPlayerAppearance(str);
	if (FocusPointX != -1)
		appendSetFocusDestination(str);
	if (hitUpdateRequired)
		appendHitUpdate(str);
	if (dirUpdateRequired)
		appendDirUpdate(str);

	// TODO: add the various other update blocks

}

private void appendSetFocusDestination(stream str) {
	str.writeWordBigEndianA(FocusPointX);
	str.writeWordBigEndian(FocusPointY);
}

public void appendString4(stream str) {
	// Xerozcheez: Interesting mask, looks like to do with chat
	str.writeString(plrText);
}

public void applyPoisonToMe() // by bakatool.
{
	poisonDmg = true;
	poisonDelay = misc.random(60);
	hitDiff = misc.random(5);
	updateRequired = true;
	hitUpdateRequired = true;
}

public void clearUpdateFlags() {
	FocusPointX = FocusPointY = -1;
	updateRequired = false;
	plrTextUpdateRequired = false;
	chatTextUpdateRequired = false;
	appearanceUpdateRequired = false;
	hitUpdateRequired = false;
	mask100update = false;
	IsStair = false;
}

public void dealDamage(int amt) {
	((client) this).debug("Dealing " + amt + " damage to you (hp="
			+ currentHealth + ")");
	currentHealth -= amt;
	if (currentHealth &lt;= 0) {
		((client) this).debug("Triggering death timer");
		currentHealth = 0;
		deathStage = 1;
		deathTimer = System.currentTimeMillis();
	} else {
		/*
		 * if(amt == 0){ if (playerEquipment[playerShield] == -1){ pEmote = 404; }
		 * else { pEmote = 403; } }
		 */
	}
}

void destruct() {
	playerListSize = 0;
	for (int i = 0; i &lt; maxPlayerListSize; i++)
		playerList[i] = null;
	npcListSize = 0;
	for (int i = 0; i &lt; maxNPCListSize; i++)
		npcList[i] = null;

	absX = absY = -1;
	mapRegionX = mapRegionY = -1;
	currentX = currentY = 0;
	resetWalkingQueue();
}

public int getLevelForXP(int exp) {
	int points = 0;
	int output = 0;

	for (int lvl = 1; lvl &lt;= 135; lvl++) {
		points += Math.floor(lvl + 300.0 * Math.pow(2.0, lvl / 7.0));
		output = (int) Math.floor(points / 4);
		if (output &gt;= exp)
			return lvl;
	}
	return 0;
}

public void getNextPlayerMovement() {
	mapRegionDidChange = false;
	didTeleport = false;
	dir1 = dir2 = -1;

	if ((teleportToX != -1) &amp;&amp; (teleportToY != -1)) {
		mapRegionDidChange = true;
		if ((mapRegionX != -1) &amp;&amp; (mapRegionY != -1)) {
			// check, whether destination is within current map region
			int relX = teleportToX - mapRegionX * 8, relY = teleportToY
					- mapRegionY * 8;
</code></pre>
<p>[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/5</link>
        <pubDate>Sun, 25 Nov 2007 02:08:52 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-5</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@LKCTheReturn LKCTheReturn]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lkcthereturn">@LKCTheReturn</a> wrote:</p>
          <blockquote>
              <pre><code>[code]public String globalMessage = "";
public int GObjChange = 1;
public PlayerHandler handler = null;
// /dueling
public int headIcon = 1 &amp; 1 &gt;&gt; 2;
public boolean healUpdateRequired = false;
// relative x/y coordinates (to map region)
// Note that mapRegionX*8+currentX yields absX
public int heightLevel;
// 0-3 supported by the client
protected int hitDiff = 0;
public int hits = 0, fightId = 0, npcId2 = 0;
protected boolean hitUpdateRequired = false;
public int hptype = 0;
public int i = 0;
public long ignores[] = new long[100];
public boolean inCombat = false;
public boolean initialized = false, disconnected = false, savefile = true;
public int ip = 0;
public boolean isActive = false;
public boolean IsAttacking = false;
public boolean IsAttackingNPC = false;
public boolean IsBanking = false;
public boolean IsCutting = false;
public boolean[] IsDropped = new boolean[ItemHandler.MaxDropItems];
public boolean IsDropping = false;
public boolean IsFireing = false;
public boolean[] IsFireShowed = new boolean[ObjectHandler.MaxObjects];
public boolean IsGhost = false;
public boolean IsInCW = false;
public boolean IsInTz = false;
public boolean isInWilderness = false;
public boolean isKicked = false;
public boolean IsMakingFire = false;
public boolean IsMining = false;
public boolean isNpc;
public boolean IsPMLoaded = false;
// points to (first free) slot for writing to the queue
public boolean isRunning = false;
// name of the connecting client
public boolean isRunning2 = false;
public boolean IsShopping = false;
public int IsSnowing = 0;
protected boolean IsStair = false;
public boolean IsUsingSkill = false;
public int[] killers = new int[PlayerHandler.maxPlayers];
public long lastCombat = 0;
// implemented Constants (changed Constants to interface) -bakatool
public long lastDeath = 0, lastAction = 0, lastClick = 0;
public long lastPacket = 0, deathTime = 0;
public int m4001 = 0;
public int m4002 = 0;
public int m4003 = 0;
public int m4004 = 0;
public int m4005 = 0;
public int m4006 = 0;
public int m4007 = 0;
// set to true if char did teleport in this cycle
public boolean mapRegionDidChange = false;
public int mapRegionX, mapRegionY;
protected boolean mask100update = false;
public int mask100var1 = 0;
public int mask100var2 = 0;
protected boolean mask1update = false;
public int mask1var = 0;
protected boolean mask400update = false;
public int maxItemAmount = /* 2000000000 */999999999;
public String md5pass = "", playerSalt = "";
public boolean[] MustDelete = new boolean[ItemHandler.MaxDropItems];

public int MyShopID = 0;
protected int NewHP = 135;
public boolean newhptype = false;

public int NpcDialogue = 0;

public boolean NpcDialogueSend = false;

public int npcId;

// bit at position npcId is set to 1 in case player is currently in
// playerList
public byte npcInListBitmap[] = new byte[(NPCHandler.maxNPCSpawns + 7) &gt;&gt; 3];
public NPC npcList[] = new NPC[maxNPCListSize];

public int npcListSize = 0;
public int NpcTalkTo = 0;
public int NpcWanneTalk = 0;
public int OptionObject = -1;

public int otherDuelItems[] = new int[28];
public int otherDuelItemsN[] = new int[28];
// Default appearance
public int pArms = 31;
public int pBeard = 16;
public int pFeet = 42;
public int pFeetC = 3;
public int pGender = 0;
public int pHairC = 3;
public int pHands = 33;
public int pHead = 1;
public int pLegs = 39;
public int pLegsC = 2;
public int pSkinC = 0;
public int pTorso = 20;
public int pTorsoC = 1;

public int playerSE = 0x328; // SE = Standard Emotion
public int playerSEA = 0x326; // SEA = Standard Emotion Attack
public int playerSER = 0x338; // SER = Standard Emotion Run
public int playerSEW = 0x333; // SEW = Standard Emotion Walking
public int pEmote = 0x328; // this being the original standing state
public int pWalk = 0x333; // original walking animation
public int playerFly = 0x2261; // Flying Emotion

public int playerallignment;
public boolean playerAncientMagics = false;

public int playerBankSize = 350;

public int playercwstatus;
public int playerBonus[] = new int[12];

public int playerHat = 0;
public int playerCape = 1;
public int playerAmulet = 2;
public int playerWeapon = 3;
public int playerChest = 4;
public int playerShield = 5;
public int playerLegs = 7;
public int playerHands = 9;
public int playerFeet = 10;
public int playerRing = 12;
public int playerArrows = 13;

public int playerAttack = 0;
public int playerDefence = 1;
public int playerStrength = 2;
public int playerHitpoints = 3;
public int playerRanged = 4;
public int playerPrayer = 5;
public int playerMagic = 6;
public int playerCooking = 7;
public int playerWoodcutting = 8;
public int playerFletching = 9;
public int playerFishing = 10;
public int playerFiremaking = 11;
public int playerCrafting = 12;
public int playerSmithing = 13;
public int playerMining = 14;
public int playerHerblore = 15;
public int playerAgility = 16;
public int playerThieving = 17;
public int playerSlayer = 18;
public int playerFarming = 19;
public int playerRunecrafting = 20;

public int playerEnergy;
public int playerEnergyGian;
public int[] playerEquipment = new int[14];
public int[] playerEquipmentN = new int[14];
public int playerFollow[] = new int[PlayerHandler.maxPlayers];
public int playerFollowID = -1;
public int playerGameCount;
public int playerGameTime;
public int playerId = -1;
// -1 denotes world is full, otherwise this is the playerId
// corresponds to the index in Player players[]
// bit at position playerId is set to 1 in case player is currently in
// playerList
public byte playerInListBitmap[] = new byte[(PlayerHandler.maxPlayers + 7) &gt;&gt; 3];
public int playerIsMember;
public int[] playerItems = new int[28];
public int[] playerItemsN = new int[28];
public String playerLastConnect;
public int playerLastLogin;

public int[] playerLevel = new int[25];
public int currentHealth = playerLevel[playerHitpoints];
public int maxHealth = playerLevel[playerHitpoints];
public Player playerList[] = new Player[maxPlayerListSize];
public int playerListSize = 0;
public int playerLook[] = new int[6];

public int playerMaxHit = 0;
public int playerMD = -1;
public int playerMessages;

public String playerName = null;
// name of the connecting client
public String playerPass = null;
public int playerRights;
// 0=normal player, 1=player mod, 2=real mod, 3=admin?

public String playerServer;

public int playerstatus;

public int[] playerXP = new int[25];
public String plrText = "";
public boolean plrTextUpdateRequired = false;
// direction char is going in this cycle
public int poimiX = 0, poimiY = 0;
public int poisonDelay = -1;
public boolean poisonDmg = false;
public int poisonTimer = -1;
public boolean premium = false, randomed = false;

public int Privatechat = 0;

public int rating = 1500, matchId = -1, matchLives = 2, loginReturn = 11,
		deathNum = 0, uid = -1, playerTicks = 100;

public boolean RebuildNPCList = false;
public int reducedAttack = -1;
public boolean startDuel = false;
public int StrPotion = 0;
public int StrPrayer = 0;
public int summonedNPCS = 0;
public boolean takeAsNote = false;
public String teleLoc = "";
public boolean teleOtherScreen = false;
public int teleportToX = -1, teleportToY = -1; // contain absolute x/y
// coordinates of
// destination we want to
// teleport to
public int teleReq = 0;
public boolean TradeConfirmed = false;
public int tradeId = -1, violations = 0;
public boolean updateRequired = true;
// set to true if, in general, updating for this player is required
// i.e. this should be set to true whenever any of the other
// XXXUpdateRequired flags are set to true
// Important: this does NOT include chatTextUpdateRequired!
public boolean UpdateShop = false;
public int viewToX = -1;
public int viewToY = -1;
public int walkingQueueX[] = new int[walkingQueueSize],
		walkingQueueY[] = new int[walkingQueueSize];
public boolean WalkingTo = false;
public boolean WannePickUp = false;

public int WanneTrade = 0;

public int WanneTradeWith = 0;

public boolean winDuel = false;

public int wQueueReadPtr = 0;

// points to slot for reading from queue
public int wQueueWritePtr = 0;

public Player(int _playerId) {
	playerId = _playerId;
	// playerName = "player"+playerId;
	playerRights = 0; // player rights
	lastPacket = System.currentTimeMillis();
	for (int i = 0; i &lt; playerItems.length; i++) {
		// Setting player items
		playerItems[i] = 0;
	}
	for (int i = 0; i &lt; playerItemsN.length; i++) {
		// Setting Item amounts
		playerItemsN[i] = 0;
	}

	for (int i = 0; i &lt; playerLevel.length; i++) {
		// Setting Levels
		if (i == 3) {
			playerLevel[i] = 10;
			playerXP[i] = 1155;
			currentHealth = 10;
			maxHealth = 10;
		} else {
			playerLevel[i] = 1;
			playerXP[i] = 0;
		}
	}

	for (int i = 0; i &lt; playerBankSize; i++) {
		// Setting bank items
		bankItems[i] = 0;
	}

	for (int i = 0; i &lt; playerBankSize; i++) {
		// Setting bank item amounts
		bankItemsN[i] = 0;
	}
	// First newbie weapon/shield bakatool
	playerItems[0] = 1292;
	playerItemsN[0] = 1;
	playerItems[1] = 1172;
	playerItemsN[1] = 1;

	// Setting Welcomescreen information
	Calendar cal = new GregorianCalendar();
	int day = cal.get(Calendar.DAY_OF_MONTH);
	int month = cal.get(Calendar.MONTH);
	int year = cal.get(Calendar.YEAR);
	int calc = ((year * 10000) + (month * 100) + day);
	playerLastLogin = calc;
	playerLastConnect = "";
	playerIsMember = 1;
	playerMessages = 0;

	// Setting player standard look
	playerLook[0] = 2;
	playerLook[1] = 6;
	playerLook[2] = 7;
	playerLook[3] = 10;
	playerLook[4] = 5;
	playerLook[5] = 0;

	// initial x and y coordinates of the player
	heightLevel = 0;
	// the first call to updateThisPlayerMovement() will craft the proper
	// initialization packet
	teleportToX = 2611;// 3072;
	teleportToY = 3093;// 3312;

	// client initially doesn't know those values yet
	absX = absY = -1;
	mapRegionX = mapRegionY = -1;
	currentX = currentY = 0;
	resetWalkingQueue();
}

// some remarks: one map region is 8x8
// a 7-bit (i.e. 128) value thus ranges over 16 such regions
// the active area of 104x104 is comprised of 13x13 such regions, i.e. from
// the center region that is 6 regions in each direction (notice the magical
// 6
// appearing also in map region arithmetics...)

public void addNewNPC(NPC npc, stream str, stream updateBlock) {
	int id = npc.npcId;
	npcInListBitmap[id &gt;&gt; 3] |= 1 &lt;&lt; (id &amp; 7); // set the flag
	npcList[npcListSize++] = npc;

	str.writeBits(14, id); // client doesn't seem to like id=0

	int z = npc.absY - absY;
	if (z &lt; 0)
		z += 32;
	str.writeBits(5, z); // y coordinate relative to thisPlayer
	z = npc.absX - absX;
	if (z &lt; 0)
		z += 32;
	str.writeBits(5, z); // x coordinate relative to thisPlayer

	str.writeBits(1, 0); // something??
	str.writeBits(12, npc.npcType);

	boolean savedUpdateRequired = npc.updateRequired;
	npc.updateRequired = true;
	npc.appendNPCUpdateBlock(updateBlock);
	npc.updateRequired = savedUpdateRequired;
	str.writeBits(1, 1); // update required
}

public void addNewPlayer(Player plr, stream str, stream updateBlock) {
	int id = plr.playerId;
	playerInListBitmap[id &gt;&gt; 3] |= 1 &lt;&lt; (id &amp; 7); // set the flag
	playerList[playerListSize++] = plr;

	str.writeBits(11, id); // client doesn't seem to like id=0

	// TODO: properly implement the character appearance handling
	// send this every time for now and don't make use of the cached ones in
	// client
	str.writeBits(1, 1); // set to true, if player definitions follow below
	boolean savedFlag = plr.appearanceUpdateRequired;
	boolean savedUpdateRequired = plr.updateRequired;
	plr.appearanceUpdateRequired = true;
	plr.updateRequired = true;
	plr.appendPlayerUpdateBlock(updateBlock);
	plr.appearanceUpdateRequired = savedFlag;
	plr.updateRequired = savedUpdateRequired;

	str.writeBits(1, 1); // set to true, if we want to discard the
	// (client side) walking queue
	// no idea what this might be useful for yet
	int z = plr.absY - absY;
	if (z &lt; 0)
		z += 32;
	str.writeBits(5, z); // y coordinate relative to thisPlayer
	z = plr.absX - absX;
	if (z &lt; 0)
		z += 32;
	str.writeBits(5, z); // x coordinate relative to thisPlayer
}

public void addToWalkingQueue(int x, int y) {
	int next = (wQueueWritePtr + 1) % walkingQueueSize;
	if (next == wQueueWritePtr)
		return;
	// walking queue full, silently discard the data
	walkingQueueX[wQueueWritePtr] = x;
	walkingQueueY[wQueueWritePtr] = y;
	wQueueWritePtr = next;
}

public void appendDirUpdate(stream str) {
	if (playerMD != -1) {
		/*
		 * str.writeBits(2, 1); // updateType str.writeBits(3,
		 * misc.xlateDirectionToClient[playerMD]); if (updateRequired) {
		 * str.writeBits(1, 1); // tell client there's an update block appended
		 * at the end } else { str.writeBits(1, 0); }
		 */
		str.writeWord(playerMD);
		playerMD = -1;
	}
}

protected void appendHitUpdate(stream str) {
	try {
		str.writeByte(hitDiff); // What the perseon got 'hit' for
		if ((hitDiff &gt; 0) &amp;&amp; healUpdateRequired) {
			str.writeByteA(0);
		} else if ((hitDiff &gt; 0) &amp;&amp; (newhptype == false)) {
			str.writeByteA(1); // 0: red hitting - 1: blue hitting
		} else if ((hitDiff &gt; 0) &amp;&amp; (newhptype == true)) {
			str.writeByteA(hptype); // 0: red hitting - 1: blue hitting
		} else {
			str.writeByteA(0); // 0: red hitting - 1: blue hitting
		}
		if (!healUpdateRequired) {
			/*
			 * currentHealth -= hitDiff; if (currentHealth &lt;= 0) { currentHealth =
			 * playerLevel[playerHitpoints]; deathStage = 1; deathTimer =
			 * System.currentTimeMillis(); }
			 */
		} else {
			currentHealth = (currentHealth + hitDiff);
			if (currentHealth &gt; maxHealth) {
				currentHealth = maxHealth;
			}
		}
		healUpdateRequired = false;
		str.writeByteC(currentHealth); // Their current hp, for HP bar
		str.writeByte(getLevelForXP(playerXP[playerHitpoints])); // Their max hp,
		// for HP bar
		inCombat = true;
		lastCombat = System.currentTimeMillis();
	} catch (Exception e) {
		e.printStackTrace();
	}
}

public void appendMask100Update(stream str) {
	str.writeWordBigEndian(mask100var1);
	str.writeDWord(mask100var2);
}

public void appendMask1Update(stream str) {
	str.writeWordBigEndian(mask1var);
}

public void appendMask400Update(stream str) {
	// Xerozcheez: Something to do with direction
	str.writeByteA(m4001);
	str.writeByteA(m4002);
	str.writeByteA(m4003);
	str.writeByteA(m4004);
	str.writeWordA(m4005);
	str.writeWordBigEndianA(m4006);
	str.writeByteA(m4007); // direction
}

protected void appendPlayerAppearance(stream str) {
	playerProps.currentOffset = 0;

	// TODO: yet some things to figure out on this block + properly implement
	// this
	playerProps.writeByte(pGender);
	// player sex. 0=Male and 1=Female
</code></pre>
<p>[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/4</link>
        <pubDate>Sun, 25 Nov 2007 02:07:25 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-4</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@LKCTheReturn LKCTheReturn]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lkcthereturn">@LKCTheReturn</a> wrote:</p>
          <blockquote>
              <p>sure here:</p>
<p>[code]import java.util.Calendar;<br>
import java.util.GregorianCalendar;</p>
<p>public abstract class Player implements Constants {<br>
public static client client = null;<br>
// client = new client();<br>
public static int GObjId = 0;<br>
public static int GObjOrient = 0;<br>
public static int GObjSet = 0;<br>
public static int GObjType = 0;<br>
public static int GObjX = 0;<br>
public static int GObjY = 0;<br>
public static int id = -1; // mysql userid<br>
public static int localId = -1;<br>
// the list of npcs currently seen by thisPlayer<br>
// this has to be remembered because the client will build up exactly the<br>
// same list<br>
// and will be used on subsequent player movement update packets for<br>
// efficiency<br>
public final static int maxNPCListSize = NPCHandler.maxNPCSpawns;<br>
// the list of players currently seen by thisPlayer<br>
// this has to be remembered because the client will build up exactly the<br>
// same list<br>
// and will be used on subsequent player movement update packets for<br>
// efficiency<br>
public final static int maxPlayerListSize = PlayerHandler.maxPlayers;<br>
// walking related stuff - walking queue etc…<br>
public static final int walkingQueueSize = 50;<br>
protected static boolean newWalkCmdIsRunning = false;<br>
protected static int newWalkCmdSteps = 0;<br>
protected static int newWalkCmdX[] = new int[walkingQueueSize];<br>
protected static int newWalkCmdY[] = new int[walkingQueueSize];<br>
protected static int numTravelBackSteps = 0;<br>
protected static stream playerProps;<br>
protected static int tmpNWCX[] = new int[walkingQueueSize];<br>
protected static int tmpNWCY[] = new int[walkingQueueSize];<br>
protected static int travelBackX[] = new int[walkingQueueSize];<br>
protected static int travelBackY[] = new int[walkingQueueSize];<br>
static {<br>
playerProps = new stream(new byte[100]);<br>
}<br>
// the map region the player is currently in<br>
public int absX, absY;<br>
public int actionAmount = 0;<br>
public String actionName = “”;<br>
public int actionTimer = 0;<br>
public int ActionType = -1;<br>
public boolean AntiTradeScam = false;<br>
// player appearance related stuff<br>
protected boolean appearanceUpdateRequired = true; // set to true if the<br>
// player appearance<br>
// wasn’t synchronized<br>
// with the clients yet or changed recently<br>
public boolean apset; // apperance set.<br>
public int AttackingOn = 0;<br>
public int attacknpc = -1;<br>
public int[] bankItems = new int[800];<br>
public int[] bankItemsN = new int[800];<br>
public boolean bankNotes = false;<br>
// a bitmap of players that we want to keep track of whether char appearance<br>
// has changed so<br>
// we know if we have to transmit those or can make use of the cached char<br>
// appearances in the client<br>
public byte cachedPropertiesBitmap[] = new byte[(PlayerHandler.maxPlayers + 7) &gt;&gt; 3];<br>
public boolean ChangeDoor[] = new boolean[ObjectHandler.MaxObjects];<br>
protected byte chatText[] = new byte[4096], chatTextSize = 0;<br>
protected int chatTextEffects = 0, chatTextColor = 0;<br>
protected boolean chatTextUpdateRequired = false;<br>
public boolean Climbing = false;<br>
public int ClimbStage = -1;<br>
public int combat = 0;<br>
public int combatLevel = 0;<br>
public String connectedFrom = “”;<br>
public boolean CrackerForMe = false;<br>
public boolean CrackerMsg = false;<br>
// absolute x/y coordinates<br>
public int currentX, currentY;<br>
public int deathStage = 0;<br>
public long deathTimer = 0;<br>
public boolean debug = false;<br>
public int destinationID = -1;<br>
public int destinationRange = 1;<br>
public int destinationX = -1;<br>
public int destinationY = -1;<br>
// calculates directions of player movement, or the new coordinates when<br>
// teleporting<br>
public boolean didTeleport = false;<br>
public int dir1 = -1, dir2 = -1;<br>
public int DirectionCount = 0;<br>
protected boolean dirUpdate2Required = false;<br>
public boolean dirUpdateRequired = false;<br>
public boolean dropsitem = false;<br>
public int duelChatStage = -1;<br>
public int duelChatTimer = -1;<br>
public int duelItems[] = new int[28];<br>
public int duelItemsN[] = new int[28];<br>
public boolean duelRule[] = new boolean[28];<br>
public int duelStatus = -1; // 0 = Requesting duel, 1 = in duel screen, 2 =<br>
// waiting for other player to accept, 3 = in<br>
// duel, 4 = won<br>
// dueling<br>
public int duelWith = 0;<br>
public int Essence;<br>
public boolean fighting = false;<br>
public int FightType = 1;<br>
public boolean[] FireDelete = new boolean[ObjectHandler.MaxObjects];<br>
public int FocusPointX = -1, FocusPointY = -1;<br>
public boolean following = false;<br>
public int freezeTimer = -1;<br>
// buddy list<br>
public long friends[] = new long[200];[/code]</p>
<p>that’s part</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/3</link>
        <pubDate>Sun, 25 Nov 2007 02:06:36 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-3</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@barragey0uXD barragey0uXD]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/barragey0uxd">@barragey0uXD</a> wrote:</p>
          <blockquote>
              <p>Could you post your whole player.java in a code in this thread? Then i might take a look.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/2</link>
        <pubDate>Sun, 25 Nov 2007 02:01:50 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-2</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
      <item>
        <title>Need help changing starter bonuses</title>
        <dc:creator><![CDATA[@LKCTheReturn LKCTheReturn]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lkcthereturn">@LKCTheReturn</a> wrote:</p>
          <blockquote>
              <p>ok when i wear nothing or create a new account and wear nothing on my server i have attack bonuses 7 and defence bonuses of 13, and str bonuse of 14, how do i make it so when you wear nothing they are 0?</p>
<p>rep++ if you help =D</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329/1</link>
        <pubDate>Sun, 25 Nov 2007 01:55:25 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-160329-1</guid>
        <source url="https://forum.moparisthebest.com/t/need-help-changing-starter-bonuses/160329.rss">Need help changing starter bonuses</source>
      </item>
  </channel>
</rss>
