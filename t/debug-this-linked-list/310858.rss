<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Debug this Linked List</title>
    <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858</link>
    <description>Here is some C# code I wrote for a Generic Linked List. I ran some Unit Tests just to make sure that everything worked fine in it, but not all of my tests passed, specifically one that tests my Equals Method.

I had a good look at it, and it seems it should work, but it doesn&#39;t, so I&#39;m suspecting I overlooked something simple... (Chances are if my equals method isn&#39;t working, my other methods may night be working exactly as I wanted them either...)

I just wanted to see if someone could give me a quick code review to see what I missed.

[code]#region Using Directives

using System.Collections.Generic;
using System;
using System.Collections;

#endregion

#region Class Definition : LinkedList&lt;T&gt;
[Serializable]
public class LinkedList&lt;T&gt; : ICollection &lt;T&gt;
{

    #region Constructor

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref=&quot;LinkedList&amp;lt;T&amp;gt;&quot;/&gt; class.
    /// &lt;/summary&gt;
    public
    LinkedList ()
    {
        this.m_front = null;
        this.m_count = 0;
    }

    #endregion

    #region Overloaded Operators

    /// &lt;summary&gt;
    /// Returns the &lt;see cref=&quot;T&quot;/&gt; at the entered index.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public T
    this [int index]
    {
        get
        {
            lock (this.m_padlock)
            {
                if (index &lt; 0 || index &gt;= this.m_count)
                    throw new IndexOutOfRangeException  ();

                Node&lt;T&gt;  node = this.m_front;
                int      cnt = 0;

                /*
                 * In a doubly linked list, I could
                 * double the speed of this method
                 * by simply dividing the count,
                 * comare it to the index, then decide
                 * which end to start the search.
                 * 
                 * But, I&#39;m not in a doubly linked list,
                 * so, I&#39;m stuck with any index operation
                 * costing O(N)     =/
                 * 
                 * And... in all honesty, I hate this
                 * implementation of the index operator.
                 * 
                 * Looping through using the index
                 * operator of this object would run
                 * ... ugh... but take an exponential
                 * amount of time.
                 *
                 */
                while (cnt++ != index)
                {
                    node = node.Next;
                }

                return  node.Value;
            }
        }
        set
        {
            lock (this.m_padlock)
            {
                if (index &lt; 0 || index &gt;= this.m_count)
                    throw new IndexOutOfRangeException  ();

                Node&lt;T&gt;  node = this.m_front;
                int      cnt = 0;


                //See remarks on &#39;get&#39;

                while (cnt++ != index)
                {
                    node = node.Next;
                }

                node.Value = value;
            }
        }
    }

    #endregion

    #region ICollection Methods/Properties

    /// &lt;summary&gt;
    /// Adds the specified value to the collection.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;value&quot;&gt;The value to add to the collection.&lt;/param&gt;
    public void
    Add (T value)
    {
        lock (this.m_padlock)
        {
            if (this.m_front == null)
            {
                this.m_front = new Node&lt;T&gt; (value);
                this.m_count++;
            }
            else if (this.m_last == null)
            {
                this.m_last = new Node&lt;T&gt; (value);
                this.m_front.Next = m_last;
                this.m_count++;
            }
            else
            {
                Node&lt;T&gt;  tempNode = new Node&lt;T&gt; (value);
                this.m_last.Next = tempNode;
                this.m_last = tempNode;
                this.m_count++;
            }
        }
    }

    /// &lt;summary&gt;
    /// Gets a value indicating whether the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only.
    /// &lt;/summary&gt;
    /// &lt;value&gt;&lt;/value&gt;
    /// &lt;returns&gt;true if the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only; otherwise, false.
    /// &lt;/returns&gt;
    public bool
    IsReadOnly
    {
        get
        {
            return READONLY;
        }
    }

    /// &lt;summary&gt;
    /// Gets the number of elements contained in the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;value&gt;&lt;/value&gt;
    /// &lt;returns&gt;
    /// The number of elements contained in the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.
    /// &lt;/returns&gt;
    public int
    Count
    {
        get
        {
            return m_count;
        }
    }

    /// &lt;summary&gt;
    /// Removes all items from the &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt;.
    /// &lt;/summary&gt;
    /// &lt;exception cref=&quot;T:System.NotSupportedException&quot;&gt;
    /// The &lt;see cref=&quot;T:System.Collections.Generic.ICollection`1&quot;/&gt; is read-only.
    /// &lt;/exception&gt;
    public void
    Clear ()
    {
        lock (this.m_padlock)
        {
            this.m_last = null;
            this.m_front = null;
            this.m_count = 0;
        }
    }

    /// &lt;summary&gt;
    /// Determines whether this collection contains the specified value.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
    /// &lt;returns&gt;
    /// 	&lt;c&gt;true&lt;/c&gt; if this collection contains the specified value; otherwise, &lt;c&gt;false&lt;/c&gt;.
    /// &lt;/returns&gt;
    public bool
    Contains (T value)
    {
        lock (this.m_padlock)
        {
            if (this.m_count == 0)
                return false;

            Node&lt;T&gt;  node = this.m_front;

            do
            {
                if (node.Value.Equals (value))
                    return true;
            } while ((node = node.Next) != null);
            return false;
        }
    }

    /// &lt;summary&gt;
    /// Removes the specified value from the linked list.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;value&quot;&gt;The value to remove.&lt;/param&gt;
    /// &lt;returns&gt;
    ///     &lt;c&gt;true&lt;/c&gt; if the value was removed; otherwise, &lt;c&gt;false&lt;/c&gt;
    /// &lt;/returns&gt;
    public bool
    Remove (T value)
    {
        lock (this.m_padlock)
        {
            if (this.m_count == 0)
                return false;

            Node&lt;T&gt;  node = this.m_front;

            if (node.Value.Equals (value))
            {
                this.m_front = node.Next;
                this.m_count--;
                return true;
            }

            do
            {
                if (node.Next != null &amp;&amp; node.Next.Value.Equals (value))
                {
                    /*
                     * Removes the node... i think... =/
                     * 
                     * 11:11pm, MAKE A WISH!
                     */
                    node.Next = node.Next.Next;

                    this.m_count--;
                    return true;
                }
            } while ((node = node.Next) != null);

            return false;
        }
    }

    /// &lt;summary&gt;
    /// Copies the elements of this Collection to the given array.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;array&quot;&gt;The zero-based array.&lt;/param&gt;
    /// &lt;param name=&quot;index&quot;&gt;The zero-based index to start writing on the array.&lt;/param&gt;
    public void
    CopyTo (T[] array, int index)
    {
        lock (this.m_padlock)
        {
            if (this.m_count == 0)
                return;

            if (this.m_count &gt; array.Length - index)
                throw new IndexOutOfRangeException ();

            Node&lt;T&gt;  node = this.m_front;

            do
            {
                array[index++] = node.Value;
            } while ((node = node.Next) != null);
        }
    }


    #endregion

    #region IEnumerable&lt;T&gt; Methods

    /// &lt;summary&gt;
    /// Returns an enumerator that iterates through the collection.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// A &lt;see cref=&quot;T:System.Collections.Generic.IEnumerator`1&quot;/&gt; that can be used to iterate through the collection.
    /// &lt;/returns&gt;
    IEnumerator&lt;T&gt;
    IEnumerable&lt;T&gt;.GetEnumerator ()
    {
        // We have this lock because of constructor logic.
        lock (this.m_padlock)
        {
            return new LinkedListEnum&lt;T&gt; (this.m_front);
        }
    }

    #endregion

    #region IEnumerable Methods

    /// &lt;summary&gt;
    /// Returns an enumerator that iterates through a collection.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// An &lt;see cref=&quot;T:System.Collections.IEnumerator&quot;/&gt; object that can be used to iterate through the collection.
    /// &lt;/returns&gt;
    IEnumerator
    IEnumerable.GetEnumerator ()
    {
        // See IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ()
        lock(this.m_padlock)
        {
            return new LinkedListEnum&lt;T&gt; (this.m_front);
        }
    }

    #endregion

    #region Object Methods

    /// &lt;summary&gt;
    /// Returns a hash code for this instance.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
    /// &lt;/returns&gt;
    public override int
    GetHashCode ()
    {
        lock (this.m_padlock)
        {
            return m_front.GetHashCode();
        }
    }

    /// &lt;summary&gt;
    /// Determines whether the specified &lt;see cref=&quot;System.Object&quot;/&gt; is equal to this instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;obj&quot;&gt;The &lt;see cref=&quot;System.Object&quot;/&gt; to compare with this instance.&lt;/param&gt;
    /// &lt;returns&gt;
    /// 	&lt;c&gt;true&lt;/c&gt; if the specified &lt;see cref=&quot;System.Object&quot;/&gt; is equal to this instance; otherwise, &lt;c&gt;false&lt;/c&gt;.
    /// &lt;/returns&gt;
    /// &lt;exception cref=&quot;T:System.NullReferenceException&quot;&gt;
    /// The &lt;paramref name=&quot;obj&quot;/&gt; parameter is null.
    /// &lt;/exception&gt;
    public override bool
    Equals(object obj)
    {
        return this.Equals ((LinkedList&lt;T&gt;) obj);
    }

    #endregion

    #region Private Methods

    /// &lt;summary&gt;
    /// Determines if the two objects are equal.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;obj&quot;&gt;The obj.&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private bool
    Equals (LinkedList&lt;T&gt;  obj)
    {
        
        lock (obj.m_padlock)
        {
            // Possible deadlock here...
            lock (this.m_padlock)
            {
                return m_front == null &amp;&amp; obj.m_front == null ?
                    true : m_front.Equals (obj.m_front);
            }
        }
    }

    #endregion

    #region Private Member Data

    private Node&lt;T&gt;  m_front;
    private Node&lt;T&gt;  m_last;
    private int      m_count;
    private object   m_padlock = new object ();

    #endregion

    #region Constants

    private const bool    READONLY = false;

    #endregion

}
#endregion

#region Class Definition : Node&lt;E&gt;
[Serializable]
internal class Node &lt;E&gt;
{

    #region Constructors

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref=&quot;Node&amp;lt;E&amp;gt;&quot;/&gt; class.
    /// &lt;/summary&gt;
    public
    Node ()
    {
        this.m_value = default(E);
    }

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref=&quot;Node&amp;lt;E&amp;gt;&quot;/&gt; class.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;value&quot;&gt;The value stored in this Node.&lt;/param&gt;
    public
    Node (E  value)
    {
        this.m_value = value;
    }

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref=&quot;Node&amp;lt;E&amp;gt;&quot;/&gt; class.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;next&quot;&gt;The next Node.&lt;/param&gt;
    public
    Node (Node&lt;E&gt;  next)
    {
        this.m_next = next;
    }

    #endregion

    #region Public Properties

    /// &lt;summary&gt;
    /// Gets or sets the value.
    /// &lt;/summary&gt;
    /// &lt;value&gt;The value.&lt;/value&gt;
    public E
    Value
    {
        get
        {
            return m_value;
        }
        set
        {
            m_value = value;
        }
    }

    /// &lt;summary&gt;
    /// Gets or sets the next Node.
    /// &lt;/summary&gt;
    /// &lt;value&gt;The next Node.&lt;/value&gt;
    public Node&lt;E&gt;
    Next
    {
        get
        {
            return m_next;
        }
        set
        {
            m_next = value;
        }
    }

    #endregion

    #region Override Methods

    /// &lt;summary&gt;
    /// Returns a hash code for this instance.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// A hash code for this instance, suitable for use in hashing algorithms
    /// and data structures like a hash table. 
    /// &lt;/returns&gt;
    public override int
    GetHashCode ()
    {
        return m_next == null ? 
            m_value.GetHashCode () :
            m_value.GetHashCode () ^ m_next.GetHashCode ();
    }

    /// &lt;summary&gt;
    /// Determines whether the specified &lt;see cref=&quot;System.Object&quot;/&gt; is equal to this instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;obj&quot;&gt;The &lt;see cref=&quot;System.Object&quot;/&gt; to compare with this instance.&lt;/param&gt;
    /// &lt;returns&gt;
    /// 	&lt;c&gt;true&lt;/c&gt; if the specified &lt;see cref=&quot;System.Object&quot;/&gt; is equal to this instance; otherwise, &lt;c&gt;false&lt;/c&gt;.
    /// &lt;/returns&gt;
    /// &lt;exception cref=&quot;T:System.NullReferenceException&quot;&gt;
    /// The &lt;paramref name=&quot;obj&quot;/&gt; parameter is null.
    /// &lt;/exception&gt;
    public override bool
    Equals (object obj)
    {
        return this.Equals ((Node&lt;E&gt;) obj);
    }

    #endregion

    #region Private Methods

    /// &lt;summary&gt;
    /// Determains if the two objects are equal.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;obj&quot;&gt;The obj.&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private bool
    Equals (Node&lt;E&gt;  obj)
    {
        return m_value.Equals (obj.m_value) &amp;&amp;
            (m_next == null &amp;&amp; obj.m_next == null ?
            true : m_next.Equals (obj.m_next));
    }

    #endregion

    #region Private Member Data

    private E        m_value;
    private Node&lt;E&gt;  m_next;

    #endregion

}
#endregion

#region Class Definition : LinkedListEnum&lt;T&gt;
class LinkedListEnum&lt;T&gt; : IEnumerator&lt;T&gt;
{
    #region Constructor

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref=&quot;LinkedListEnum&amp;lt;T&amp;gt;&quot;/&gt; class.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;node&quot;&gt;The starting node.&lt;/param&gt;
    public
    LinkedListEnum (Node&lt;T&gt;  node)
    {
        m_origNode = node;
        m_currentNode = node;
    }

    #endregion

    #region IEnumerator Methods / Properties

    /// &lt;summary&gt;
    /// Advances the enumerator to the next element of the collection.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
    /// &lt;/returns&gt;
    /// &lt;exception cref=&quot;T:System.InvalidOperationException&quot;&gt;
    /// The collection was modified after the enumerator was created.
    /// &lt;/exception&gt;
    public bool
    MoveNext ()
    {
        lock (this.m_origNode)
        {
            m_currentNode = m_currentNode.Next;
            return (m_currentNode != null);
        }
    }

    /// &lt;summary&gt;
    /// Sets the enumerator to its initial position, which is before the first element in the collection.
    /// &lt;/summary&gt;
    /// &lt;exception cref=&quot;T:System.InvalidOperationException&quot;&gt;
    /// The collection was modified after the enumerator was created.
    /// &lt;/exception&gt;
    public void
    Reset ()
    {
        lock (this.m_origNode)
        {
            m_currentNode = new Node&lt;T&gt; ();
            m_currentNode.Next = m_origNode;
        }
    }

    /// &lt;summary&gt;
    /// Gets the element in the collection at the current position of the enumerator.
    /// &lt;/summary&gt;
    /// &lt;value&gt;&lt;/value&gt;
    /// &lt;returns&gt;
    /// The element in the collection at the current position of the enumerator.
    /// &lt;/returns&gt;
    object
    IEnumerator.Current
    {
        get
        {
            lock (this.m_origNode)
            {
                if (m_currentNode == null)
                    throw new InvalidOperationException ();
                return m_currentNode.Value;
            }
        }
    }

    #endregion

    #region IEnumerator&lt;T&gt; Properties

    /// &lt;summary&gt;
    /// Gets the element in the collection at the current position of the enumerator.
    /// &lt;/summary&gt;
    /// &lt;value&gt;&lt;/value&gt;
    /// &lt;returns&gt;
    /// The element in the collection at the current position of the enumerator.
    /// &lt;/returns&gt;
    T
    IEnumerator&lt;T&gt;.Current
    {
        get
        {
            lock (this.m_origNode)
            {
                if (m_currentNode == null)
                    throw new InvalidOperationException ();
                return m_currentNode.Value;
            }
        }
    }

    #endregion

    #region IDisposeable Methods

    /// &lt;summary&gt;
    /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
    /// &lt;/summary&gt;
    public void
    Dispose ()
    {
        //Nothing really to dispose of...
        ;
    }

    #endregion

    #region Private Member Data

    private Node&lt;T&gt;  m_origNode;
    private Node&lt;T&gt;  m_currentNode;

    #endregion

}
#endregion[/code]

I have full code with NUnit tests zipped:</description>
    
    <lastBuildDate>Sat, 31 Oct 2009 13:33:40 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>learn some abstraction first</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/19">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/19</link>
        <pubDate>Sat, 31 Oct 2009 13:33:40 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-19</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@unlimitedorb unlimitedorb]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/unlimitedorb">@unlimitedorb</a> wrote:</p>
          <blockquote>
              <p>Learn some Big O notation.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/18">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/18</link>
        <pubDate>Fri, 30 Oct 2009 21:31:26 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-18</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@Ollie Ollie]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ollie">@Ollie</a> wrote:</p>
          <blockquote>
              <aside class="quote no-group" data-post="16" data-topic="310858">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/yakman/40/5_513041d5f7104045db30895d3b90af16.png" class="avatar"> yakman:</div>
<blockquote>
<p>says wikipedia anyway…</p>
</blockquote>
</aside>
<p><img src="http://img249.imageshack.us/img249/4308/facebooklike.png" alt width="" height=""></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/17">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/17</link>
        <pubDate>Fri, 30 Oct 2009 21:19:27 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-17</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>suppose you have a list that has 500 elements, and you want to add a new element in the 250th index.</p>
<p>In a dynamic array backed list, you have shift the entire last 250 elements up one spot and possibly allocate a whole new array.<br>
In a linked list, you only gotta reassign some pointers and allocate a new element struct.</p>
<p>Both array lists and linked lists have their pros and cons, its foolish and simple-minded to say one is always better then the other.</p>
<p>says wikipedia anyway…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/16</link>
        <pubDate>Fri, 30 Oct 2009 21:08:37 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-16</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@abraham2119 abraham2119]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/abraham2119">@abraham2119</a> wrote:</p>
          <blockquote>
              <p>tell me why you would use a linkedlist over a simple, dynamically sized list again</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/15</link>
        <pubDate>Fri, 30 Oct 2009 19:49:40 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-15</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@Jython super_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jython">@Jython</a> wrote:</p>
          <blockquote>
              <p>[quote=“meiscooldude, post:11, topic:310858”]hehe</p>
<p><code>typedef struct {
int value;
ListNode* next;
} ListNode</code></p>
<hr>
<p>Anyway, can anyone seriously take a look at this code? or are we all just going to argue over stupid points?[/quote]</p>
<p>listnode is an undefined symbol when it is used to type a struct member</p>
<p>[code]    lnk_node *result;<br>
} _lnk_find_info;</p>
<p>void _lnk_find_iter(lnk_node *node, _lnk_find_info *info) {<br>
if ((*info-&gt;cmp)(node, info-&gt;to_find)) {<br>
info-&gt;result = node;<br>
}<br>
}</p>
<p>lnk_node *lnk_find(lnk_node *head, lnk_find_cmp cmp, void *info) {<br>
_lnk_find_info find_info;<br>
find_info.cmp = cmp;<br>
find_info.to_find = info;<br>
find_info.result = NULL;<br>
lnk_iterate(head, &amp;_lnk_find_iter, &amp;find_info);<br>
return find_info.result;<br>
}</p>
<p>void lnk_remove(lnk_node *prev, lnk_node *node) {<br>
prev-&gt;next = node-&gt;next;<br>
}</p>
<p>typedef struct __lnk_print_info {<br>
lnk_print_fmt fmt;<br>
void *info;<br>
} _lnk_print_info;</p>
<p>void _lnk_print_iter(lnk_node *node, _lnk_print_info *info) {<br>
printf("%s", (*info-&gt;fmt)(node, info-&gt;info));<br>
}</p>
<p>void lnk_print(lnk_node *node, lnk_print_fmt fmt, void *info) {<br>
_lnk_print_info print_info;<br>
print_info.fmt = fmt;<br>
print_info.info = info;<br>
lnk_iterate(node, &amp;_lnk_print_iter, &amp;print_info);<br>
}</p>
<p>void _lnk_size_iter(lnk_node *node, int *size) {<br>
++*size;<br>
}</p>
<p>int lnk_size(lnk_node *node) {<br>
int size = 0;<br>
lnk_iterate(node, &amp;_lnk_size_iter, &amp;size);<br>
return size;<br>
}<br>
[/code]</p>
<p>[code]<span class="hashtag">#ifndef</span> _FREQ_LNK<br>
<span class="hashtag">#define</span> _FREQ_LNK</p>
<p>typedef struct _lnk_node {<br>
void *info;<br>
struct _lnk_node *next;<br>
} lnk_node;</p>
<p>typedef void (* lnk_iter_func)(lnk_node *, void <em>);<br>
typedef int (</em> lnk_find_cmp)(lnk_node *, void *);<br>
typedef char <em>(</em> lnk_print_fmt)(lnk_node *, void *);</p>
<p>void lnk_iterate(lnk_node *, lnk_iter_func, void *);<br>
void lnk_insert(lnk_node *, lnk_node *);<br>
lnk_node *lnk_find(lnk_node *, lnk_find_cmp, void *);<br>
void lnk_remove(lnk_node *, lnk_node *);<br>
void lnk_print(lnk_node *, lnk_print_fmt, void *);<br>
int lnk_size(lnk_node *);</p>
<p><span class="hashtag">#endif</span><br>
[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/14</link>
        <pubDate>Wed, 28 Oct 2009 14:41:39 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-14</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>guys, he might be an idiot but actually try to help him</p>
<p>you said the problem was the equals method?</p>
<pre><code class="lang-auto">return m_front == null &amp;&amp; obj.m_front == null ? true : m_front.Equals (obj.m_front);</code></pre>
<p>that should probably be more like</p>
<pre><code class="lang-auto">return m_front == null ? obj.m_front == null : m_front.Equals(obj.m_front);</code></pre>
<p>and in Node</p>
<pre><code class="lang-auto">return m_value.Equals (obj.m_value) &amp;&amp; (m_next == null &amp;&amp; obj.m_next == null ? true : m_next.Equals (obj.m_next));</code></pre>
<p>should probably be</p>
<pre><code class="lang-auto">return m_value.Equals(obj.m_value) &amp;&amp; (m_next == null ? obj.m_next == null : m_next.Equals(obj.m_next);</code></pre>
<p>i would also advise against casting to your type in the Equals(object) methods and to not recursively calculate equality because it will blow out the stack on even a medium sized list</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/13</link>
        <pubDate>Wed, 28 Oct 2009 01:50:51 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-13</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@abraham2119 abraham2119]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/abraham2119">@abraham2119</a> wrote:</p>
          <blockquote>
              <p>ya i know unlimitedorb, i just posted my dynamic list because i see no use for linkedlist over dynamic lists…</p>
<p>its not like it uses less memory</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/12</link>
        <pubDate>Wed, 28 Oct 2009 01:36:24 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-12</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@meiscooldude meiscooldude]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/meiscooldude">@meiscooldude</a> wrote:</p>
          <blockquote>
              <p>hehe</p>
<p><code>typedef struct {
int value;
ListNode* next;
} ListNode</code></p>
<hr>
<p>Anyway, can anyone seriously take a look at this code? or are we all just going to argue over stupid points?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/11</link>
        <pubDate>Tue, 27 Oct 2009 21:37:20 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-11</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@unlimitedorb unlimitedorb]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/unlimitedorb">@unlimitedorb</a> wrote:</p>
          <blockquote>
              <p>[quote=“abraham2119, post:8, topic:310858”][quote author=unlimitedorb link=topic=407318.msg3009534#msg3009534 date=1256673404]<br>
“Removes the node… i think… =/”</p>
<p>This is why, for learning purposes, it’s better to implement a Linked List in a language that doesn’t rely on a garbage collector.<br>
[/quote]<br>
like in c:</p>
<p>list.h</p>
<pre><code class="lang-auto">/*Author: abraham2119*/

#ifndef _LIST

#define _LIST

#include &lt;stdlib.h&gt;

typedef struct {
    int index;
    int max;
    void **a;
} list;

extern void init_list(list *);
extern int size(list *);
extern void add(list *, void *);
extern void delete(list *, int);
extern void *get(list *, int);
extern void clear(list *);
extern void dispose(list *);

#endif</code></pre>
<p>list.c</p>
<p>[code]<br>
/<em>Author: abraham2119</em>/</p>
<p><span class="hashtag">#include</span> “list.h”</p>
<p>void init_list(list *l)<br>
{</p>
<pre><code>l-&gt;a = malloc(sizeof(void *) * 10);
l-&gt;max = 10;
l-&gt;index = 0;
</code></pre>
<p>}</p>
<p>int size(list *l)<br>
{<br>
return l-&gt;index;<br>
}</p>
<p>void add(list *l, void *obj)<br>
{<br>
if (l-&gt;index &gt;= l-&gt;max) {<br>
realloc((l-&gt;a), sizeof(void *) * (l-&gt;max * 2));<br>
l-&gt;max *= 2;<br>
}</p>
<pre><code>l-&gt;a[l-&gt;index++] = obj;
</code></pre>
<p>}</p>
<p>void delete(list *l, int index)<br>
{<br>
l-&gt;a[index] = NULL;</p>
<pre><code>int i = index;
int a;
for (a = 0; a &lt; (l-&gt;index - index)-1; a++, i++)
    l-&gt;a[i] = ((i + 1) == l-&gt;index) ? NULL : l-&gt;a[i+1];

l-&gt;index--;
</code></pre>
<p>}</p>
<p>void *get(list *l, int index)<br>
{<br>
return l-&gt;a[index];<br>
}</p>
<p>void clear(list *l)<br>
{<br>
int i;<br>
for (i = 0; i &lt; l-&gt;index; i++) {<br>
free(l-&gt;a[i]);<br>
l-&gt;a[i] = NULL;<br>
}<br>
}</p>
<p>void dispose(list *l)<br>
{<br>
int i = 0;<br>
for (; i &lt; l-&gt;index; i++) {<br>
free(l-&gt;a[i]);<br>
}</p>
<pre><code>free(l-&gt;a);
</code></pre>
<p>}[/code][/quote]</p>
<p>Except for the fact that that’s not a Linked List…?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/10</link>
        <pubDate>Tue, 27 Oct 2009 20:22:24 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-10</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@meiscooldude meiscooldude]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/meiscooldude">@meiscooldude</a> wrote:</p>
          <blockquote>
              <p>[quote=“unlimitedorb, post:7, topic:310858”]“Removes the node… i think… =/”</p>
<p>This is why, for learning purposes, it’s better to implement a Linked List in a language that doesn’t rely on a garbage collector.[/quote]</p>
<p>I’ve implemented a linked list in C in one of my classes before and I’m fairly certain I could implement on in C++ if I needed to (my c++ is a little sketchy), and I’m fairly certain the code next to that comment works like expected.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/9</link>
        <pubDate>Tue, 27 Oct 2009 20:14:10 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-9</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@abraham2119 abraham2119]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/abraham2119">@abraham2119</a> wrote:</p>
          <blockquote>
              <p>[quote=“unlimitedorb, post:7, topic:310858”]“Removes the node… i think… =/”</p>
<p>This is why, for learning purposes, it’s better to implement a Linked List in a language that doesn’t rely on a garbage collector.[/quote]<br>
like in c:</p>
<p>list.h</p>
<pre><code class="lang-auto">/*Author: abraham2119*/

#ifndef _LIST

#define _LIST

#include &lt;stdlib.h&gt;

typedef struct {
    int index;
    int max;
    void **a;
} list;

extern void init_list(list *);
extern int size(list *);
extern void add(list *, void *);
extern void delete(list *, int);
extern void *get(list *, int);
extern void clear(list *);
extern void dispose(list *);

#endif</code></pre>
<p>list.c</p>
<p>[code]<br>
/<em>Author: abraham2119</em>/</p>
<p><span class="hashtag">#include</span> “list.h”</p>
<p>void init_list(list *l)<br>
{</p>
<pre><code>l-&gt;a = malloc(sizeof(void *) * 10);
l-&gt;max = 10;
l-&gt;index = 0;
</code></pre>
<p>}</p>
<p>int size(list *l)<br>
{<br>
return l-&gt;index;<br>
}</p>
<p>void add(list *l, void *obj)<br>
{<br>
if (l-&gt;index &gt;= l-&gt;max) {<br>
realloc((l-&gt;a), sizeof(void *) * (l-&gt;max * 2));<br>
l-&gt;max *= 2;<br>
}</p>
<pre><code>l-&gt;a[l-&gt;index++] = obj;
</code></pre>
<p>}</p>
<p>void delete(list *l, int index)<br>
{<br>
l-&gt;a[index] = NULL;</p>
<pre><code>int i = index;
int a;
for (a = 0; a &lt; (l-&gt;index - index)-1; a++, i++)
    l-&gt;a[i] = ((i + 1) == l-&gt;index) ? NULL : l-&gt;a[i+1];

l-&gt;index--;
</code></pre>
<p>}</p>
<p>void *get(list *l, int index)<br>
{<br>
return l-&gt;a[index];<br>
}</p>
<p>void clear(list *l)<br>
{<br>
int i;<br>
for (i = 0; i &lt; l-&gt;index; i++) {<br>
free(l-&gt;a[i]);<br>
l-&gt;a[i] = NULL;<br>
}<br>
}</p>
<p>void dispose(list *l)<br>
{<br>
int i = 0;<br>
for (; i &lt; l-&gt;index; i++) {<br>
free(l-&gt;a[i]);<br>
}</p>
<pre><code>free(l-&gt;a);
</code></pre>
<p>}[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/8</link>
        <pubDate>Tue, 27 Oct 2009 20:05:36 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-8</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@unlimitedorb unlimitedorb]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/unlimitedorb">@unlimitedorb</a> wrote:</p>
          <blockquote>
              <p>“Removes the node… i think… =/”</p>
<p>This is why, for learning purposes, it’s better to implement a Linked List in a language that doesn’t rely on a garbage collector.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/7</link>
        <pubDate>Tue, 27 Oct 2009 19:56:44 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-7</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@meiscooldude meiscooldude]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/meiscooldude">@meiscooldude</a> wrote:</p>
          <blockquote>
              <p>[quote=“Unhandled, post:2, topic:310858”]1) I seriously doubt you wrote this.<br>
2) Saying “It’s not working exactly the way it needs to” doesn’t give anyone the slightest clue what is actually wrong with it nor what they should look for to fix it.<br>
3) Why the fuck can’t you use System.Collections.Generic.LinkedList?[/quote]</p>
<ol>
<li>
<p>I did write this, I’m not sure why you doubt that I did.</p>
</li>
<li>
<p>Sorry for the poor description. I ran a few Unit Tests, and found that my Equals method is not working correctly… I think i’m overlooking something simple.</p>
</li>
<li>
<p>I could use .NET’s LinkedList, but I decided to implement my own just to see if I could do it…</p>
</li>
</ol>
<p>[To Lothy:] This was just for fun actually</p>
<p>[code]using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
using System.Text;</p>
<p>using NUnit.Framework;</p>
<p>[TestFixture]<br>
public class LinkedListTests<br>
{<br>
[TestFixtureSetUp]<br>
public void<br>
Init ()<br>
{<br>
m_list = new LinkedList ();<br>
}</p>
<pre><code>[TearDown]
public void
Reset ()
{
    m_list = new LinkedList&lt;int&gt; ();
}

[Test]
public void
AddRemoveTest ([Values (new int[] {1,6,3,2,7,2},
                        new int[] {76,2,6,23,6,1,4,5,3},
                        new int[] {6,32,76,13,4,21,5,3,423},
                        new int[] {3,62,6,3,62,8,2,3},
                        new int[] {4},
                        new int[] {})] int[] arr)
{
    int[]  array = new int[arr.Length];

    foreach (int i in arr)
    {
        m_list.Add (i);
        Console.Write ("{0}, ", i);
    }
    
    for (int i = 0; i &lt; arr.Length; i++)
    {
        Assert.That (arr[i] == m_list[i]);
    }
}

[Test]
public void
CopyToTest ([Values (new int[] {1,6,3,2,7,2},
                     new int[] {76,2,6,23,6,1,4,5,3},
                     new int[] {6,32,76,13,4,21,5,3,423},
                     new int[] {3,62,6,3,62,8,2,3},
                     new int[] {4},
                     new int[] {})] int[] arr)
{
    int[]  array = new int[arr.Length];

    foreach (int i in arr)
    {
        m_list.Add (i);
        Console.Write ("{0}, ", i);
    }

    m_list.CopyTo (array, 0);

    for(int i = 0; i &lt; arr.Length; i++)
    {
        Assert.That (arr[i] == array[i]);
    }
}

[Test]
public void
ContainsTest ([Values (1, 5, 9, 7, 2)] int i)
{
    m_list.Add (i);

    Assert.That (!m_list.Contains ((i + 1)));
    Assert.That (m_list.Contains (i));
}

[Test]
public void
EqualsTest ([Values (new int[] {1,6,3,2,7,2},
                     new int[] {76,2,6,23,6,1,4,5,3},
                     new int[] {6,32,76,13,4,21,5,3,423},
                     new int[] {3,62,6,3,62,8,2,3},
                     new int[] {4},
                     new int[] {})] int[] arr)
{
    LinkedList&lt;int&gt;  other;

    other = new LinkedList&lt;int&gt; ();

    foreach (int i in arr)
    {
        m_list.Add (i);
        other.Add (i);
    }

    Console.Write (m_list.Equals (other));
    Assert.That (m_list.Equals (other));

    other.Add (3);
    
    Console.Write (m_list.Equals (other));
    Assert.That (!m_list.Equals (other));
}

//Make sure to be explicit on which linked list you use...
private LinkedList&lt;int&gt;  m_list;
</code></pre>
<p>}[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/6</link>
        <pubDate>Tue, 27 Oct 2009 19:23:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-6</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@Speljohan Speljohan]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speljohan">@Speljohan</a> wrote:</p>
          <blockquote>
              <p>[quote=“abraham2119, post:4, topic:310858”][quote author=Unhandled link=topic=407318.msg3008466#msg3008466 date=1256587112]</p>
<ol>
<li>I seriously doubt you wrote this.</li>
<li>Saying “It’s not working exactly the way it needs to” doesn’t give anyone the slightest clue what is actually wrong with it nor what they should look for to fix it.</li>
<li>Why the fuck can’t you use System.Collections.Generic.LinkedList?<br>
[/quote]why would you doubt he wrote this? i know him for quite a while now and he is more than capable of writing something as easy as this. of course, c# is his “first/strongest language”[/quote]If he can write this he can easily solve his own problems.</li>
</ol>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/5</link>
        <pubDate>Tue, 27 Oct 2009 19:12:42 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-5</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@abraham2119 abraham2119]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/abraham2119">@abraham2119</a> wrote:</p>
          <blockquote>
              <p>[quote=“Unhandled, post:2, topic:310858”]1) I seriously doubt you wrote this.<br>
2) Saying “It’s not working exactly the way it needs to” doesn’t give anyone the slightest clue what is actually wrong with it nor what they should look for to fix it.<br>
3) Why the fuck can’t you use System.Collections.Generic.LinkedList?[/quote]why would you doubt he wrote this? i know him for quite a while now and he is more than capable of writing something as easy as this. of course, c# is his “first/strongest language”</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/4</link>
        <pubDate>Tue, 27 Oct 2009 19:04:45 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-4</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@lothy Lothy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lothy">@lothy</a> wrote:</p>
          <blockquote>
              <p>He might need to implement one from first principles for school (or something similar).</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/3</link>
        <pubDate>Tue, 27 Oct 2009 00:57:35 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-3</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@Unhandled Unhandled]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/unhandled">@Unhandled</a> wrote:</p>
          <blockquote>
              <ol>
<li>I seriously doubt you wrote this.</li>
<li>Saying “It’s not working exactly the way it needs to” doesn’t give anyone the slightest clue what is actually wrong with it nor what they should look for to fix it.</li>
<li>Why the fuck can’t you use System.Collections.Generic.LinkedList?</li>
</ol>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/2</link>
        <pubDate>Mon, 26 Oct 2009 19:58:32 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-2</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
      <item>
        <title>Debug this Linked List</title>
        <dc:creator><![CDATA[@meiscooldude meiscooldude]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/meiscooldude">@meiscooldude</a> wrote:</p>
          <blockquote>
              <p>Here is some C# code I wrote for a Generic Linked List. I ran some Unit Tests just to make sure that everything worked fine in it, but not all of my tests passed, specifically one that tests my Equals Method.</p>
<p>I had a good look at it, and it seems it should work, but it doesn’t, so I’m suspecting I overlooked something simple… (Chances are if my equals method isn’t working, my other methods may night be working exactly as I wanted them either…)</p>
<p>I just wanted to see if someone could give me a quick code review to see what I missed.</p>
<p>[code]<span class="hashtag">#region</span> Using Directives</p>
<p>using System.Collections.Generic;<br>
using System;<br>
using System.Collections;</p>
<p><span class="hashtag">#endregion</span></p>
<p><span class="hashtag">#region</span> Class Definition : LinkedList<br>
[Serializable]<br>
public class LinkedList : ICollection <br>
{</p>
<pre><code>#region Constructor

/// &lt;summary&gt;
/// Initializes a new instance of the &lt;see cref="LinkedList&amp;lt;T&amp;gt;"/&gt; class.
/// &lt;/summary&gt;
public
LinkedList ()
{
    this.m_front = null;
    this.m_count = 0;
}

#endregion

#region Overloaded Operators

/// &lt;summary&gt;
/// Returns the &lt;see cref="T"/&gt; at the entered index.
/// &lt;/summary&gt;
/// &lt;param name="index"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public T
this [int index]
{
    get
    {
        lock (this.m_padlock)
        {
            if (index &lt; 0 || index &gt;= this.m_count)
                throw new IndexOutOfRangeException  ();

            Node&lt;T&gt;  node = this.m_front;
            int      cnt = 0;

            /*
             * In a doubly linked list, I could
             * double the speed of this method
             * by simply dividing the count,
             * comare it to the index, then decide
             * which end to start the search.
             * 
             * But, I'm not in a doubly linked list,
             * so, I'm stuck with any index operation
             * costing O(N)     =/
             * 
             * And... in all honesty, I hate this
             * implementation of the index operator.
             * 
             * Looping through using the index
             * operator of this object would run
             * ... ugh... but take an exponential
             * amount of time.
             *
             */
            while (cnt++ != index)
            {
                node = node.Next;
            }

            return  node.Value;
        }
    }
    set
    {
        lock (this.m_padlock)
        {
            if (index &lt; 0 || index &gt;= this.m_count)
                throw new IndexOutOfRangeException  ();

            Node&lt;T&gt;  node = this.m_front;
            int      cnt = 0;


            //See remarks on 'get'

            while (cnt++ != index)
            {
                node = node.Next;
            }

            node.Value = value;
        }
    }
}

#endregion

#region ICollection Methods/Properties

/// &lt;summary&gt;
/// Adds the specified value to the collection.
/// &lt;/summary&gt;
/// &lt;param name="value"&gt;The value to add to the collection.&lt;/param&gt;
public void
Add (T value)
{
    lock (this.m_padlock)
    {
        if (this.m_front == null)
        {
            this.m_front = new Node&lt;T&gt; (value);
            this.m_count++;
        }
        else if (this.m_last == null)
        {
            this.m_last = new Node&lt;T&gt; (value);
            this.m_front.Next = m_last;
            this.m_count++;
        }
        else
        {
            Node&lt;T&gt;  tempNode = new Node&lt;T&gt; (value);
            this.m_last.Next = tempNode;
            this.m_last = tempNode;
            this.m_count++;
        }
    }
}

/// &lt;summary&gt;
/// Gets a value indicating whether the &lt;see cref="T:System.Collections.Generic.ICollection`1"/&gt; is read-only.
/// &lt;/summary&gt;
/// &lt;value&gt;&lt;/value&gt;
/// &lt;returns&gt;true if the &lt;see cref="T:System.Collections.Generic.ICollection`1"/&gt; is read-only; otherwise, false.
/// &lt;/returns&gt;
public bool
IsReadOnly
{
    get
    {
        return READONLY;
    }
}

/// &lt;summary&gt;
/// Gets the number of elements contained in the &lt;see cref="T:System.Collections.Generic.ICollection`1"/&gt;.
/// &lt;/summary&gt;
/// &lt;value&gt;&lt;/value&gt;
/// &lt;returns&gt;
/// The number of elements contained in the &lt;see cref="T:System.Collections.Generic.ICollection`1"/&gt;.
/// &lt;/returns&gt;
public int
Count
{
    get
    {
        return m_count;
    }
}

/// &lt;summary&gt;
/// Removes all items from the &lt;see cref="T:System.Collections.Generic.ICollection`1"/&gt;.
/// &lt;/summary&gt;
/// &lt;exception cref="T:System.NotSupportedException"&gt;
/// The &lt;see cref="T:System.Collections.Generic.ICollection`1"/&gt; is read-only.
/// &lt;/exception&gt;
public void
Clear ()
{
    lock (this.m_padlock)
    {
        this.m_last = null;
        this.m_front = null;
        this.m_count = 0;
    }
}

/// &lt;summary&gt;
/// Determines whether this collection contains the specified value.
/// &lt;/summary&gt;
/// &lt;param name="value"&gt;The value.&lt;/param&gt;
/// &lt;returns&gt;
/// 	&lt;c&gt;true&lt;/c&gt; if this collection contains the specified value; otherwise, &lt;c&gt;false&lt;/c&gt;.
/// &lt;/returns&gt;
public bool
Contains (T value)
{
    lock (this.m_padlock)
    {
        if (this.m_count == 0)
            return false;

        Node&lt;T&gt;  node = this.m_front;

        do
        {
            if (node.Value.Equals (value))
                return true;
        } while ((node = node.Next) != null);
        return false;
    }
}

/// &lt;summary&gt;
/// Removes the specified value from the linked list.
/// &lt;/summary&gt;
/// &lt;param name="value"&gt;The value to remove.&lt;/param&gt;
/// &lt;returns&gt;
///     &lt;c&gt;true&lt;/c&gt; if the value was removed; otherwise, &lt;c&gt;false&lt;/c&gt;
/// &lt;/returns&gt;
public bool
Remove (T value)
{
    lock (this.m_padlock)
    {
        if (this.m_count == 0)
            return false;

        Node&lt;T&gt;  node = this.m_front;

        if (node.Value.Equals (value))
        {
            this.m_front = node.Next;
            this.m_count--;
            return true;
        }

        do
        {
            if (node.Next != null &amp;&amp; node.Next.Value.Equals (value))
            {
                /*
                 * Removes the node... i think... =/
                 * 
                 * 11:11pm, MAKE A WISH!
                 */
                node.Next = node.Next.Next;

                this.m_count--;
                return true;
            }
        } while ((node = node.Next) != null);

        return false;
    }
}

/// &lt;summary&gt;
/// Copies the elements of this Collection to the given array.
/// &lt;/summary&gt;
/// &lt;param name="array"&gt;The zero-based array.&lt;/param&gt;
/// &lt;param name="index"&gt;The zero-based index to start writing on the array.&lt;/param&gt;
public void
CopyTo (T[] array, int index)
{
    lock (this.m_padlock)
    {
        if (this.m_count == 0)
            return;

        if (this.m_count &gt; array.Length - index)
            throw new IndexOutOfRangeException ();

        Node&lt;T&gt;  node = this.m_front;

        do
        {
            array[index++] = node.Value;
        } while ((node = node.Next) != null);
    }
}


#endregion

#region IEnumerable&lt;T&gt; Methods

/// &lt;summary&gt;
/// Returns an enumerator that iterates through the collection.
/// &lt;/summary&gt;
/// &lt;returns&gt;
/// A &lt;see cref="T:System.Collections.Generic.IEnumerator`1"/&gt; that can be used to iterate through the collection.
/// &lt;/returns&gt;
IEnumerator&lt;T&gt;
IEnumerable&lt;T&gt;.GetEnumerator ()
{
    // We have this lock because of constructor logic.
    lock (this.m_padlock)
    {
        return new LinkedListEnum&lt;T&gt; (this.m_front);
    }
}

#endregion

#region IEnumerable Methods

/// &lt;summary&gt;
/// Returns an enumerator that iterates through a collection.
/// &lt;/summary&gt;
/// &lt;returns&gt;
/// An &lt;see cref="T:System.Collections.IEnumerator"/&gt; object that can be used to iterate through the collection.
/// &lt;/returns&gt;
IEnumerator
IEnumerable.GetEnumerator ()
{
    // See IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ()
    lock(this.m_padlock)
    {
        return new LinkedListEnum&lt;T&gt; (this.m_front);
    }
}

#endregion

#region Object Methods

/// &lt;summary&gt;
/// Returns a hash code for this instance.
/// &lt;/summary&gt;
/// &lt;returns&gt;
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// &lt;/returns&gt;
public override int
GetHashCode ()
{
    lock (this.m_padlock)
    {
        return m_front.GetHashCode();
    }
}

/// &lt;summary&gt;
/// Determines whether the specified &lt;see cref="System.Object"/&gt; is equal to this instance.
/// &lt;/summary&gt;
/// &lt;param name="obj"&gt;The &lt;see cref="System.Object"/&gt; to compare with this instance.&lt;/param&gt;
/// &lt;returns&gt;
/// 	&lt;c&gt;true&lt;/c&gt; if the specified &lt;see cref="System.Object"/&gt; is equal to this instance; otherwise, &lt;c&gt;false&lt;/c&gt;.
/// &lt;/returns&gt;
/// &lt;exception cref="T:System.NullReferenceException"&gt;
/// The &lt;paramref name="obj"/&gt; parameter is null.
/// &lt;/exception&gt;
public override bool
Equals(object obj)
{
    return this.Equals ((LinkedList&lt;T&gt;) obj);
}

#endregion

#region Private Methods

/// &lt;summary&gt;
/// Determines if the two objects are equal.
/// &lt;/summary&gt;
/// &lt;param name="obj"&gt;The obj.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private bool
Equals (LinkedList&lt;T&gt;  obj)
{
    
    lock (obj.m_padlock)
    {
        // Possible deadlock here...
        lock (this.m_padlock)
        {
            return m_front == null &amp;&amp; obj.m_front == null ?
                true : m_front.Equals (obj.m_front);
        }
    }
}

#endregion

#region Private Member Data

private Node&lt;T&gt;  m_front;
private Node&lt;T&gt;  m_last;
private int      m_count;
private object   m_padlock = new object ();

#endregion

#region Constants

private const bool    READONLY = false;

#endregion
</code></pre>
<p>}<br>
<span class="hashtag">#endregion</span></p>
<p><span class="hashtag">#region</span> Class Definition : Node<br>
[Serializable]<br>
internal class Node <br>
{</p>
<pre><code>#region Constructors

/// &lt;summary&gt;
/// Initializes a new instance of the &lt;see cref="Node&amp;lt;E&amp;gt;"/&gt; class.
/// &lt;/summary&gt;
public
Node ()
{
    this.m_value = default(E);
}

/// &lt;summary&gt;
/// Initializes a new instance of the &lt;see cref="Node&amp;lt;E&amp;gt;"/&gt; class.
/// &lt;/summary&gt;
/// &lt;param name="value"&gt;The value stored in this Node.&lt;/param&gt;
public
Node (E  value)
{
    this.m_value = value;
}

/// &lt;summary&gt;
/// Initializes a new instance of the &lt;see cref="Node&amp;lt;E&amp;gt;"/&gt; class.
/// &lt;/summary&gt;
/// &lt;param name="next"&gt;The next Node.&lt;/param&gt;
public
Node (Node&lt;E&gt;  next)
{
    this.m_next = next;
}

#endregion

#region Public Properties

/// &lt;summary&gt;
/// Gets or sets the value.
/// &lt;/summary&gt;
/// &lt;value&gt;The value.&lt;/value&gt;
public E
Value
{
    get
    {
        return m_value;
    }
    set
    {
        m_value = value;
    }
}

/// &lt;summary&gt;
/// Gets or sets the next Node.
/// &lt;/summary&gt;
/// &lt;value&gt;The next Node.&lt;/value&gt;
public Node&lt;E&gt;
Next
{
    get
    {
        return m_next;
    }
    set
    {
        m_next = value;
    }
}

#endregion

#region Override Methods

/// &lt;summary&gt;
/// Returns a hash code for this instance.
/// &lt;/summary&gt;
/// &lt;returns&gt;
/// A hash code for this instance, suitable for use in hashing algorithms
/// and data structures like a hash table. 
/// &lt;/returns&gt;
public override int
GetHashCode ()
{
    return m_next == null ? 
        m_value.GetHashCode () :
        m_value.GetHashCode () ^ m_next.GetHashCode ();
}

/// &lt;summary&gt;
/// Determines whether the specified &lt;see cref="System.Object"/&gt; is equal to this instance.
/// &lt;/summary&gt;
/// &lt;param name="obj"&gt;The &lt;see cref="System.Object"/&gt; to compare with this instance.&lt;/param&gt;
/// &lt;returns&gt;
/// 	&lt;c&gt;true&lt;/c&gt; if the specified &lt;see cref="System.Object"/&gt; is equal to this instance; otherwise, &lt;c&gt;false&lt;/c&gt;.
/// &lt;/returns&gt;
/// &lt;exception cref="T:System.NullReferenceException"&gt;
/// The &lt;paramref name="obj"/&gt; parameter is null.
/// &lt;/exception&gt;
public override bool
Equals (object obj)
{
    return this.Equals ((Node&lt;E&gt;) obj);
}

#endregion

#region Private Methods

/// &lt;summary&gt;
/// Determains if the two objects are equal.
/// &lt;/summary&gt;
/// &lt;param name="obj"&gt;The obj.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private bool
Equals (Node&lt;E&gt;  obj)
{
    return m_value.Equals (obj.m_value) &amp;&amp;
        (m_next == null &amp;&amp; obj.m_next == null ?
        true : m_next.Equals (obj.m_next));
}

#endregion

#region Private Member Data

private E        m_value;
private Node&lt;E&gt;  m_next;

#endregion
</code></pre>
<p>}<br>
<span class="hashtag">#endregion</span></p>
<p><span class="hashtag">#region</span> Class Definition : LinkedListEnum<br>
class LinkedListEnum : IEnumerator<br>
{<br>
<span class="hashtag">#region</span> Constructor</p>
<pre><code>/// &lt;summary&gt;
/// Initializes a new instance of the &lt;see cref="LinkedListEnum&amp;lt;T&amp;gt;"/&gt; class.
/// &lt;/summary&gt;
/// &lt;param name="node"&gt;The starting node.&lt;/param&gt;
public
LinkedListEnum (Node&lt;T&gt;  node)
{
    m_origNode = node;
    m_currentNode = node;
}

#endregion

#region IEnumerator Methods / Properties

/// &lt;summary&gt;
/// Advances the enumerator to the next element of the collection.
/// &lt;/summary&gt;
/// &lt;returns&gt;
/// true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
/// &lt;/returns&gt;
/// &lt;exception cref="T:System.InvalidOperationException"&gt;
/// The collection was modified after the enumerator was created.
/// &lt;/exception&gt;
public bool
MoveNext ()
{
    lock (this.m_origNode)
    {
        m_currentNode = m_currentNode.Next;
        return (m_currentNode != null);
    }
}

/// &lt;summary&gt;
/// Sets the enumerator to its initial position, which is before the first element in the collection.
/// &lt;/summary&gt;
/// &lt;exception cref="T:System.InvalidOperationException"&gt;
/// The collection was modified after the enumerator was created.
/// &lt;/exception&gt;
public void
Reset ()
{
    lock (this.m_origNode)
    {
        m_currentNode = new Node&lt;T&gt; ();
        m_currentNode.Next = m_origNode;
    }
}

/// &lt;summary&gt;
/// Gets the element in the collection at the current position of the enumerator.
/// &lt;/summary&gt;
/// &lt;value&gt;&lt;/value&gt;
/// &lt;returns&gt;
/// The element in the collection at the current position of the enumerator.
/// &lt;/returns&gt;
object
IEnumerator.Current
{
    get
    {
        lock (this.m_origNode)
        {
            if (m_currentNode == null)
                throw new InvalidOperationException ();
            return m_currentNode.Value;
        }
    }
}

#endregion

#region IEnumerator&lt;T&gt; Properties

/// &lt;summary&gt;
/// Gets the element in the collection at the current position of the enumerator.
/// &lt;/summary&gt;
/// &lt;value&gt;&lt;/value&gt;
/// &lt;returns&gt;
/// The element in the collection at the current position of the enumerator.
/// &lt;/returns&gt;
T
IEnumerator&lt;T&gt;.Current
{
    get
    {
        lock (this.m_origNode)
        {
            if (m_currentNode == null)
                throw new InvalidOperationException ();
            return m_currentNode.Value;
        }
    }
}

#endregion

#region IDisposeable Methods

/// &lt;summary&gt;
/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
/// &lt;/summary&gt;
public void
Dispose ()
{
    //Nothing really to dispose of...
    ;
}

#endregion

#region Private Member Data

private Node&lt;T&gt;  m_origNode;
private Node&lt;T&gt;  m_currentNode;

#endregion
</code></pre>
<p>}<br>
<span class="hashtag">#endregion</span>[/code]</p>
<p>I have full code with NUnit tests zipped:</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/debug-this-linked-list/310858/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/debug-this-linked-list/310858/1</link>
        <pubDate>Mon, 26 Oct 2009 18:21:35 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-310858-1</guid>
        <source url="https://forum.moparisthebest.com/t/debug-this-linked-list/310858.rss">Debug this Linked List</source>
      </item>
  </channel>
</rss>
