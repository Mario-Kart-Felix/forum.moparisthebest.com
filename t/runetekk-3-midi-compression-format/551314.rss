<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>RuneTekk 3+ - MIDI Compression Format</title>
    <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314</link>
    <description>This is a refactor of the jagex midi compression format. Strict encoding is required for most media players.

[code=java]
package com.jagex;

import com.jagex.io.Buffer;

/**
 * Created by hadyn on 5/1/2015.
 */
public class MidiCodec {

    private static final int EVENT_NOTE_ON = 0x0;
    private static final int EVENT_NOTE_OFF = 0x1;
    private static final int EVENT_CONTROL_CHANGE = 0x2;
    private static final int EVENT_PITCH_BEND = 0x3;
    private static final int EVENT_CHANNEL_PRESSURE = 0x4;
    private static final int EVENT_KEY_PRESSURE = 0x5;
    private static final int EVENT_PROGRAM_CHANGE = 0x6;
    private static final int EVENT_END_OF_TRACK = 0x07;
    private static final int EVENT_SET_TEMPO = 0x17;

    private static final int CONTROLLER_BANK_SELECT = 0;
    private static final int CONTROLLER_BANK_SELECT_LSB = 32;
    private static final int CONTROLLER_MODULATION_WHEEL = 1;
    private static final int CONTROLLER_MODULATION_WHEEL_LSB = 33;
    private static final int CONTROLLER_CHANNEL_VOLUME = 7;
    private static final int CONTROLLER_CHANNEL_VOLUME_LSB = 39;
    private static final int CONTROLLER_PAN = 10;
    private static final int CONTROLLER_PAN_LSB = 42;
    private static final int CONTROLLER_NRPN = 99;
    private static final int CONTROLLER_NRPN_LSB = 98;
    private static final int CONTROLLER_RPN = 101;
    private static final int CONTROLLER_RPN_LSB = 100;
    private static final int CONTROLLER_DAMPER_PEDAL = 64;
    private static final int CONTROLLER_PORTAMENDO = 65;
    private static final int CONTROLLER_ALL_SOUND_OFF = 120;
    private static final int CONTROLLER_RESET_ALL_CONTROLLERS = 121;
    private static final int CONTROLLER_ALL_NOTES_OFF = 123;

    private static final int TYPE_END_OF_TRACK = 0x2f;
    private static final int TYPE_SET_TEMPO = 0x51;

    byte[] data;

    public MidiCodec() {}

    void parse(Buffer input, boolean strict) {

        // Read the footer which contains the amount
        // of track and
        input.position(input.capacity() - 3);
        int tracks = input.getUInt8();
        int division = input.getUInt16();

        int length = 14 + tracks * 10;
        input.position(0);

        int tempoCount = 0;
        int controlChangeCount = 0;
        int noteOnCount = 0;
        int noteOffCount = 0;
        int pitchBendCount = 0;
        int channelPressureCount = 0;
        int keyPressureCount = 0;
        int programChangeCount = 0;

        // Parse and count each of the event opcodes
        int i;
        int j;
        int track = 0;
        while(track &lt; tracks) {
            i = -1;
            while(true) {
                j = input.getUInt8();

                if(strict || i != j) {
                    ++length;
                }

                i = j &amp; 0xf;
                if(j == EVENT_END_OF_TRACK) {
                    ++track;
                    break;
                }

                if(j == EVENT_SET_TEMPO) {
                    ++tempoCount;
                } else if(i == EVENT_NOTE_ON) {
                    ++noteOnCount;
                } else if(i == EVENT_NOTE_OFF) {
                    ++noteOffCount;
                } else if(i == EVENT_CONTROL_CHANGE) {
                    ++controlChangeCount;
                } else if(i == EVENT_PITCH_BEND) {
                    ++pitchBendCount;
                } else if(i == EVENT_CHANNEL_PRESSURE) {
                    ++channelPressureCount;
                } else if(i == EVENT_KEY_PRESSURE) {
                    ++keyPressureCount;
                } else {
                    if(i != EVENT_PROGRAM_CHANGE) {
                        throw new RuntimeException();
                    }
                    ++programChangeCount;
                }
            }
        }

        // Append the amount of data for each event
        length += 5 * tempoCount;
        length += 2 * (noteOnCount + noteOffCount + controlChangeCount + pitchBendCount + keyPressureCount);
        length += channelPressureCount + programChangeCount;

        // TODO: Eventually remove this shit
        int deltaTimeOffset = input.position();

        // Parse the delta time for each event
        int deltaTimeStart = input.position();
        int eventCount = tracks + tempoCount + controlChangeCount + noteOnCount +
                noteOffCount + pitchBendCount + channelPressureCount +
                keyPressureCount + programChangeCount;
        for(int l = 0; l &lt; eventCount; l++) {
            input.getVariableLength();
        }

        // Append the data length of the event delta times
        // to the length of the decompressed output
        length += input.position() - deltaTimeStart;

        // Mark where the controller data begins
        int controllerOffset = input.position();

        // Count each of the controller changes
        int modulationWheelCount = 0;
        int modulationWheelMsbCount = 0;
        int channelVolumeCount = 0;
        int channelVolumeLsbCount = 0;
        int panCount = 0;
        int panLsbCount = 0;
        int nrpnCount = 0;
        int nrpnLsbCount = 0;
        int rpnCount = 0;
        int rpnLsbCount = 0;
        int var26 = 0;
        int toggleCount = 0;
        int controller = 0;

        for(int k = 0; k &lt; controlChangeCount; k++) {
            controller = controller + input.getUInt8() &amp; 127;
            if(controller != CONTROLLER_BANK_SELECT &amp;&amp; controller != CONTROLLER_BANK_SELECT_LSB) {
                if(controller == CONTROLLER_MODULATION_WHEEL) {
                    ++modulationWheelCount;
                } else if(controller == CONTROLLER_MODULATION_WHEEL_LSB) {
                    ++modulationWheelMsbCount;
                } else if(controller == CONTROLLER_CHANNEL_VOLUME) {
                    ++channelVolumeCount;
                } else if(controller == CONTROLLER_CHANNEL_VOLUME_LSB) {
                    ++channelVolumeLsbCount;
                } else if(controller == CONTROLLER_PAN) {
                    ++panCount;
                } else if(controller == CONTROLLER_PAN_LSB) {
                    ++panLsbCount;
                } else if(controller == CONTROLLER_NRPN) {
                    ++nrpnCount;
                } else if(controller == CONTROLLER_NRPN_LSB) {
                    ++nrpnLsbCount;
                } else if(controller == CONTROLLER_RPN) {
                    ++rpnCount;
                } else if(controller == CONTROLLER_RPN_LSB) {
                    ++rpnLsbCount;
                } else if(controller != CONTROLLER_DAMPER_PEDAL &amp;&amp; controller != CONTROLLER_PORTAMENDO &amp;&amp;
                        controller != CONTROLLER_ALL_SOUND_OFF &amp;&amp; controller != CONTROLLER_RESET_ALL_CONTROLLERS &amp;&amp;
                        controller != CONTROLLER_ALL_NOTES_OFF) {
                    ++toggleCount;
                } else {
                    ++var26;
                }
            } else {
                ++programChangeCount;
            }
        }

        // Calculate each of the offsets for all of the data to encode
        // the midi file with.
        int opcodeOffset = 0;

        int var30 = input.position();
        input.skip(var26);

        int keyPressureOffset = input.position();
        input.skip(keyPressureCount);

        int channelPressureOffset = input.position();
        input.skip(channelPressureCount);

        int var33 = input.position();
        input.skip(pitchBendCount);

        int modulationWheelOffset = input.position();
        input.skip(modulationWheelCount);

        int channelVolumeOffset = input.position();
        input.skip(channelVolumeCount);

        int panOffset = input.position();
        input.skip(panCount);

        int keyOffset = input.position();
        input.skip(noteOnCount + noteOffCount + keyPressureCount);

        int onVelocityOffset = input.position();
        input.skip(noteOnCount);

        int toggleOffset = input.position();
        input.skip(toggleCount);

        int offVelocityOffset = input.position();
        input.skip(noteOffCount);

        int modulationWheelLsbOffset = input.position();
        input.skip(modulationWheelMsbCount);

        int channelVolumeLsbOffset = input.position();
        input.skip(channelVolumeLsbCount);

        int panLsbOffset = input.position();
        input.skip(panLsbCount);

        int programChangeOffset = input.position();
        input.skip(programChangeCount);

        int var45 = input.position();
        input.skip(pitchBendCount);

        int nrpnOffset = input.position();
        input.skip(nrpnCount);

        int nrpnLsbOffset = input.position();
        input.skip(nrpnLsbCount);

        int rpnOffset = input.position();
        input.skip(rpnCount);

        int rpnLsbOffset = input.position();
        input.skip(rpnLsbCount);

        int tempoSetOffset = input.position();
        input.skip(tempoCount * 3);

        // Create a buffer to put the encoded midi file
        data = new byte[length];

        Buffer outputBuf = new Buffer(data);

        // Encode the header chunk to the output buffer, big endian
        // 0:   int32 -&gt; &#39;MThd&#39;
        // 4:   int32 -&gt; chunk_len
        // 8:   int16 -&gt; format
        // 10:  int16 -&gt; tracks
        // 12:  int16 -&gt; division
        //
        // format notes
        // ------------------------------------------------------------
        // format 0 -&gt; Single track
        // format 1 -&gt; One or more simultaneous tracks
        // format 2 -&gt; One or more independent tracks
        //
        // division notes
        // ------------------------------------------------------------
        // For the division value the MSB determines what the division
        // value defines, if the MSB
        outputBuf.putInt32(0x4d546864);
        outputBuf.putInt32(6);
        outputBuf.putInt16(tracks &gt; 1 ? 1 : 0);
        outputBuf.putInt16(tracks);
        outputBuf.putInt16(division);

        // Position the buffer to read the delta lengths
        input.position(deltaTimeOffset);

        // Encode each of the track chunks to the output buffer
        // int32    -&gt; &#39;MTtk&#39;
        // varlen   -&gt; delta_time
        int[] controllers = new int[128];
        controller = 0;

        int channel = 0;
        int key = 0;
        int onVelocity = 0;
        int offVelocity = 0;
        int pitch = 0;
        int channelPressure = 0;
        int keyPressure = 0;

        // Write each of the tracks
        track = 0;
        while(track &lt; tracks) {
            outputBuf.putInt32(0x4d54726b);
            outputBuf.skip(4);                        // Skip writing the length until the end

            int chunkStart = outputBuf.position();
            int type = -1;

            while(true) {
                // Read and put the delta time for the event
                int deltaTime = input.getVariableLength();
                outputBuf.putVariableLength(deltaTime);

                int opcode = input.getUInt8(opcodeOffset++);
                boolean channelUpdated = strict || type != opcode;
                type = opcode &amp; 0xf;

                // Encode an end of track event
                if(opcode == EVENT_END_OF_TRACK) {
                    if(channelUpdated) {
                        outputBuf.putInt8(0xff);
                    }

                    outputBuf.putInt8(TYPE_END_OF_TRACK);                     // Event type
                    outputBuf.putInt8(0);                                     // Length

                    // Encode the length of the track to the buffer and stop parsing the
                    // current track
                    outputBuf.putIntLength(outputBuf.position() - chunkStart);
                    track++;
                    break;
                }

                if(opcode == EVENT_SET_TEMPO) {
                    if(channelUpdated) {
                        outputBuf.putInt8(0xff);
                    }

                    outputBuf.putInt8(TYPE_SET_TEMPO);                    // Type
                    outputBuf.putInt8(3);                                 // Length

                    outputBuf.putInt8(input.getUInt8(tempoSetOffset++));
                    outputBuf.putInt8(input.getUInt8(tempoSetOffset++));
                    outputBuf.putInt8(input.getUInt8(tempoSetOffset++));
                } else {
                    channel ^= opcode &gt;&gt; 4;
                    if(type == EVENT_NOTE_ON) {

                        // Note on
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10010000 + channel);
                        }

                        key += input.getInt8(keyOffset++);
                        onVelocity += input.getInt8(onVelocityOffset++);
                        outputBuf.putInt8(key &amp; 127);
                        outputBuf.putInt8(onVelocity &amp; 127);
                    } else if(type == EVENT_NOTE_OFF) {

                        // Note off
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10000000 + channel);
                        }

                        key += input.getInt8(keyOffset++);
                        offVelocity += input.getInt8(offVelocityOffset++);
                        outputBuf.putInt8(key &amp; 127);
                        outputBuf.putInt8(offVelocity &amp; 127);
                    } else if(type == EVENT_CONTROL_CHANGE) {

                        // Controller change
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10110000 + channel);
                        }

                        controller = controller + input.getInt8(controllerOffset++) &amp; 127;
                        outputBuf.putInt8(controller);

                        byte delta;
                        if(controller != CONTROLLER_BANK_SELECT &amp;&amp; controller != CONTROLLER_BANK_SELECT_LSB) {
                            if(controller == CONTROLLER_MODULATION_WHEEL) {
                                delta = input.getInt8(modulationWheelOffset++);
                            } else if(controller == CONTROLLER_MODULATION_WHEEL_LSB) {
                                delta = input.getInt8(modulationWheelLsbOffset++);
                            } else if(controller == CONTROLLER_CHANNEL_VOLUME) {
                                delta = input.getInt8(channelVolumeOffset++);
                            } else if(controller == CONTROLLER_CHANNEL_VOLUME_LSB) {
                                delta = input.getInt8(channelVolumeLsbOffset++);
                            } else if(controller == CONTROLLER_PAN) {
                                delta = input.getInt8(panOffset++);
                            } else if(controller == CONTROLLER_PAN_LSB) {
                                delta = input.getInt8(panLsbOffset++);
                            } else if(controller == CONTROLLER_NRPN) {
                                delta = input.getInt8(nrpnOffset++);
                            } else if(controller == CONTROLLER_NRPN_LSB) {
                                delta = input.getInt8(nrpnLsbOffset++);
                            } else if(controller == CONTROLLER_RPN) {
                                delta = input.getInt8(rpnOffset++);
                            } else if(controller == CONTROLLER_RPN_LSB) {
                                delta = input.getInt8(rpnLsbOffset++);
                            } else if(controller != CONTROLLER_DAMPER_PEDAL &amp;&amp; controller != CONTROLLER_PORTAMENDO &amp;&amp;
                                    controller != CONTROLLER_ALL_SOUND_OFF &amp;&amp; controller != CONTROLLER_RESET_ALL_CONTROLLERS &amp;&amp;
                                    controller != CONTROLLER_ALL_NOTES_OFF) {
                                delta = input.getInt8(toggleOffset++);
                            } else {
                                delta = input.getInt8(var30++);
                            }
                        } else {
                            delta = input.getInt8(programChangeOffset++);
                        }

                        int value = delta + controllers[controller];
                        controllers[controller] = value;
                        outputBuf.putInt8(value &amp; 127);
                    } else if(type == EVENT_PITCH_BEND) {

                        // Pitch bend change
                        if(channelUpdated) {
                            outputBuf.putInt8(0b11100000 + channel);
                        }

                        pitch += input.getInt8(var45++);
                        pitch += input.getInt8(var33++) &lt;&lt; 7;
                        outputBuf.putInt8(pitch &amp; 127);
                        outputBuf.putInt8(pitch &gt;&gt; 7 &amp; 127);
                    } else if(type == EVENT_CHANNEL_PRESSURE) {

                        // Channel pressure (after touch)
                        if(channelUpdated) {
                            outputBuf.putInt8(0b11010000 + channel);
                        }

                        channelPressure += input.getInt8(channelPressureOffset++);
                        outputBuf.putInt8(channelPressure &amp; 127);
                    } else if(type == EVENT_KEY_PRESSURE) {

                        // Key pressure
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10100000 + channel);
                        }

                        key += input.getInt8(keyOffset++);
                        keyPressure += input.getInt8(keyPressureOffset++);
                        outputBuf.putInt8(key &amp; 127);
                        outputBuf.putInt8(keyPressure &amp; 127);
                    } else {
                        if(type != EVENT_PROGRAM_CHANGE) {
                            throw new RuntimeException(&quot;Unknown event type&quot;);
                        }

                        // Program change
                        if(channelUpdated) {
                            outputBuf.putInt8(0b11000000 + channel);
                        }

                        outputBuf.putInt8(input.getInt8(programChangeOffset++));
                    }
                }
            }
        }
    }
}

[/code]</description>
    
    <lastBuildDate>Tue, 23 Jun 2015 14:59:56 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>RuneTekk 3+ - MIDI Compression Format</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="6" data-topic="551314">
<div class="title">
<div class="quote-controls"></div>
 t4:</div>
<blockquote>
<p>use a switch</p>
</blockquote>
</aside>
<p>o k</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/7</link>
        <pubDate>Tue, 23 Jun 2015 14:59:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551314-7</guid>
        <source url="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss">RuneTekk 3+ - MIDI Compression Format</source>
      </item>
      <item>
        <title>RuneTekk 3+ - MIDI Compression Format</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>use a switch</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/6</link>
        <pubDate>Sat, 13 Jun 2015 00:09:35 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551314-6</guid>
        <source url="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss">RuneTekk 3+ - MIDI Compression Format</source>
      </item>
      <item>
        <title>RuneTekk 3+ - MIDI Compression Format</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p>ok?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/5</link>
        <pubDate>Tue, 09 Jun 2015 10:57:27 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551314-5</guid>
        <source url="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss">RuneTekk 3+ - MIDI Compression Format</source>
      </item>
      <item>
        <title>RuneTekk 3+ - MIDI Compression Format</title>
        <dc:creator><![CDATA[@nwe_luigi2 nwe luigi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/nwe_luigi2">@nwe_luigi2</a> wrote:</p>
          <blockquote>
              <p>Also your dump is incomplete</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/4</link>
        <pubDate>Tue, 09 Jun 2015 10:50:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551314-4</guid>
        <source url="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss">RuneTekk 3+ - MIDI Compression Format</source>
      </item>
      <item>
        <title>RuneTekk 3+ - MIDI Compression Format</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="2" data-topic="551314">
<div class="title">
<div class="quote-controls"></div>
 nwe luigi2:</div>
<blockquote>
<p>I thought they used OGG for all runetek 3+ engines? Since that stores the instruments used inside the file</p>
</blockquote>
</aside>
<p>RT5+, maybe late RT4</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/3</link>
        <pubDate>Mon, 08 Jun 2015 23:05:37 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551314-3</guid>
        <source url="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss">RuneTekk 3+ - MIDI Compression Format</source>
      </item>
      <item>
        <title>RuneTekk 3+ - MIDI Compression Format</title>
        <dc:creator><![CDATA[@nwe_luigi2 nwe luigi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/nwe_luigi2">@nwe_luigi2</a> wrote:</p>
          <blockquote>
              <p>I thought they used OGG for all runetek 3+ engines? Since that stores the instruments used inside the file</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/2</link>
        <pubDate>Mon, 08 Jun 2015 22:48:11 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551314-2</guid>
        <source url="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss">RuneTekk 3+ - MIDI Compression Format</source>
      </item>
      <item>
        <title>RuneTekk 3+ - MIDI Compression Format</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p>This is a refactor of the jagex midi compression format. Strict encoding is required for most media players.</p>
<pre><code class="lang-auto">package com.jagex;

import com.jagex.io.Buffer;

/**
 * Created by hadyn on 5/1/2015.
 */
public class MidiCodec {

    private static final int EVENT_NOTE_ON = 0x0;
    private static final int EVENT_NOTE_OFF = 0x1;
    private static final int EVENT_CONTROL_CHANGE = 0x2;
    private static final int EVENT_PITCH_BEND = 0x3;
    private static final int EVENT_CHANNEL_PRESSURE = 0x4;
    private static final int EVENT_KEY_PRESSURE = 0x5;
    private static final int EVENT_PROGRAM_CHANGE = 0x6;
    private static final int EVENT_END_OF_TRACK = 0x07;
    private static final int EVENT_SET_TEMPO = 0x17;

    private static final int CONTROLLER_BANK_SELECT = 0;
    private static final int CONTROLLER_BANK_SELECT_LSB = 32;
    private static final int CONTROLLER_MODULATION_WHEEL = 1;
    private static final int CONTROLLER_MODULATION_WHEEL_LSB = 33;
    private static final int CONTROLLER_CHANNEL_VOLUME = 7;
    private static final int CONTROLLER_CHANNEL_VOLUME_LSB = 39;
    private static final int CONTROLLER_PAN = 10;
    private static final int CONTROLLER_PAN_LSB = 42;
    private static final int CONTROLLER_NRPN = 99;
    private static final int CONTROLLER_NRPN_LSB = 98;
    private static final int CONTROLLER_RPN = 101;
    private static final int CONTROLLER_RPN_LSB = 100;
    private static final int CONTROLLER_DAMPER_PEDAL = 64;
    private static final int CONTROLLER_PORTAMENDO = 65;
    private static final int CONTROLLER_ALL_SOUND_OFF = 120;
    private static final int CONTROLLER_RESET_ALL_CONTROLLERS = 121;
    private static final int CONTROLLER_ALL_NOTES_OFF = 123;

    private static final int TYPE_END_OF_TRACK = 0x2f;
    private static final int TYPE_SET_TEMPO = 0x51;

    byte[] data;

    public MidiCodec() {}

    void parse(Buffer input, boolean strict) {

        // Read the footer which contains the amount
        // of track and
        input.position(input.capacity() - 3);
        int tracks = input.getUInt8();
        int division = input.getUInt16();

        int length = 14 + tracks * 10;
        input.position(0);

        int tempoCount = 0;
        int controlChangeCount = 0;
        int noteOnCount = 0;
        int noteOffCount = 0;
        int pitchBendCount = 0;
        int channelPressureCount = 0;
        int keyPressureCount = 0;
        int programChangeCount = 0;

        // Parse and count each of the event opcodes
        int i;
        int j;
        int track = 0;
        while(track &lt; tracks) {
            i = -1;
            while(true) {
                j = input.getUInt8();

                if(strict || i != j) {
                    ++length;
                }

                i = j &amp; 0xf;
                if(j == EVENT_END_OF_TRACK) {
                    ++track;
                    break;
                }

                if(j == EVENT_SET_TEMPO) {
                    ++tempoCount;
                } else if(i == EVENT_NOTE_ON) {
                    ++noteOnCount;
                } else if(i == EVENT_NOTE_OFF) {
                    ++noteOffCount;
                } else if(i == EVENT_CONTROL_CHANGE) {
                    ++controlChangeCount;
                } else if(i == EVENT_PITCH_BEND) {
                    ++pitchBendCount;
                } else if(i == EVENT_CHANNEL_PRESSURE) {
                    ++channelPressureCount;
                } else if(i == EVENT_KEY_PRESSURE) {
                    ++keyPressureCount;
                } else {
                    if(i != EVENT_PROGRAM_CHANGE) {
                        throw new RuntimeException();
                    }
                    ++programChangeCount;
                }
            }
        }

        // Append the amount of data for each event
        length += 5 * tempoCount;
        length += 2 * (noteOnCount + noteOffCount + controlChangeCount + pitchBendCount + keyPressureCount);
        length += channelPressureCount + programChangeCount;

        // TODO: Eventually remove this shit
        int deltaTimeOffset = input.position();

        // Parse the delta time for each event
        int deltaTimeStart = input.position();
        int eventCount = tracks + tempoCount + controlChangeCount + noteOnCount +
                noteOffCount + pitchBendCount + channelPressureCount +
                keyPressureCount + programChangeCount;
        for(int l = 0; l &lt; eventCount; l++) {
            input.getVariableLength();
        }

        // Append the data length of the event delta times
        // to the length of the decompressed output
        length += input.position() - deltaTimeStart;

        // Mark where the controller data begins
        int controllerOffset = input.position();

        // Count each of the controller changes
        int modulationWheelCount = 0;
        int modulationWheelMsbCount = 0;
        int channelVolumeCount = 0;
        int channelVolumeLsbCount = 0;
        int panCount = 0;
        int panLsbCount = 0;
        int nrpnCount = 0;
        int nrpnLsbCount = 0;
        int rpnCount = 0;
        int rpnLsbCount = 0;
        int var26 = 0;
        int toggleCount = 0;
        int controller = 0;

        for(int k = 0; k &lt; controlChangeCount; k++) {
            controller = controller + input.getUInt8() &amp; 127;
            if(controller != CONTROLLER_BANK_SELECT &amp;&amp; controller != CONTROLLER_BANK_SELECT_LSB) {
                if(controller == CONTROLLER_MODULATION_WHEEL) {
                    ++modulationWheelCount;
                } else if(controller == CONTROLLER_MODULATION_WHEEL_LSB) {
                    ++modulationWheelMsbCount;
                } else if(controller == CONTROLLER_CHANNEL_VOLUME) {
                    ++channelVolumeCount;
                } else if(controller == CONTROLLER_CHANNEL_VOLUME_LSB) {
                    ++channelVolumeLsbCount;
                } else if(controller == CONTROLLER_PAN) {
                    ++panCount;
                } else if(controller == CONTROLLER_PAN_LSB) {
                    ++panLsbCount;
                } else if(controller == CONTROLLER_NRPN) {
                    ++nrpnCount;
                } else if(controller == CONTROLLER_NRPN_LSB) {
                    ++nrpnLsbCount;
                } else if(controller == CONTROLLER_RPN) {
                    ++rpnCount;
                } else if(controller == CONTROLLER_RPN_LSB) {
                    ++rpnLsbCount;
                } else if(controller != CONTROLLER_DAMPER_PEDAL &amp;&amp; controller != CONTROLLER_PORTAMENDO &amp;&amp;
                        controller != CONTROLLER_ALL_SOUND_OFF &amp;&amp; controller != CONTROLLER_RESET_ALL_CONTROLLERS &amp;&amp;
                        controller != CONTROLLER_ALL_NOTES_OFF) {
                    ++toggleCount;
                } else {
                    ++var26;
                }
            } else {
                ++programChangeCount;
            }
        }

        // Calculate each of the offsets for all of the data to encode
        // the midi file with.
        int opcodeOffset = 0;

        int var30 = input.position();
        input.skip(var26);

        int keyPressureOffset = input.position();
        input.skip(keyPressureCount);

        int channelPressureOffset = input.position();
        input.skip(channelPressureCount);

        int var33 = input.position();
        input.skip(pitchBendCount);

        int modulationWheelOffset = input.position();
        input.skip(modulationWheelCount);

        int channelVolumeOffset = input.position();
        input.skip(channelVolumeCount);

        int panOffset = input.position();
        input.skip(panCount);

        int keyOffset = input.position();
        input.skip(noteOnCount + noteOffCount + keyPressureCount);

        int onVelocityOffset = input.position();
        input.skip(noteOnCount);

        int toggleOffset = input.position();
        input.skip(toggleCount);

        int offVelocityOffset = input.position();
        input.skip(noteOffCount);

        int modulationWheelLsbOffset = input.position();
        input.skip(modulationWheelMsbCount);

        int channelVolumeLsbOffset = input.position();
        input.skip(channelVolumeLsbCount);

        int panLsbOffset = input.position();
        input.skip(panLsbCount);

        int programChangeOffset = input.position();
        input.skip(programChangeCount);

        int var45 = input.position();
        input.skip(pitchBendCount);

        int nrpnOffset = input.position();
        input.skip(nrpnCount);

        int nrpnLsbOffset = input.position();
        input.skip(nrpnLsbCount);

        int rpnOffset = input.position();
        input.skip(rpnCount);

        int rpnLsbOffset = input.position();
        input.skip(rpnLsbCount);

        int tempoSetOffset = input.position();
        input.skip(tempoCount * 3);

        // Create a buffer to put the encoded midi file
        data = new byte[length];

        Buffer outputBuf = new Buffer(data);

        // Encode the header chunk to the output buffer, big endian
        // 0:   int32 -&gt; 'MThd'
        // 4:   int32 -&gt; chunk_len
        // 8:   int16 -&gt; format
        // 10:  int16 -&gt; tracks
        // 12:  int16 -&gt; division
        //
        // format notes
        // ------------------------------------------------------------
        // format 0 -&gt; Single track
        // format 1 -&gt; One or more simultaneous tracks
        // format 2 -&gt; One or more independent tracks
        //
        // division notes
        // ------------------------------------------------------------
        // For the division value the MSB determines what the division
        // value defines, if the MSB
        outputBuf.putInt32(0x4d546864);
        outputBuf.putInt32(6);
        outputBuf.putInt16(tracks &gt; 1 ? 1 : 0);
        outputBuf.putInt16(tracks);
        outputBuf.putInt16(division);

        // Position the buffer to read the delta lengths
        input.position(deltaTimeOffset);

        // Encode each of the track chunks to the output buffer
        // int32    -&gt; 'MTtk'
        // varlen   -&gt; delta_time
        int[] controllers = new int[128];
        controller = 0;

        int channel = 0;
        int key = 0;
        int onVelocity = 0;
        int offVelocity = 0;
        int pitch = 0;
        int channelPressure = 0;
        int keyPressure = 0;

        // Write each of the tracks
        track = 0;
        while(track &lt; tracks) {
            outputBuf.putInt32(0x4d54726b);
            outputBuf.skip(4);                        // Skip writing the length until the end

            int chunkStart = outputBuf.position();
            int type = -1;

            while(true) {
                // Read and put the delta time for the event
                int deltaTime = input.getVariableLength();
                outputBuf.putVariableLength(deltaTime);

                int opcode = input.getUInt8(opcodeOffset++);
                boolean channelUpdated = strict || type != opcode;
                type = opcode &amp; 0xf;

                // Encode an end of track event
                if(opcode == EVENT_END_OF_TRACK) {
                    if(channelUpdated) {
                        outputBuf.putInt8(0xff);
                    }

                    outputBuf.putInt8(TYPE_END_OF_TRACK);                     // Event type
                    outputBuf.putInt8(0);                                     // Length

                    // Encode the length of the track to the buffer and stop parsing the
                    // current track
                    outputBuf.putIntLength(outputBuf.position() - chunkStart);
                    track++;
                    break;
                }

                if(opcode == EVENT_SET_TEMPO) {
                    if(channelUpdated) {
                        outputBuf.putInt8(0xff);
                    }

                    outputBuf.putInt8(TYPE_SET_TEMPO);                    // Type
                    outputBuf.putInt8(3);                                 // Length

                    outputBuf.putInt8(input.getUInt8(tempoSetOffset++));
                    outputBuf.putInt8(input.getUInt8(tempoSetOffset++));
                    outputBuf.putInt8(input.getUInt8(tempoSetOffset++));
                } else {
                    channel ^= opcode &gt;&gt; 4;
                    if(type == EVENT_NOTE_ON) {

                        // Note on
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10010000 + channel);
                        }

                        key += input.getInt8(keyOffset++);
                        onVelocity += input.getInt8(onVelocityOffset++);
                        outputBuf.putInt8(key &amp; 127);
                        outputBuf.putInt8(onVelocity &amp; 127);
                    } else if(type == EVENT_NOTE_OFF) {

                        // Note off
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10000000 + channel);
                        }

                        key += input.getInt8(keyOffset++);
                        offVelocity += input.getInt8(offVelocityOffset++);
                        outputBuf.putInt8(key &amp; 127);
                        outputBuf.putInt8(offVelocity &amp; 127);
                    } else if(type == EVENT_CONTROL_CHANGE) {

                        // Controller change
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10110000 + channel);
                        }

                        controller = controller + input.getInt8(controllerOffset++) &amp; 127;
                        outputBuf.putInt8(controller);

                        byte delta;
                        if(controller != CONTROLLER_BANK_SELECT &amp;&amp; controller != CONTROLLER_BANK_SELECT_LSB) {
                            if(controller == CONTROLLER_MODULATION_WHEEL) {
                                delta = input.getInt8(modulationWheelOffset++);
                            } else if(controller == CONTROLLER_MODULATION_WHEEL_LSB) {
                                delta = input.getInt8(modulationWheelLsbOffset++);
                            } else if(controller == CONTROLLER_CHANNEL_VOLUME) {
                                delta = input.getInt8(channelVolumeOffset++);
                            } else if(controller == CONTROLLER_CHANNEL_VOLUME_LSB) {
                                delta = input.getInt8(channelVolumeLsbOffset++);
                            } else if(controller == CONTROLLER_PAN) {
                                delta = input.getInt8(panOffset++);
                            } else if(controller == CONTROLLER_PAN_LSB) {
                                delta = input.getInt8(panLsbOffset++);
                            } else if(controller == CONTROLLER_NRPN) {
                                delta = input.getInt8(nrpnOffset++);
                            } else if(controller == CONTROLLER_NRPN_LSB) {
                                delta = input.getInt8(nrpnLsbOffset++);
                            } else if(controller == CONTROLLER_RPN) {
                                delta = input.getInt8(rpnOffset++);
                            } else if(controller == CONTROLLER_RPN_LSB) {
                                delta = input.getInt8(rpnLsbOffset++);
                            } else if(controller != CONTROLLER_DAMPER_PEDAL &amp;&amp; controller != CONTROLLER_PORTAMENDO &amp;&amp;
                                    controller != CONTROLLER_ALL_SOUND_OFF &amp;&amp; controller != CONTROLLER_RESET_ALL_CONTROLLERS &amp;&amp;
                                    controller != CONTROLLER_ALL_NOTES_OFF) {
                                delta = input.getInt8(toggleOffset++);
                            } else {
                                delta = input.getInt8(var30++);
                            }
                        } else {
                            delta = input.getInt8(programChangeOffset++);
                        }

                        int value = delta + controllers[controller];
                        controllers[controller] = value;
                        outputBuf.putInt8(value &amp; 127);
                    } else if(type == EVENT_PITCH_BEND) {

                        // Pitch bend change
                        if(channelUpdated) {
                            outputBuf.putInt8(0b11100000 + channel);
                        }

                        pitch += input.getInt8(var45++);
                        pitch += input.getInt8(var33++) &lt;&lt; 7;
                        outputBuf.putInt8(pitch &amp; 127);
                        outputBuf.putInt8(pitch &gt;&gt; 7 &amp; 127);
                    } else if(type == EVENT_CHANNEL_PRESSURE) {

                        // Channel pressure (after touch)
                        if(channelUpdated) {
                            outputBuf.putInt8(0b11010000 + channel);
                        }

                        channelPressure += input.getInt8(channelPressureOffset++);
                        outputBuf.putInt8(channelPressure &amp; 127);
                    } else if(type == EVENT_KEY_PRESSURE) {

                        // Key pressure
                        if(channelUpdated) {
                            outputBuf.putInt8(0b10100000 + channel);
                        }

                        key += input.getInt8(keyOffset++);
                        keyPressure += input.getInt8(keyPressureOffset++);
                        outputBuf.putInt8(key &amp; 127);
                        outputBuf.putInt8(keyPressure &amp; 127);
                    } else {
                        if(type != EVENT_PROGRAM_CHANGE) {
                            throw new RuntimeException("Unknown event type");
                        }

                        // Program change
                        if(channelUpdated) {
                            outputBuf.putInt8(0b11000000 + channel);
                        }

                        outputBuf.putInt8(input.getInt8(programChangeOffset++));
                    }
                }
            }
        }
    }
}
</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314/1</link>
        <pubDate>Sat, 02 May 2015 09:59:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551314-1</guid>
        <source url="https://forum.moparisthebest.com/t/runetekk-3-midi-compression-format/551314.rss">RuneTekk 3+ - MIDI Compression Format</source>
      </item>
  </channel>
</rss>
