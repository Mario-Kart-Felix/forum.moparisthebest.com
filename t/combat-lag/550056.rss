<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Combat Lag</title>
    <link>https://forum.moparisthebest.com/t/combat-lag/550056</link>
    <description>I hate to ask for help but PI is so poorly written I can&#39;t trace the origin of a nasty combat lag.

#Pic (gif), let it load#
[img]http://azaruth.com/images/clip0010.gif[/img]

As you can see, walking and attack animations are synchronized but the hit update and death animation both lag horribly for the attacker. The solution eludes me... I hope someone here has seen/dealt with this before.

--Requested Files/Methods--
Attack method in CombatAssistant class
[code=java]	public void attackPlayer(int i) {
		if (Server.playerHandler.players[i] != null) {
			if (Server.playerHandler.players[i].isDead) {
				resetPlayerAttack();
				return;
			}
			if (c.curseActive[19]) { // Turmoil
				c.getStr = Server.playerHandler.players[i].playerLevel[2] * 10 / 100;
				c.getDef = Server.playerHandler.players[i].playerLevel[1] * 15 / 100;
				c.getAtt = Server.playerHandler.players[i].playerLevel[0] * 15 / 100;
			} else if (c.curseActive[10]) { // LeechAtt
				c.getAtt = c.playerLevel[0] * c.attInc / 100;
			} else if (c.curseActive[11]) { // Leech Ranged
				c.getRange = c.playerLevel[4] * c.rangeInc / 100;
			} else if (c.curseActive[12]) { // Leech Magic
				c.getMagic = c.playerLevel[6] * c.magicInc / 100;
			} else if (c.curseActive[13]) {// leechDef
				c.getDef = c.playerLevel[1] * c.defInc / 100;
			} else if (c.curseActive[14]) {// LeechStr
				c.getStr = c.playerLevel[2] * c.strInc / 100;
			}
			if (c.respawnTimer &gt; 0
					|| Server.playerHandler.players[i].respawnTimer &gt; 0) {
				resetPlayerAttack();
				return;
			}
			if (!c.getCombat().checkReqs()) {
				return;
			}
			if (c.getPA().getWearingAmount() &lt; 4 &amp;&amp; c.duelStatus &lt; 1) {
				c.sendMessage(&quot;You must be wearing at least 4 items to attack someone.&quot;);
				resetPlayerAttack();
				return;
			}
			boolean sameSpot = c.absX == Server.playerHandler.players[i].getX()
					&amp;&amp; c.absY == Server.playerHandler.players[i].getY();
			if (!c.goodDistance(Server.playerHandler.players[i].getX(),
					Server.playerHandler.players[i].getY(), c.getX(), c.getY(),
					25)
					&amp;&amp; !sameSpot) {
				resetPlayerAttack();
				return;
			}
			if (Server.playerHandler.players[i].respawnTimer &gt; 0) {
				Server.playerHandler.players[i].playerIndex = 0;
				resetPlayerAttack();
				return;
			}

			if (Server.playerHandler.players[i].heightLevel != c.heightLevel) {
				resetPlayerAttack();
				return;
			}
			c.followId = i;
			c.followId2 = 0;
			if (c.attackTimer &lt;= 0) {
				c.usingBow = false;
				c.specEffect = 0;
				c.usingRangeWeapon = false;
				c.rangeItemUsed = 0;
				boolean usingBow = false;
				boolean usingArrows = false;
				boolean usingOtherRangeWeapons = false;
				boolean usingCross = c.playerEquipment[c.playerWeapon] == 9185;
				c.projectileStage = 0;
				if (c.absX == Server.playerHandler.players[i].absX
						&amp;&amp; c.absY == Server.playerHandler.players[i].absY) {
					if (c.freezeTimer &gt; 0) {
						resetPlayerAttack();
						return;
					}
					c.followId = i;
					c.attackTimer = 0;
					return;
				}
				if (!c.usingMagic) {
					for (int bowId : c.BOWS) {
						if (c.playerEquipment[c.playerWeapon] == bowId) {
							usingBow = true;
							for (int arrowId : c.ARROWS) {
								if (c.playerEquipment[c.playerArrows] == arrowId) {
									usingArrows = true;
								}
							}
						}
					}
					for (int otherRangeId : c.OTHER_RANGE_WEAPONS) {
						if (c.playerEquipment[c.playerWeapon] == otherRangeId) {
							usingOtherRangeWeapons = true;
						}
					}
				}
				if (c.autocasting) {
					c.spellId = c.autocastId;
					c.usingMagic = true;
				}
				if (c.spellId &gt; 0) {
					c.usingMagic = true;
				}
				c.attackTimer = getAttackDelay(c.getItems()
						.getItemName(c.playerEquipment[c.playerWeapon])
						.toLowerCase());

				if (c.duelRule[9]) {
					boolean canUseWeapon = false;
					for (int funWeapon : Config.FUN_WEAPONS) {
						if (c.playerEquipment[c.playerWeapon] == funWeapon) {
							canUseWeapon = true;
						}
					}
					if (!canUseWeapon) {
						c.sendMessage(&quot;You can only use fun weapons in this duel!&quot;);
						resetPlayerAttack();
						return;
					}
				}
				if (c.duelRule[2] &amp;&amp; (usingBow || usingOtherRangeWeapons)) {
					c.sendMessage(&quot;Range has been disabled in this duel!&quot;);
					return;
				}
				if (c.duelRule[3]
						&amp;&amp; (!usingBow &amp;&amp; !usingOtherRangeWeapons &amp;&amp; !c.usingMagic)) {
					c.sendMessage(&quot;Melee has been disabled in this duel!&quot;);
					return;
				}
				if (c.duelRule[4] &amp;&amp; c.usingMagic) {
					c.sendMessage(&quot;Magic has been disabled in this duel!&quot;);
					resetPlayerAttack();
					return;
				}
				if (!usingCross
						&amp;&amp; !usingArrows
						&amp;&amp; usingBow
						&amp;&amp; (c.playerEquipment[c.playerWeapon] &lt; 4212 || c.playerEquipment[c.playerWeapon] &gt; 4223)
						&amp;&amp; !c.usingMagic) {
					c.sendMessage(&quot;You have run out of arrows!&quot;);
					c.stopMovement();
					resetPlayerAttack();
					return;
				}
				if (properBolts() &amp;&amp; c.playerEquipment[c.playerWeapon] == 11235) {
					c.sendMessage(&quot;You cannot use bolts with a dark bow.&quot;);
					c.stopMovement();
					resetPlayerAttack();
					return;
				}
				if (correctBowAndArrows() &lt; c.playerEquipment[c.playerArrows]
						&amp;&amp; Config.CORRECT_ARROWS &amp;&amp; usingBow
						&amp;&amp; !usingCrystalBow()
						&amp;&amp; c.playerEquipment[c.playerWeapon] != 9185
						&amp;&amp; !c.usingMagic) {
					String itemA = c.getItems()
							.getItemName(c.playerEquipment[c.playerArrows])
							.toLowerCase();
					String itemB = c.getItems()
							.getItemName(c.playerEquipment[c.playerWeapon])
							.toLowerCase();
					c.sendMessage(&quot;You can&#39;t use &quot; + itemA + &quot;s with a &quot;
							+ itemB + &quot;.&quot;);
					c.stopMovement();
					resetPlayerAttack();
					return;
				}
				if (c.playerEquipment[c.playerWeapon] == 9185 &amp;&amp; !properBolts()
						&amp;&amp; !c.usingMagic) {
					c.sendMessage(&quot;You must use bolts with a crossbow.&quot;);
					c.stopMovement();
					resetPlayerAttack();
					return;
				}
				if (c.playerEquipment[c.playerWeapon] == 15241
						&amp;&amp; c.playerEquipment[c.playerArrows] != 15243) {
					c.sendMessage(&quot;You can&#39;t use Hand Cannon without cannon shots!&quot;);
					c.stopMovement();
					resetPlayerAttack();
					return;
				}
				if (c.playerEquipment[c.playerWeapon] == 15241) {
					c.gfx0(2138);
				}
				if (usingBow || c.usingMagic || usingOtherRangeWeapons
						|| usingHally()) {
					c.stopMovement();
				}
				if (!checkMagicReqs(c.spellId)) {
					c.stopMovement();
					resetPlayerAttack();
					return;
				}
				c.faceUpdate(i + 32768);
				if (c.duelStatus != 5) {
					if (!c.inBountyHunterCombat()
							&amp;&amp; !c.attackedPlayers.contains(c.playerIndex)
							&amp;&amp; !Server.playerHandler.players[c.playerIndex].attackedPlayers
									.contains(c.playerId)) {
						c.attackedPlayers.add(c.playerIndex);
						c.isSkulled = true;
						c.skullTimer = Config.SKULL_TIMER;
						c.headIconPk = 0;
						c.getPA().requestUpdates();
					}
				}
				c.specAccuracy = 1.0;
				c.specDamage = 1.0;
				c.delayedDamage = c.delayedDamage2 = 0;
				if (c.usingSpecial &amp;&amp; !c.usingMagic) {
					if (c.duelRule[10] &amp;&amp; c.duelStatus == 5) {
						c.sendMessage(&quot;Special attacks have been disabled during this duel!&quot;);
						c.usingSpecial = false;
						c.getItems().updateSpecialBar();
						resetPlayerAttack();
						return;
					}
					if (checkSpecAmount(c.playerEquipment[c.playerWeapon])) {
						c.lastArrowUsed = c.playerEquipment[c.playerArrows];
						activateSpecial(c.playerEquipment[c.playerWeapon], i);
						c.followId = c.playerIndex;
						return;
					} else {
						c.sendMessage(&quot;You don&#39;t have the required special energy to use this attack.&quot;);
						c.usingSpecial = false;
						c.getItems().updateSpecialBar();
						c.playerIndex = 0;
						return;
					}
				}
				if (!c.usingMagic) {
					c.startAnimation(getWepAnim(c.getItems()
							.getItemName(c.playerEquipment[c.playerWeapon])
							.toLowerCase()));
					c.mageFollow = false;
				} else {
					c.startAnimation(c.MAGIC_SPELLS[c.spellId][2]);
					c.mageFollow = true;
					c.followId = c.playerIndex;
				}
				if (c.coolDown == 0 &amp;&amp; c.inWild() == false) {
					resetPlayerAttack();
					return;
				}
				if (Server.playerHandler.players[i].coolDown == 0
						&amp;&amp; Server.playerHandler.players[i].world == 2)
					Server.playerHandler.players[i].coolDown = 10;
		[/code]

Death event in PlayerAssistant class
[code=java]
	/**
	 * Dieing
	 **/
	public void applyDead() {
		c.respawnTimer = 10;
		c.isDead = false;
		if (c.curseActive[17]) {
			applyWrath();
		}
		if (c.prayerActive[21])
			applyRetribution();
		if (!c.eaten)
			c.startAnimation(2304);
		else
			c.startAnimation(837);
		int weapon = c.playerEquipment[c.playerWeapon];
		if (c.duelStatus != 6) {
			// c.killerId = c.getCombat().getKillerId(c.playerId);
			c.killerId = findKiller();
			Client o = (Client) Server.playerHandler.players[c.killerId];
			for(int x = 0; x &lt; 8; x++){
				if(o.pkReqs[x] == o.pks){
					//o.sendMessage(&quot;Gratz! You&#39;ve completed pk task! :)&quot;);
					c.refleshTasks();
				}
			}
			if (o != null) {
				if (!(c.npcIndex &gt; 0)) {
				}
				if (c.killerId != c.playerId) {
					o.sendMessage(&quot;You have defeated &quot;
							+ Misc.optimizeText(c.playerName) + &quot;!&quot;);
				}
				//if (c.killerId != c.playerId &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk())
				//	c.logKill(o.playerName, c.playerName, o.pkPoints);
				if (c.killerId != c.playerId &amp;&amp; ((o.playerRights &gt; 0 &amp;&amp; o.playerRights &lt; 4) || (c.playerRights &gt; 0 &amp;&amp; c.playerRights &lt; 4))  &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk()) {
					String data = Misc.optimizeText(o.playerName) + &quot; killed &quot; + Misc.optimizeText(c.playerName);
					c.log.writeLog(&quot;staffKills&quot;, data);
				}
				if ((c.inWild() &amp;&amp; !c.inFunPk()) || c.world == 2) {
					if (c == o)
						return;
					if (o.lastKilled.equalsIgnoreCase(c.playerName)) {
						o.sendMessage(&quot;You have killed &quot; + Misc.optimizeText(c.playerName) + &quot; twice in a row and recieve no Pk Points.&quot;);
					} else {
				//		if (Misc.random(500) &gt; 400) {
					o.pkPoints += 1;
					if (o.world == 2)
						o.pkPoints += 50;
					o.sendMessage(&quot;You have now have &quot; + o.pkPoints + &quot; PK Points.&quot;);
					o.lastKilled = c.playerName;
			//		}
					}
					o.getPA().sendFrame126(&quot;PkPts: &quot; + o.pkPoints, 29169);
				}
				if (c.killerId != c.playerId &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk())
					c.logKill(o.playerName, c.playerName, o.pkPoints, c.world);
				if (c.inClanWars()) {
					ClanWars.killedSomeone();
				}
				if (weapon == CastleWars.SARA_BANNER
						|| weapon == CastleWars.ZAMMY_BANNER) {
					c.getItems().removeItem(weapon, 3);
					c.getItems().deleteItem2(weapon, 1);
					CastleWars.dropFlag(c, weapon);
				}
				c.playerKilled = c.playerId;
				if (o.duelStatus == 5) {
					o.duelStatus++;
				}
			}
		}
		c.poisonDamage = 0;
		c.faceUpdate(0);
		EventManager.getSingleton().addEvent(new Event() {
			public void execute(EventContainer b) {
				c.npcIndex = 0;
				c.playerIndex = 0;
				b.stop();
			}
		}, 2500);
		c.stopMovement();
		if (c.duelStatus &lt;= 4) {
			Client o = (Client) Server.playerHandler.players[c.killerId];
			c.sendMessage(&quot;Oh dear you are dead!&quot;);
			PlayerSave.saveGame(o);
			PlayerSave.saveGame(c);
		} else if (c.duelStatus != 6) {
			Client o = (Client) Server.playerHandler.players[c.killerId];
			c.sendMessage(&quot;You have lost the duel!&quot;);
			PlayerSave.saveGame(o);
			PlayerSave.saveGame(c);
		}
		
		Client o = (Client) Server.playerHandler.players[c.killerId];
		if(o.leavePenalty &gt; 0) {
			BountyHunter.startLeavePenalty(o);
		} else {
			BountyHunter.startPickupPenalty(o);
		}
		
		resetDamageDone();
		c.specAmount = 10;
		c.getItems().addSpecialBar(c.playerEquipment[c.playerWeapon]);
		c.lastVeng = 0;
		c.vengOn = false;
		resetFollowers();
		c.attackTimer = 10;
		removeAllWindows();
		c.tradeResetNeeded = true;
	}
[/code]

Melee attack from loop in AttackPlayer class
[code=java]/**
			* Attack player
			**/
			case ATTACK_PLAYER:
			c.playerIndex = c.getInStream().readSignedWordBigEndian();
			Client other = (Client) Server.playerHandler.players[c.playerIndex];
			if(Server.playerHandler.players[c.playerIndex] == null ){
				break;
			}
			c.sendMessage(&quot;AttackPlayer:33 find player to begin&quot;);
			if(c.respawnTimer &gt; 0) {
				break;
			}
			
			if (c.autocastId &gt; 0)
				c.autocasting = true;
			
			if (!c.autocasting &amp;&amp; c.spellId &gt; 0) {
				c.spellId = 0;
			}
			c.mageFollow = false;
			c.spellId = 0;
			c.usingMagic = false;
			boolean usingBow = false;
			boolean usingOtherRangeWeapons = false;
			boolean usingArrows = false;
			boolean usingCross = c.playerEquipment[c.playerWeapon] == 9185;
			for (int bowId : c.BOWS) {
				if(c.playerEquipment[c.playerWeapon] == bowId) {
					usingBow = true;
					for (int arrowId : c.ARROWS) {
						if(c.playerEquipment[c.playerArrows] == arrowId) {
							usingArrows = true;
						}
					}
				}
			}
			for (int otherRangeId : c.OTHER_RANGE_WEAPONS) {
				if(c.playerEquipment[c.playerWeapon] == otherRangeId) {
					usingOtherRangeWeapons = true;
				}
			}
			if(c.duelStatus == 5) {	
				if(c.duelCount &gt; 0) {
					c.sendMessage(&quot;The duel hasn&#39;t started yet!&quot;);
					c.playerIndex = 0;
					return;
				}
				if(c.duelRule[9]){
					boolean canUseWeapon = false;
					for(int funWeapon: Config.FUN_WEAPONS) {
						if(c.playerEquipment[c.playerWeapon] == funWeapon) {
							canUseWeapon = true;
						}
					}
					if(!canUseWeapon) {
						c.sendMessage(&quot;You can only use fun weapons in this duel!&quot;);
						return;
					}
				}
				
				if(c.duelRule[2] &amp;&amp; (usingBow || usingOtherRangeWeapons)) {
					c.sendMessage(&quot;Range has been disabled in this duel!&quot;);
					return;
				}
				if(c.duelRule[3] &amp;&amp; (!usingBow &amp;&amp; !usingOtherRangeWeapons)) {
					c.sendMessage(&quot;Melee has been disabled in this duel!&quot;);
					return;
				}
			}
			
			if((usingBow || c.autocasting) &amp;&amp; c.goodDistance(c.getX(), c.getY(), Server.playerHandler.players[c.playerIndex].getX(), Server.playerHandler.players[c.playerIndex].getY(), 6)) {
				c.usingBow = true;
				c.stopMovement();
			}
			
			if(usingOtherRangeWeapons &amp;&amp; c.goodDistance(c.getX(), c.getY(), Server.playerHandler.players[c.playerIndex].getX(), Server.playerHandler.players[c.playerIndex].getY(), 3)) {
				c.usingRangeWeapon = true;
				c.stopMovement();
			}
			if (!usingBow)
				c.usingBow = false;
			if (!usingOtherRangeWeapons)
				c.usingRangeWeapon = false;

			if(!usingCross &amp;&amp; !usingArrows &amp;&amp; usingBow &amp;&amp; c.playerEquipment[c.playerWeapon] &lt; 4212 &amp;&amp; c.playerEquipment[c.playerWeapon] &gt; 4223) {
				c.sendMessage(&quot;You have run out of arrows!&quot;);
				return;
			} 
			if(c.getCombat().correctBowAndArrows() &lt; c.playerEquipment[c.playerArrows] &amp;&amp; Config.CORRECT_ARROWS &amp;&amp; usingBow &amp;&amp; !c.getCombat().usingCrystalBow() &amp;&amp; c.playerEquipment[c.playerWeapon] != 9185) {
					c.sendMessage(&quot;You can&#39;t use &quot;+c.getItems().getItemName(c.playerEquipment[c.playerArrows]).toLowerCase()+&quot;s with a &quot;+c.getItems().getItemName(c.playerEquipment[c.playerWeapon]).toLowerCase()+&quot;.&quot;);
					c.stopMovement();
					c.getCombat().resetPlayerAttack();
					return;
			}
			if (c.playerEquipment[c.playerWeapon] == 9185 &amp;&amp; !c.getCombat().properBolts()) {
					c.sendMessage(&quot;You must use bolts with a crossbow.&quot;);
					c.stopMovement();
					c.getCombat().resetPlayerAttack();
					return;				
			}
			if (c.getCombat().checkReqs()) {
				c.sendMessage(&quot;AttackPlayer:123 requirements:&quot; + c.getCombat().checkReqs());
				c.followId = c.playerIndex;
				if (!c.usingMagic &amp;&amp; !usingBow &amp;&amp; !usingOtherRangeWeapons) {
					c.followDistance = 1;
					c.getPA().followPlayer();
				}	
				if (c.attackTimer &lt;= 0) {
					//c.sendMessage(&quot;Tried to attack...&quot;);
					//c.getCombat().attackPlayer(c.playerIndex);
					//c.attackTimer++;
				}	
			}
			break;[/code]</description>
    
    <lastBuildDate>Sun, 08 Mar 2015 04:46:13 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/combat-lag/550056.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@deathschaos9 DeathsChaos9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/deathschaos9">@deathschaos9</a> wrote:</p>
          <blockquote>
              <p>I’ve found nothing to explain the delay in updating. The “applyDead” method that’s generically used when someone is killed handles the death animation and also sends a message to the killer; “You have slain …”. The message sends with perfect timing, the animation is still delayed on the killers client.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/10</link>
        <pubDate>Sun, 08 Mar 2015 04:46:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-10</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@sk8rdude461 sk8rdude461]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sk8rdude461">@sk8rdude461</a> wrote:</p>
          <blockquote>
              <p>I’m not seeing the code that actually processes the attack in the CombatAssistant code.<br>
Is there something missing from that code you provided? Because it seems to cut off.</p>
<p>Look in your entire project for the variable attackTimer, see if that is used in something like process() of client.java, if it is, trace it to see what the value is for each player while in combat.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/9</link>
        <pubDate>Fri, 06 Mar 2015 09:04:57 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-9</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@deathschaos9 DeathsChaos9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/deathschaos9">@deathschaos9</a> wrote:</p>
          <blockquote>
              <p>I’ve come up empty handed. Anyone?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/8</link>
        <pubDate>Fri, 06 Mar 2015 05:37:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-8</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@deathschaos9 DeathsChaos9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/deathschaos9">@deathschaos9</a> wrote:</p>
          <blockquote>
              <p>That’s what I deduced but nothing I do fixes it. I see nothing that would indicate everyone except the attacker gets updated.</p>
<p>In the meantime I’ll start writing debugging statements during certain events to see whats happening when.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/7</link>
        <pubDate>Sun, 22 Feb 2015 04:13:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-7</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@Clawz_fury lare69]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/clawz_fury">@Clawz_fury</a> wrote:</p>
          <blockquote>
              <p>maybe it’s an issue with the update blocks and not the actual combat process?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/6</link>
        <pubDate>Sun, 22 Feb 2015 03:49:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-6</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@deathschaos9 DeathsChaos9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/deathschaos9">@deathschaos9</a> wrote:</p>
          <blockquote>
              <p>Attack method in CombatAssistance class</p>
<p>[code=java]	public void attackPlayer(int i) {<br>
if (Server.playerHandler.players[i] != null) {<br>
if (Server.playerHandler.players[i].isDead) {<br>
resetPlayerAttack();<br>
return;<br>
}<br>
if (c.curseActive[19]) { // Turmoil<br>
c.getStr = Server.playerHandler.players[i].playerLevel[2] * 10 / 100;<br>
c.getDef = Server.playerHandler.players[i].playerLevel[1] * 15 / 100;<br>
c.getAtt = Server.playerHandler.players[i].playerLevel[0] * 15 / 100;<br>
} else if (c.curseActive[10]) { // LeechAtt<br>
c.getAtt = c.playerLevel[0] * c.attInc / 100;<br>
} else if (c.curseActive[11]) { // Leech Ranged<br>
c.getRange = c.playerLevel[4] * c.rangeInc / 100;<br>
} else if (c.curseActive[12]) { // Leech Magic<br>
c.getMagic = c.playerLevel[6] * c.magicInc / 100;<br>
} else if (c.curseActive[13]) {// leechDef<br>
c.getDef = c.playerLevel[1] * c.defInc / 100;<br>
} else if (c.curseActive[14]) {// LeechStr<br>
c.getStr = c.playerLevel[2] * c.strInc / 100;<br>
}<br>
if (c.respawnTimer &gt; 0<br>
|| Server.playerHandler.players[i].respawnTimer &gt; 0) {<br>
resetPlayerAttack();<br>
return;<br>
}<br>
if (!c.getCombat().checkReqs()) {<br>
return;<br>
}<br>
if (c.getPA().getWearingAmount() &lt; 4 &amp;&amp; c.duelStatus &lt; 1) {<br>
c.sendMessage(“You must be wearing at least 4 items to attack someone.”);<br>
resetPlayerAttack();<br>
return;<br>
}<br>
boolean sameSpot = c.absX == Server.playerHandler.players[i].getX()<br>
&amp;&amp; c.absY == Server.playerHandler.players[i].getY();<br>
if (!c.goodDistance(Server.playerHandler.players[i].getX(),<br>
Server.playerHandler.players[i].getY(), c.getX(), c.getY(),<br>
25)<br>
&amp;&amp; !sameSpot) {<br>
resetPlayerAttack();<br>
return;<br>
}<br>
if (Server.playerHandler.players[i].respawnTimer &gt; 0) {<br>
Server.playerHandler.players[i].playerIndex = 0;<br>
resetPlayerAttack();<br>
return;<br>
}</p>
<pre><code>		if (Server.playerHandler.players[i].heightLevel != c.heightLevel) {
			resetPlayerAttack();
			return;
		}
		c.followId = i;
		c.followId2 = 0;
		if (c.attackTimer &lt;= 0) {
			c.usingBow = false;
			c.specEffect = 0;
			c.usingRangeWeapon = false;
			c.rangeItemUsed = 0;
			boolean usingBow = false;
			boolean usingArrows = false;
			boolean usingOtherRangeWeapons = false;
			boolean usingCross = c.playerEquipment[c.playerWeapon] == 9185;
			c.projectileStage = 0;
			if (c.absX == Server.playerHandler.players[i].absX
					&amp;&amp; c.absY == Server.playerHandler.players[i].absY) {
				if (c.freezeTimer &gt; 0) {
					resetPlayerAttack();
					return;
				}
				c.followId = i;
				c.attackTimer = 0;
				return;
			}
			if (!c.usingMagic) {
				for (int bowId : c.BOWS) {
					if (c.playerEquipment[c.playerWeapon] == bowId) {
						usingBow = true;
						for (int arrowId : c.ARROWS) {
							if (c.playerEquipment[c.playerArrows] == arrowId) {
								usingArrows = true;
							}
						}
					}
				}
				for (int otherRangeId : c.OTHER_RANGE_WEAPONS) {
					if (c.playerEquipment[c.playerWeapon] == otherRangeId) {
						usingOtherRangeWeapons = true;
					}
				}
			}
			if (c.autocasting) {
				c.spellId = c.autocastId;
				c.usingMagic = true;
			}
			if (c.spellId &gt; 0) {
				c.usingMagic = true;
			}
			c.attackTimer = getAttackDelay(c.getItems()
					.getItemName(c.playerEquipment[c.playerWeapon])
					.toLowerCase());

			if (c.duelRule[9]) {
				boolean canUseWeapon = false;
				for (int funWeapon : Config.FUN_WEAPONS) {
					if (c.playerEquipment[c.playerWeapon] == funWeapon) {
						canUseWeapon = true;
					}
				}
				if (!canUseWeapon) {
					c.sendMessage("You can only use fun weapons in this duel!");
					resetPlayerAttack();
					return;
				}
			}
			if (c.duelRule[2] &amp;&amp; (usingBow || usingOtherRangeWeapons)) {
				c.sendMessage("Range has been disabled in this duel!");
				return;
			}
			if (c.duelRule[3]
					&amp;&amp; (!usingBow &amp;&amp; !usingOtherRangeWeapons &amp;&amp; !c.usingMagic)) {
				c.sendMessage("Melee has been disabled in this duel!");
				return;
			}
			if (c.duelRule[4] &amp;&amp; c.usingMagic) {
				c.sendMessage("Magic has been disabled in this duel!");
				resetPlayerAttack();
				return;
			}
			if (!usingCross
					&amp;&amp; !usingArrows
					&amp;&amp; usingBow
					&amp;&amp; (c.playerEquipment[c.playerWeapon] &lt; 4212 || c.playerEquipment[c.playerWeapon] &gt; 4223)
					&amp;&amp; !c.usingMagic) {
				c.sendMessage("You have run out of arrows!");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (properBolts() &amp;&amp; c.playerEquipment[c.playerWeapon] == 11235) {
				c.sendMessage("You cannot use bolts with a dark bow.");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (correctBowAndArrows() &lt; c.playerEquipment[c.playerArrows]
					&amp;&amp; Config.CORRECT_ARROWS &amp;&amp; usingBow
					&amp;&amp; !usingCrystalBow()
					&amp;&amp; c.playerEquipment[c.playerWeapon] != 9185
					&amp;&amp; !c.usingMagic) {
				String itemA = c.getItems()
						.getItemName(c.playerEquipment[c.playerArrows])
						.toLowerCase();
				String itemB = c.getItems()
						.getItemName(c.playerEquipment[c.playerWeapon])
						.toLowerCase();
				c.sendMessage("You can't use " + itemA + "s with a "
						+ itemB + ".");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (c.playerEquipment[c.playerWeapon] == 9185 &amp;&amp; !properBolts()
					&amp;&amp; !c.usingMagic) {
				c.sendMessage("You must use bolts with a crossbow.");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (c.playerEquipment[c.playerWeapon] == 15241
					&amp;&amp; c.playerEquipment[c.playerArrows] != 15243) {
				c.sendMessage("You can't use Hand Cannon without cannon shots!");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (c.playerEquipment[c.playerWeapon] == 15241) {
				c.gfx0(2138);
			}
			if (usingBow || c.usingMagic || usingOtherRangeWeapons
					|| usingHally()) {
				c.stopMovement();
			}
			if (!checkMagicReqs(c.spellId)) {
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			c.faceUpdate(i + 32768);
			if (c.duelStatus != 5) {
				if (!c.inBountyHunterCombat()
						&amp;&amp; !c.attackedPlayers.contains(c.playerIndex)
						&amp;&amp; !Server.playerHandler.players[c.playerIndex].attackedPlayers
								.contains(c.playerId)) {
					c.attackedPlayers.add(c.playerIndex);
					c.isSkulled = true;
					c.skullTimer = Config.SKULL_TIMER;
					c.headIconPk = 0;
					c.getPA().requestUpdates();
				}
			}
			c.specAccuracy = 1.0;
			c.specDamage = 1.0;
			c.delayedDamage = c.delayedDamage2 = 0;
			if (c.usingSpecial &amp;&amp; !c.usingMagic) {
				if (c.duelRule[10] &amp;&amp; c.duelStatus == 5) {
					c.sendMessage("Special attacks have been disabled during this duel!");
					c.usingSpecial = false;
					c.getItems().updateSpecialBar();
					resetPlayerAttack();
					return;
				}
				if (checkSpecAmount(c.playerEquipment[c.playerWeapon])) {
					c.lastArrowUsed = c.playerEquipment[c.playerArrows];
					activateSpecial(c.playerEquipment[c.playerWeapon], i);
					c.followId = c.playerIndex;
					return;
				} else {
					c.sendMessage("You don't have the required special energy to use this attack.");
					c.usingSpecial = false;
					c.getItems().updateSpecialBar();
					c.playerIndex = 0;
					return;
				}
			}
			if (!c.usingMagic) {
				c.startAnimation(getWepAnim(c.getItems()
						.getItemName(c.playerEquipment[c.playerWeapon])
						.toLowerCase()));
				c.mageFollow = false;
			} else {
				c.startAnimation(c.MAGIC_SPELLS[c.spellId][2]);
				c.mageFollow = true;
				c.followId = c.playerIndex;
			}
			if (c.coolDown == 0 &amp;&amp; c.inWild() == false) {
				resetPlayerAttack();
				return;
			}
			if (Server.playerHandler.players[i].coolDown == 0
					&amp;&amp; Server.playerHandler.players[i].world == 2)
				Server.playerHandler.players[i].coolDown = 10;
	[/code]
</code></pre>
<p>Death event in PlayerAssistant class</p>
<pre><code class="lang-auto">	/**
	 * Dieing
	 **/
	public void applyDead() {
		c.respawnTimer = 10;
		c.isDead = false;
		if (c.curseActive[17]) {
			applyWrath();
		}
		if (c.prayerActive[21])
			applyRetribution();
		if (!c.eaten)
			c.startAnimation(2304);
		else
			c.startAnimation(837);
		int weapon = c.playerEquipment[c.playerWeapon];
		if (c.duelStatus != 6) {
			// c.killerId = c.getCombat().getKillerId(c.playerId);
			c.killerId = findKiller();
			Client o = (Client) Server.playerHandler.players[c.killerId];
			for(int x = 0; x &lt; 8; x++){
				if(o.pkReqs[x] == o.pks){
					//o.sendMessage("Gratz! You've completed pk task! :)");
					c.refleshTasks();
				}
			}
			if (o != null) {
				if (!(c.npcIndex &gt; 0)) {
				}
				if (c.killerId != c.playerId) {
					o.sendMessage("You have defeated "
							+ Misc.optimizeText(c.playerName) + "!");
				}
				//if (c.killerId != c.playerId &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk())
				//	c.logKill(o.playerName, c.playerName, o.pkPoints);
				if (c.killerId != c.playerId &amp;&amp; ((o.playerRights &gt; 0 &amp;&amp; o.playerRights &lt; 4) || (c.playerRights &gt; 0 &amp;&amp; c.playerRights &lt; 4))  &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk()) {
					String data = Misc.optimizeText(o.playerName) + " killed " + Misc.optimizeText(c.playerName);
					c.log.writeLog("staffKills", data);
				}
				if ((c.inWild() &amp;&amp; !c.inFunPk()) || c.world == 2) {
					if (c == o)
						return;
					if (o.lastKilled.equalsIgnoreCase(c.playerName)) {
						o.sendMessage("You have killed " + Misc.optimizeText(c.playerName) + " twice in a row and recieve no Pk Points.");
					} else {
				//		if (Misc.random(500) &gt; 400) {
					o.pkPoints += 1;
					if (o.world == 2)
						o.pkPoints += 50;
					o.sendMessage("You have now have " + o.pkPoints + " PK Points.");
					o.lastKilled = c.playerName;
			//		}
					}
					o.getPA().sendFrame126("PkPts: " + o.pkPoints, 29169);
				}
				if (c.killerId != c.playerId &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk())
					c.logKill(o.playerName, c.playerName, o.pkPoints, c.world);
				if (c.inClanWars()) {
					ClanWars.killedSomeone();
				}
				if (weapon == CastleWars.SARA_BANNER
						|| weapon == CastleWars.ZAMMY_BANNER) {
					c.getItems().removeItem(weapon, 3);
					c.getItems().deleteItem2(weapon, 1);
					CastleWars.dropFlag(c, weapon);
				}
				c.playerKilled = c.playerId;
				if (o.duelStatus == 5) {
					o.duelStatus++;
				}
			}
		}
		c.poisonDamage = 0;
		c.faceUpdate(0);
		EventManager.getSingleton().addEvent(new Event() {
			public void execute(EventContainer b) {
				c.npcIndex = 0;
				c.playerIndex = 0;
				b.stop();
			}
		}, 2500);
		c.stopMovement();
		if (c.duelStatus &lt;= 4) {
			Client o = (Client) Server.playerHandler.players[c.killerId];
			c.sendMessage("Oh dear you are dead!");
			PlayerSave.saveGame(o);
			PlayerSave.saveGame(c);
		} else if (c.duelStatus != 6) {
			Client o = (Client) Server.playerHandler.players[c.killerId];
			c.sendMessage("You have lost the duel!");
			PlayerSave.saveGame(o);
			PlayerSave.saveGame(c);
		}
		
		Client o = (Client) Server.playerHandler.players[c.killerId];
		if(o.leavePenalty &gt; 0) {
			BountyHunter.startLeavePenalty(o);
		} else {
			BountyHunter.startPickupPenalty(o);
		}
		
		resetDamageDone();
		c.specAmount = 10;
		c.getItems().addSpecialBar(c.playerEquipment[c.playerWeapon]);
		c.lastVeng = 0;
		c.vengOn = false;
		resetFollowers();
		c.attackTimer = 10;
		removeAllWindows();
		c.tradeResetNeeded = true;
	}</code></pre>
<p>Melee attack from loop in AttackPlayer class</p>
<p>[code=java]/**<br>
* Attack player<br>
**/<br>
case ATTACK_PLAYER:<br>
c.playerIndex = c.getInStream().readSignedWordBigEndian();<br>
Client other = (Client) Server.playerHandler.players[c.playerIndex];<br>
if(Server.playerHandler.players[c.playerIndex] == null ){<br>
break;<br>
}<br>
c.sendMessage(“AttackPlayer:33 find player to begin”);<br>
if(c.respawnTimer &gt; 0) {<br>
break;<br>
}</p>
<pre><code>		if (c.autocastId &gt; 0)
			c.autocasting = true;
		
		if (!c.autocasting &amp;&amp; c.spellId &gt; 0) {
			c.spellId = 0;
		}
		c.mageFollow = false;
		c.spellId = 0;
		c.usingMagic = false;
		boolean usingBow = false;
		boolean usingOtherRangeWeapons = false;
		boolean usingArrows = false;
		boolean usingCross = c.playerEquipment[c.playerWeapon] == 9185;
		for (int bowId : c.BOWS) {
			if(c.playerEquipment[c.playerWeapon] == bowId) {
				usingBow = true;
				for (int arrowId : c.ARROWS) {
					if(c.playerEquipment[c.playerArrows] == arrowId) {
						usingArrows = true;
					}
				}
			}
		}
		for (int otherRangeId : c.OTHER_RANGE_WEAPONS) {
			if(c.playerEquipment[c.playerWeapon] == otherRangeId) {
				usingOtherRangeWeapons = true;
			}
		}
		if(c.duelStatus == 5) {	
			if(c.duelCount &gt; 0) {
				c.sendMessage("The duel hasn't started yet!");
				c.playerIndex = 0;
				return;
			}
			if(c.duelRule[9]){
				boolean canUseWeapon = false;
				for(int funWeapon: Config.FUN_WEAPONS) {
					if(c.playerEquipment[c.playerWeapon] == funWeapon) {
						canUseWeapon = true;
					}
				}
				if(!canUseWeapon) {
					c.sendMessage("You can only use fun weapons in this duel!");
					return;
				}
			}
			
			if(c.duelRule[2] &amp;&amp; (usingBow || usingOtherRangeWeapons)) {
				c.sendMessage("Range has been disabled in this duel!");
				return;
			}
			if(c.duelRule[3] &amp;&amp; (!usingBow &amp;&amp; !usingOtherRangeWeapons)) {
				c.sendMessage("Melee has been disabled in this duel!");
				return;
			}
		}
		
		if((usingBow || c.autocasting) &amp;&amp; c.goodDistance(c.getX(), c.getY(), Server.playerHandler.players[c.playerIndex].getX(), Server.playerHandler.players[c.playerIndex].getY(), 6)) {
			c.usingBow = true;
			c.stopMovement();
		}
		
		if(usingOtherRangeWeapons &amp;&amp; c.goodDistance(c.getX(), c.getY(), Server.playerHandler.players[c.playerIndex].getX(), Server.playerHandler.players[c.playerIndex].getY(), 3)) {
			c.usingRangeWeapon = true;
			c.stopMovement();
		}
		if (!usingBow)
			c.usingBow = false;
		if (!usingOtherRangeWeapons)
			c.usingRangeWeapon = false;

		if(!usingCross &amp;&amp; !usingArrows &amp;&amp; usingBow &amp;&amp; c.playerEquipment[c.playerWeapon] &lt; 4212 &amp;&amp; c.playerEquipment[c.playerWeapon] &gt; 4223) {
			c.sendMessage("You have run out of arrows!");
			return;
		} 
		if(c.getCombat().correctBowAndArrows() &lt; c.playerEquipment[c.playerArrows] &amp;&amp; Config.CORRECT_ARROWS &amp;&amp; usingBow &amp;&amp; !c.getCombat().usingCrystalBow() &amp;&amp; c.playerEquipment[c.playerWeapon] != 9185) {
				c.sendMessage("You can't use "+c.getItems().getItemName(c.playerEquipment[c.playerArrows]).toLowerCase()+"s with a "+c.getItems().getItemName(c.playerEquipment[c.playerWeapon]).toLowerCase()+".");
				c.stopMovement();
				c.getCombat().resetPlayerAttack();
				return;
		}
		if (c.playerEquipment[c.playerWeapon] == 9185 &amp;&amp; !c.getCombat().properBolts()) {
				c.sendMessage("You must use bolts with a crossbow.");
				c.stopMovement();
				c.getCombat().resetPlayerAttack();
				return;				
		}
		if (c.getCombat().checkReqs()) {
			c.sendMessage("AttackPlayer:123 requirements:" + c.getCombat().checkReqs());
			c.followId = c.playerIndex;
			if (!c.usingMagic &amp;&amp; !usingBow &amp;&amp; !usingOtherRangeWeapons) {
				c.followDistance = 1;
				c.getPA().followPlayer();
			}	
			if (c.attackTimer &lt;= 0) {
				//c.sendMessage("Tried to attack...");
				//c.getCombat().attackPlayer(c.playerIndex);
				//c.attackTimer++;
			}	
		}
		break;[/code]</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/5</link>
        <pubDate>Sun, 22 Feb 2015 03:18:06 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-5</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@zyle1992 Zymus]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/zyle1992">@zyle1992</a> wrote:</p>
          <blockquote>
              <p>Hmm, can you post your attack method? The one that the attacker would be using, as well as the death one?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/4</link>
        <pubDate>Sun, 22 Feb 2015 02:23:38 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-4</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@deathschaos9 DeathsChaos9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/deathschaos9">@deathschaos9</a> wrote:</p>
          <blockquote>
              <p>It only lags for the attacker, that leads me to believe that the issue is with player and NPC updating. The attacker’s client isn’t getting updated when the rest are.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/3</link>
        <pubDate>Sun, 22 Feb 2015 02:20:45 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-3</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@sk8rdude461 sk8rdude461]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sk8rdude461">@sk8rdude461</a> wrote:</p>
          <blockquote>
              <p>There’s a few methods named playerDelayedHit, or similar. Are you sure it’s not using those?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/2</link>
        <pubDate>Sat, 21 Feb 2015 02:33:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-2</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
      <item>
        <title>Combat Lag</title>
        <dc:creator><![CDATA[@deathschaos9 DeathsChaos9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/deathschaos9">@deathschaos9</a> wrote:</p>
          <blockquote>
              <p>I hate to ask for help but PI is so poorly written I can’t trace the origin of a nasty combat lag.</p>
<p><span class="hashtag">#Pic</span> (gif), let it load#<br>
<img src="http://azaruth.com/images/clip0010.gif" alt width="" height=""></p>
<p>As you can see, walking and attack animations are synchronized but the hit update and death animation both lag horribly for the attacker. The solution eludes me… I hope someone here has seen/dealt with this before.</p>
<p>–Requested Files/Methods–<br>
Attack method in CombatAssistant class</p>
<p>[code=java]	public void attackPlayer(int i) {<br>
if (Server.playerHandler.players[i] != null) {<br>
if (Server.playerHandler.players[i].isDead) {<br>
resetPlayerAttack();<br>
return;<br>
}<br>
if (c.curseActive[19]) { // Turmoil<br>
c.getStr = Server.playerHandler.players[i].playerLevel[2] * 10 / 100;<br>
c.getDef = Server.playerHandler.players[i].playerLevel[1] * 15 / 100;<br>
c.getAtt = Server.playerHandler.players[i].playerLevel[0] * 15 / 100;<br>
} else if (c.curseActive[10]) { // LeechAtt<br>
c.getAtt = c.playerLevel[0] * c.attInc / 100;<br>
} else if (c.curseActive[11]) { // Leech Ranged<br>
c.getRange = c.playerLevel[4] * c.rangeInc / 100;<br>
} else if (c.curseActive[12]) { // Leech Magic<br>
c.getMagic = c.playerLevel[6] * c.magicInc / 100;<br>
} else if (c.curseActive[13]) {// leechDef<br>
c.getDef = c.playerLevel[1] * c.defInc / 100;<br>
} else if (c.curseActive[14]) {// LeechStr<br>
c.getStr = c.playerLevel[2] * c.strInc / 100;<br>
}<br>
if (c.respawnTimer &gt; 0<br>
|| Server.playerHandler.players[i].respawnTimer &gt; 0) {<br>
resetPlayerAttack();<br>
return;<br>
}<br>
if (!c.getCombat().checkReqs()) {<br>
return;<br>
}<br>
if (c.getPA().getWearingAmount() &lt; 4 &amp;&amp; c.duelStatus &lt; 1) {<br>
c.sendMessage(“You must be wearing at least 4 items to attack someone.”);<br>
resetPlayerAttack();<br>
return;<br>
}<br>
boolean sameSpot = c.absX == Server.playerHandler.players[i].getX()<br>
&amp;&amp; c.absY == Server.playerHandler.players[i].getY();<br>
if (!c.goodDistance(Server.playerHandler.players[i].getX(),<br>
Server.playerHandler.players[i].getY(), c.getX(), c.getY(),<br>
25)<br>
&amp;&amp; !sameSpot) {<br>
resetPlayerAttack();<br>
return;<br>
}<br>
if (Server.playerHandler.players[i].respawnTimer &gt; 0) {<br>
Server.playerHandler.players[i].playerIndex = 0;<br>
resetPlayerAttack();<br>
return;<br>
}</p>
<pre><code>		if (Server.playerHandler.players[i].heightLevel != c.heightLevel) {
			resetPlayerAttack();
			return;
		}
		c.followId = i;
		c.followId2 = 0;
		if (c.attackTimer &lt;= 0) {
			c.usingBow = false;
			c.specEffect = 0;
			c.usingRangeWeapon = false;
			c.rangeItemUsed = 0;
			boolean usingBow = false;
			boolean usingArrows = false;
			boolean usingOtherRangeWeapons = false;
			boolean usingCross = c.playerEquipment[c.playerWeapon] == 9185;
			c.projectileStage = 0;
			if (c.absX == Server.playerHandler.players[i].absX
					&amp;&amp; c.absY == Server.playerHandler.players[i].absY) {
				if (c.freezeTimer &gt; 0) {
					resetPlayerAttack();
					return;
				}
				c.followId = i;
				c.attackTimer = 0;
				return;
			}
			if (!c.usingMagic) {
				for (int bowId : c.BOWS) {
					if (c.playerEquipment[c.playerWeapon] == bowId) {
						usingBow = true;
						for (int arrowId : c.ARROWS) {
							if (c.playerEquipment[c.playerArrows] == arrowId) {
								usingArrows = true;
							}
						}
					}
				}
				for (int otherRangeId : c.OTHER_RANGE_WEAPONS) {
					if (c.playerEquipment[c.playerWeapon] == otherRangeId) {
						usingOtherRangeWeapons = true;
					}
				}
			}
			if (c.autocasting) {
				c.spellId = c.autocastId;
				c.usingMagic = true;
			}
			if (c.spellId &gt; 0) {
				c.usingMagic = true;
			}
			c.attackTimer = getAttackDelay(c.getItems()
					.getItemName(c.playerEquipment[c.playerWeapon])
					.toLowerCase());

			if (c.duelRule[9]) {
				boolean canUseWeapon = false;
				for (int funWeapon : Config.FUN_WEAPONS) {
					if (c.playerEquipment[c.playerWeapon] == funWeapon) {
						canUseWeapon = true;
					}
				}
				if (!canUseWeapon) {
					c.sendMessage("You can only use fun weapons in this duel!");
					resetPlayerAttack();
					return;
				}
			}
			if (c.duelRule[2] &amp;&amp; (usingBow || usingOtherRangeWeapons)) {
				c.sendMessage("Range has been disabled in this duel!");
				return;
			}
			if (c.duelRule[3]
					&amp;&amp; (!usingBow &amp;&amp; !usingOtherRangeWeapons &amp;&amp; !c.usingMagic)) {
				c.sendMessage("Melee has been disabled in this duel!");
				return;
			}
			if (c.duelRule[4] &amp;&amp; c.usingMagic) {
				c.sendMessage("Magic has been disabled in this duel!");
				resetPlayerAttack();
				return;
			}
			if (!usingCross
					&amp;&amp; !usingArrows
					&amp;&amp; usingBow
					&amp;&amp; (c.playerEquipment[c.playerWeapon] &lt; 4212 || c.playerEquipment[c.playerWeapon] &gt; 4223)
					&amp;&amp; !c.usingMagic) {
				c.sendMessage("You have run out of arrows!");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (properBolts() &amp;&amp; c.playerEquipment[c.playerWeapon] == 11235) {
				c.sendMessage("You cannot use bolts with a dark bow.");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (correctBowAndArrows() &lt; c.playerEquipment[c.playerArrows]
					&amp;&amp; Config.CORRECT_ARROWS &amp;&amp; usingBow
					&amp;&amp; !usingCrystalBow()
					&amp;&amp; c.playerEquipment[c.playerWeapon] != 9185
					&amp;&amp; !c.usingMagic) {
				String itemA = c.getItems()
						.getItemName(c.playerEquipment[c.playerArrows])
						.toLowerCase();
				String itemB = c.getItems()
						.getItemName(c.playerEquipment[c.playerWeapon])
						.toLowerCase();
				c.sendMessage("You can't use " + itemA + "s with a "
						+ itemB + ".");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (c.playerEquipment[c.playerWeapon] == 9185 &amp;&amp; !properBolts()
					&amp;&amp; !c.usingMagic) {
				c.sendMessage("You must use bolts with a crossbow.");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (c.playerEquipment[c.playerWeapon] == 15241
					&amp;&amp; c.playerEquipment[c.playerArrows] != 15243) {
				c.sendMessage("You can't use Hand Cannon without cannon shots!");
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			if (c.playerEquipment[c.playerWeapon] == 15241) {
				c.gfx0(2138);
			}
			if (usingBow || c.usingMagic || usingOtherRangeWeapons
					|| usingHally()) {
				c.stopMovement();
			}
			if (!checkMagicReqs(c.spellId)) {
				c.stopMovement();
				resetPlayerAttack();
				return;
			}
			c.faceUpdate(i + 32768);
			if (c.duelStatus != 5) {
				if (!c.inBountyHunterCombat()
						&amp;&amp; !c.attackedPlayers.contains(c.playerIndex)
						&amp;&amp; !Server.playerHandler.players[c.playerIndex].attackedPlayers
								.contains(c.playerId)) {
					c.attackedPlayers.add(c.playerIndex);
					c.isSkulled = true;
					c.skullTimer = Config.SKULL_TIMER;
					c.headIconPk = 0;
					c.getPA().requestUpdates();
				}
			}
			c.specAccuracy = 1.0;
			c.specDamage = 1.0;
			c.delayedDamage = c.delayedDamage2 = 0;
			if (c.usingSpecial &amp;&amp; !c.usingMagic) {
				if (c.duelRule[10] &amp;&amp; c.duelStatus == 5) {
					c.sendMessage("Special attacks have been disabled during this duel!");
					c.usingSpecial = false;
					c.getItems().updateSpecialBar();
					resetPlayerAttack();
					return;
				}
				if (checkSpecAmount(c.playerEquipment[c.playerWeapon])) {
					c.lastArrowUsed = c.playerEquipment[c.playerArrows];
					activateSpecial(c.playerEquipment[c.playerWeapon], i);
					c.followId = c.playerIndex;
					return;
				} else {
					c.sendMessage("You don't have the required special energy to use this attack.");
					c.usingSpecial = false;
					c.getItems().updateSpecialBar();
					c.playerIndex = 0;
					return;
				}
			}
			if (!c.usingMagic) {
				c.startAnimation(getWepAnim(c.getItems()
						.getItemName(c.playerEquipment[c.playerWeapon])
						.toLowerCase()));
				c.mageFollow = false;
			} else {
				c.startAnimation(c.MAGIC_SPELLS[c.spellId][2]);
				c.mageFollow = true;
				c.followId = c.playerIndex;
			}
			if (c.coolDown == 0 &amp;&amp; c.inWild() == false) {
				resetPlayerAttack();
				return;
			}
			if (Server.playerHandler.players[i].coolDown == 0
					&amp;&amp; Server.playerHandler.players[i].world == 2)
				Server.playerHandler.players[i].coolDown = 10;
	[/code]
</code></pre>
<p>Death event in PlayerAssistant class</p>
<pre><code class="lang-auto">	/**
	 * Dieing
	 **/
	public void applyDead() {
		c.respawnTimer = 10;
		c.isDead = false;
		if (c.curseActive[17]) {
			applyWrath();
		}
		if (c.prayerActive[21])
			applyRetribution();
		if (!c.eaten)
			c.startAnimation(2304);
		else
			c.startAnimation(837);
		int weapon = c.playerEquipment[c.playerWeapon];
		if (c.duelStatus != 6) {
			// c.killerId = c.getCombat().getKillerId(c.playerId);
			c.killerId = findKiller();
			Client o = (Client) Server.playerHandler.players[c.killerId];
			for(int x = 0; x &lt; 8; x++){
				if(o.pkReqs[x] == o.pks){
					//o.sendMessage("Gratz! You've completed pk task! :)");
					c.refleshTasks();
				}
			}
			if (o != null) {
				if (!(c.npcIndex &gt; 0)) {
				}
				if (c.killerId != c.playerId) {
					o.sendMessage("You have defeated "
							+ Misc.optimizeText(c.playerName) + "!");
				}
				//if (c.killerId != c.playerId &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk())
				//	c.logKill(o.playerName, c.playerName, o.pkPoints);
				if (c.killerId != c.playerId &amp;&amp; ((o.playerRights &gt; 0 &amp;&amp; o.playerRights &lt; 4) || (c.playerRights &gt; 0 &amp;&amp; c.playerRights &lt; 4))  &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk()) {
					String data = Misc.optimizeText(o.playerName) + " killed " + Misc.optimizeText(c.playerName);
					c.log.writeLog("staffKills", data);
				}
				if ((c.inWild() &amp;&amp; !c.inFunPk()) || c.world == 2) {
					if (c == o)
						return;
					if (o.lastKilled.equalsIgnoreCase(c.playerName)) {
						o.sendMessage("You have killed " + Misc.optimizeText(c.playerName) + " twice in a row and recieve no Pk Points.");
					} else {
				//		if (Misc.random(500) &gt; 400) {
					o.pkPoints += 1;
					if (o.world == 2)
						o.pkPoints += 50;
					o.sendMessage("You have now have " + o.pkPoints + " PK Points.");
					o.lastKilled = c.playerName;
			//		}
					}
					o.getPA().sendFrame126("PkPts: " + o.pkPoints, 29169);
				}
				if (c.killerId != c.playerId &amp;&amp; c.inWild() &amp;&amp; !c.inFunPk())
					c.logKill(o.playerName, c.playerName, o.pkPoints, c.world);
				if (c.inClanWars()) {
					ClanWars.killedSomeone();
				}
				if (weapon == CastleWars.SARA_BANNER
						|| weapon == CastleWars.ZAMMY_BANNER) {
					c.getItems().removeItem(weapon, 3);
					c.getItems().deleteItem2(weapon, 1);
					CastleWars.dropFlag(c, weapon);
				}
				c.playerKilled = c.playerId;
				if (o.duelStatus == 5) {
					o.duelStatus++;
				}
			}
		}
		c.poisonDamage = 0;
		c.faceUpdate(0);
		EventManager.getSingleton().addEvent(new Event() {
			public void execute(EventContainer b) {
				c.npcIndex = 0;
				c.playerIndex = 0;
				b.stop();
			}
		}, 2500);
		c.stopMovement();
		if (c.duelStatus &lt;= 4) {
			Client o = (Client) Server.playerHandler.players[c.killerId];
			c.sendMessage("Oh dear you are dead!");
			PlayerSave.saveGame(o);
			PlayerSave.saveGame(c);
		} else if (c.duelStatus != 6) {
			Client o = (Client) Server.playerHandler.players[c.killerId];
			c.sendMessage("You have lost the duel!");
			PlayerSave.saveGame(o);
			PlayerSave.saveGame(c);
		}
		
		Client o = (Client) Server.playerHandler.players[c.killerId];
		if(o.leavePenalty &gt; 0) {
			BountyHunter.startLeavePenalty(o);
		} else {
			BountyHunter.startPickupPenalty(o);
		}
		
		resetDamageDone();
		c.specAmount = 10;
		c.getItems().addSpecialBar(c.playerEquipment[c.playerWeapon]);
		c.lastVeng = 0;
		c.vengOn = false;
		resetFollowers();
		c.attackTimer = 10;
		removeAllWindows();
		c.tradeResetNeeded = true;
	}</code></pre>
<p>Melee attack from loop in AttackPlayer class</p>
<p>[code=java]/**<br>
* Attack player<br>
**/<br>
case ATTACK_PLAYER:<br>
c.playerIndex = c.getInStream().readSignedWordBigEndian();<br>
Client other = (Client) Server.playerHandler.players[c.playerIndex];<br>
if(Server.playerHandler.players[c.playerIndex] == null ){<br>
break;<br>
}<br>
c.sendMessage(“AttackPlayer:33 find player to begin”);<br>
if(c.respawnTimer &gt; 0) {<br>
break;<br>
}</p>
<pre><code>		if (c.autocastId &gt; 0)
			c.autocasting = true;
		
		if (!c.autocasting &amp;&amp; c.spellId &gt; 0) {
			c.spellId = 0;
		}
		c.mageFollow = false;
		c.spellId = 0;
		c.usingMagic = false;
		boolean usingBow = false;
		boolean usingOtherRangeWeapons = false;
		boolean usingArrows = false;
		boolean usingCross = c.playerEquipment[c.playerWeapon] == 9185;
		for (int bowId : c.BOWS) {
			if(c.playerEquipment[c.playerWeapon] == bowId) {
				usingBow = true;
				for (int arrowId : c.ARROWS) {
					if(c.playerEquipment[c.playerArrows] == arrowId) {
						usingArrows = true;
					}
				}
			}
		}
		for (int otherRangeId : c.OTHER_RANGE_WEAPONS) {
			if(c.playerEquipment[c.playerWeapon] == otherRangeId) {
				usingOtherRangeWeapons = true;
			}
		}
		if(c.duelStatus == 5) {	
			if(c.duelCount &gt; 0) {
				c.sendMessage("The duel hasn't started yet!");
				c.playerIndex = 0;
				return;
			}
			if(c.duelRule[9]){
				boolean canUseWeapon = false;
				for(int funWeapon: Config.FUN_WEAPONS) {
					if(c.playerEquipment[c.playerWeapon] == funWeapon) {
						canUseWeapon = true;
					}
				}
				if(!canUseWeapon) {
					c.sendMessage("You can only use fun weapons in this duel!");
					return;
				}
			}
			
			if(c.duelRule[2] &amp;&amp; (usingBow || usingOtherRangeWeapons)) {
				c.sendMessage("Range has been disabled in this duel!");
				return;
			}
			if(c.duelRule[3] &amp;&amp; (!usingBow &amp;&amp; !usingOtherRangeWeapons)) {
				c.sendMessage("Melee has been disabled in this duel!");
				return;
			}
		}
		
		if((usingBow || c.autocasting) &amp;&amp; c.goodDistance(c.getX(), c.getY(), Server.playerHandler.players[c.playerIndex].getX(), Server.playerHandler.players[c.playerIndex].getY(), 6)) {
			c.usingBow = true;
			c.stopMovement();
		}
		
		if(usingOtherRangeWeapons &amp;&amp; c.goodDistance(c.getX(), c.getY(), Server.playerHandler.players[c.playerIndex].getX(), Server.playerHandler.players[c.playerIndex].getY(), 3)) {
			c.usingRangeWeapon = true;
			c.stopMovement();
		}
		if (!usingBow)
			c.usingBow = false;
		if (!usingOtherRangeWeapons)
			c.usingRangeWeapon = false;

		if(!usingCross &amp;&amp; !usingArrows &amp;&amp; usingBow &amp;&amp; c.playerEquipment[c.playerWeapon] &lt; 4212 &amp;&amp; c.playerEquipment[c.playerWeapon] &gt; 4223) {
			c.sendMessage("You have run out of arrows!");
			return;
		} 
		if(c.getCombat().correctBowAndArrows() &lt; c.playerEquipment[c.playerArrows] &amp;&amp; Config.CORRECT_ARROWS &amp;&amp; usingBow &amp;&amp; !c.getCombat().usingCrystalBow() &amp;&amp; c.playerEquipment[c.playerWeapon] != 9185) {
				c.sendMessage("You can't use "+c.getItems().getItemName(c.playerEquipment[c.playerArrows]).toLowerCase()+"s with a "+c.getItems().getItemName(c.playerEquipment[c.playerWeapon]).toLowerCase()+".");
				c.stopMovement();
				c.getCombat().resetPlayerAttack();
				return;
		}
		if (c.playerEquipment[c.playerWeapon] == 9185 &amp;&amp; !c.getCombat().properBolts()) {
				c.sendMessage("You must use bolts with a crossbow.");
				c.stopMovement();
				c.getCombat().resetPlayerAttack();
				return;				
		}
		if (c.getCombat().checkReqs()) {
			c.sendMessage("AttackPlayer:123 requirements:" + c.getCombat().checkReqs());
			c.followId = c.playerIndex;
			if (!c.usingMagic &amp;&amp; !usingBow &amp;&amp; !usingOtherRangeWeapons) {
				c.followDistance = 1;
				c.getPA().followPlayer();
			}	
			if (c.attackTimer &lt;= 0) {
				//c.sendMessage("Tried to attack...");
				//c.getCombat().attackPlayer(c.playerIndex);
				//c.attackTimer++;
			}	
		}
		break;[/code]</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/combat-lag/550056/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/combat-lag/550056/1</link>
        <pubDate>Fri, 20 Feb 2015 20:55:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-550056-1</guid>
        <source url="https://forum.moparisthebest.com/t/combat-lag/550056.rss">Combat Lag</source>
      </item>
  </channel>
</rss>
