<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>How to write an operating system(for windows and linux)</title>
    <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999</link>
    <description> Writing an operating system is something that can not only be interesting but it is also a great learning experience. Through creating your own operating system you will learn exactly what goes on behind the scenes, elevating you above the average programmer that just writes in Visual Basic.

In this tutorial you will be tought by examples, and by the end you should have created your own operating system.

Tools:
New version of easy os link:http://www.groovyweb.uklinux.net/index.php?page_name=groovyos
Most reliable version of Easyos.zip link:http://www.groovyweb.20m.com/easyos.htm
Easy os.zip link(300kb):http://www.geocities.com/solarsistem/gif/files/easyos.zip

EasyOS is a very simple operating system, it contains all the tools needed to build an operating system.

The Tutorial:
si and ah Think of si as something to put text into, and ah as something to put numbers into.
mov This (mov)es data. mov ah,0 would move 0 into ah. (The data on the right is moved into the left)
Int Think of these as functions. Different int&#39;s do different things when ah is different. Ahem. Eg. when ah = 0 and you call int 10 it prints si to the screen.
Stuff To put words and stuff in your program you can&#39;t just do mov si,&#39;some words&#39; (well, you can but you wont like the resutls) so instead you have to declare the words first. You do this by putting the name of what you want the words to be called by, then the data type (nearly always db) then the words themselves. Eg:
name db &#39;some words&#39;
Jump To give sections of code a label, just type the label and add a : at the end, eg code: . You can then use jmp to jump to it, eg jmp code If To do an if in assembly you use cmp, eg cmp al,0 (if al=0). On the next line you then put je code, and if al=0 then the program jumps to the section of code called code. If you use jne code, then if al is not 0 the program will jump to code. 
The stack The stack is where stuff is stored. push pushes stuff into it, pop pulls stuff out. The following example would put cx into dx:
push cx pop dx

Now you know everything there is to know about assembly, you can now understand most of the program that boot&#39;s EasyOs. Drives (hard drives and floppy&#39;s) are split into lots of bits, all 512 bytes long (enough to fit 512 letters in). These are calle sectors. The first sector is what the computer looks for when it boots. It is called the bootsector.
Open the folder src and then open boot.asm. Or if you are lazy, just look at the code below (its the same). 

[code]; This is a comment
[ORG 0x7C00] ;This just tells the program where it is in the memory. Not important
[BITS 16] ;Not important too.

jmp start		; Jump over BIOS parameter block

start: ;The label for the start of the actual program

push cs ;Put cs onto the stack
pop ds ;Take it out and put it into ds


mov si,Print_loading     ;Print loading message
call printstring		 ;Call is like jump, but it goes back. Like a function


						 ;The complicated bit: Loads the next program
mov ah,02h               ;When ah=, int13 reads a disk sector
mov al,4			 	 ;Al is how many sectors to read
mov ch,0			 	 ;The track to read from
mov cl,2			 	 ;Sector Id
mov dh,0			 	 ;Head
mov dl,0			 	 ;Drive (0 is floppy)
mov bx,0x1000			 ;Es and Bx put together are where to load the program too (see jmp 0x1000:0x00)
mov es,bx
mov bx,0x00
int 13h					;Int 13 is all functions for disks

mov si,putdot           ;Print a &quot;.&quot;.
call printstring

jmp 0x1000:0x00         ;Run Bootinit from stack.

printstring:            ;Print string routine.
mov ah,0eh				;Mov ah into 0, so int 10 prints
stringloop:				;The following code loads each seperate charcter so it can be printed
lodsb					
cmp al,00				;If al =0, then the string has all been loaded
je endstring
int 10h					;When int 10 is called, and ah=, it prints
jmp stringloop
endstring:
ret						;Ret returns



putdot        db &#39;.&#39;,0
Print_loading db 13,10,&#39;Loading Easy OS v0.01a...&#39;,0
times 425 db 0 ;wastes 425 bytes on purpose, so the sector is full (The program must be 512 bytes long)
[/code]

You may have noticed that numbers, like int 10h, end in h. They don&#39;t have to, it just looks funky (there is a real reason, but it&#39;s boring).
Anyway, now copy the program called copyboot in the folder called utils to the folder with test.asm in. Open the dos prompt and type: (Make sure a blank floppy is inserted)
copyboot test.com 0
copyboot is the name of the program, test.com the name of the file to copy, and 0 is the sector.
In the program above all it does is print a string then load whats at sector 1. The program that easyos loads under the src folder called bootinit. If you assemble it with nasm, then copy it to sector 1 and restart, the bootsector will load it.
There isn&#39;t much more to be learnt from EasyOs, so run either setup.exe or make.bat to build the whole thing. The difference is setup.exe lets you setup a root password for EasyOs. If you just run make.bat the passwords is the default password: monty (named after my psychotic dog).
Now restart and be amazed. Wow. Pretty crappy, but it isn&#39;t that bad.

If you try and access the floppy disk Windows will say it need s to be formatted. Formatted? You ask. Formatting is basically organising the sectors so you can give them names. Underneath Windows and Fat, you are still just accessing sectors. I won&#39;t go into Fat here, check out http://www.maverick.subnet.dk/ for some info. Anyway, the bootsector needs to have some information in it that when Windows reads it it tells it it is fat. The following BootSector was disgustingly ripped by me of NYAOS (I have no idea what i stands for). With your A* qualification in assembly language you can no doubt understand it.

[code]; NYAOS Boot Sector (C) Copyright Sean Tash 1998
; assemble with:
; nasm -f bin -o bootsect.bin bootsect.asm
            bits 16
            org 0x7C00

start:      jmp short begin
            nop
bsOEM       db &quot;NYAOS1.0&quot;               ; OEM String
bsSectSize  dw 512                      ; Bytes per sector
bsClustSize db 1                        ; Sectors per cluster
bsRessect   dw 1                        ; # of reserved sectors
bsFatCnt    db 2                        ; # of fat copies
bsRootSize  dw 224                      ; size of root directory
bsTotalSect dw 2880                     ; total # of sectors if &lt; 32 meg
bsMedia     db 0xF0                     ; Media Descriptor
bsFatSize   dw 9                        ; Size of each FAT
bsTrackSect dw 18                       ; Sectors per track
bsHeadCnt   dw 2                        ; number of read-write heads
bsHidenSect dd 0                        ; number of hidden sectors
bsHugeSect  dd 0                        ; if bsTotalSect is 0 this value is
                                        ; the number of sectors
bsBootDrv   db 0                        ; holds drive that the bs came from
bsReserv    db 0                        ; not used for anything
bsBootSign  db 29h                      ; boot signature 29h
bsVolID     dd 0                        ; Disk volume ID also used for temp
                                        ; sector # / # sectors to load
bsVoLabel   db &quot;NO NAME    &quot;            ; Volume Label
bsFSType    db &quot;FAT12   &quot;               ; File System type

begin:      cli                         ; disable interrupts
            mov [bsBootDrv],dl          ; save drive number
            mov ax,0x9000               ; put stack at 0x98000
            mov ss,ax
            mov sp,0x8000

            mov cx,[bsTrackSect]        ; update int 1E FDC param table
            mov bx,0x0078
            lds si,[ds:bx]
            mov byte [si+4], cl
            mov byte [si+9], 0x0F

            sti                         ; enable interrupts
            push ds
            mov dl,[bsBootDrv]          ; reset controller
            xor ax,ax
            int 0x13
            pop ds
            jc bootfail2                ; display error message
            jmp _l1
bootfail2:  jmp bootfail
_l1:
            mov ax,0x0000
            mov es,ax
            mov ds,ax

            mov si,MsgLoad              ; display load message
            call putstr

            ; find the root directory

            xor ax,ax
            mov al,[bsFatCnt]
            mov bx,[bsFatSize]
            mul bx
            add ax,word [bsHidenSect]
            adc ax,word [bsHidenSect+2]
            add ax,word [bsRessect]     ; ax holds root directory location
            mov word [BootSig],ax

            call checkroot

            xor ax,ax
            add ax,word [start]
            add ax,word [bsVolID]       ; sector number
            add ax,word [BootSig]
            sub ax,2                    ; correction for a mis-calc
            mov cx,word [bsVolID+2]     ; number of sectors

            mov bx,0x8000
            mov es,bx


nextsector: push ax                     ; save registers
            push cx
            push dx
            push es

            xor bx,bx                   ; set zero offset
            call readsect               ; read a sector

            mov si,MsgDot               ; display a dot
            call putstr

            pop es                      ; restore registers
            pop dx
            pop cx
            pop ax
            mov bx,es
            add bx,20h                  ; increment address 512 bytes
            mov es,bx
            inc ax                      ; read next sector
            loopnz nextsector

            mov ax,0x8000               ; set segment registers and jump
            mov es,ax
            mov ds,ax
            push ax
            mov ax,0
            push ax
            retf

checkroot:
            push ax                     ; save registers
            push bx
            push cx
            push dx
            push si
            push di
            
            mov ax,0x8000               ; put root directory at 0x80000
            mov es,ax
            mov ax,32                   ; AX = ((32*RootSize)/512) + 2
            mul word [bsRootSize]
            div word [bsSectSize]
            mov cx,ax                   ; cx holds # of sectors in root
            mov word [start],ax
            mov ax,word [BootSig]       ; get prev. saved loc. for root dir

r1:         xor bx,bx
            push cx                     ; save count
            push ax                     ; save sector number
            push es
            push dx
            call readsect
            xor bx,bx
l_1:        mov di,bx                   ; set address to check from
            mov cx,11                   ; check 11 bytes
            mov si,FileName             ; address of string to check with
            repz cmpsb
            je foundit
            add bx,32                   ; check next entry
            cmp bx,[bsSectSize]         ; end of sector?
            je l_2
            jmp l_1
l_2:        pop dx                      ; restore registers
            pop es
            pop ax
            pop cx
            inc ax                      ; read next sector
            loopnz r1
            jmp bootfail
foundit:    pop dx                      ; get these off the stack
            pop es
            pop ax
            pop cx

            mov di,0x1A                 ; get clustor #
            add di,bx
            push bx                     ; save bx for finding # of sectors
            mov ax,[es:di]
            xor bx,bx                   ; calculate sector #
            mov bl,[bsClustSize]
            mul bx                      ; ax holds sector #
            mov word [bsVolID],ax

            pop bx                      ; get location of directory entry
            mov di,0x1C
            add di,bx
            mov ax,[es:di]              ; put number of bytes in ax
            xor dx,dx
            mov bx,[bsClustSize]        ; # of bytes / 512
            div bx
            inc ax
            mov word [bsVolID+2],ax     ; save number of sectors to load

            pop di                      ; restore registers
            pop si
            pop dx
            pop cx
            pop bx
            pop ax
            
            ret                         ; return to caller
            
putstr:     ; SI = address of string to display
            lodsb
            or al,al
            jz short putstrd
            mov ah,0x0E
            mov bx,0x0007
            int 0x10
            jmp putstr
putstrd:    retn                        ; return to caller

bootfail:   ; display failure message
            mov si,MsgBad               ; display error message
            call putstr
            xor ax,ax                   ; wait for keypress
            int 0x16
            int 0x19                    ; reboot

readsect:   ; ES:BX = Location ; AX = Sector
            mov si,[bsTrackSect]
            div si                      ; divide logical sect by track size
            inc dl                      ; sector # begins at 1
            mov [bsReserv],dl           ; sector to read
            xor dx,dx                   ; logical track left in ax
            div word [bsHeadCnt]        ; leaves head in dl, cyl in ax
            mov dh, [bsBootDrv]         ;
            xchg dl,dh                  ; head to dh, drive to dl
            mov cx,ax                   ; cyl to cx
            xchg cl,ch                  ; low 8 bits of cyl to ch, hi 2 bits
            shl cl,6                    ; shifted to bits 6 and 7
            or cl, byte [bsReserv]      ; or with sector number
            mov al,1                    ; number of sectors
            mov ah,2                    ; use read function of int 0x13
            int 0x13                    ; read sector
            jc bootfail                 ; display error message
            ret                         ; return to caller

padding     times 45 db 0
FileName    db &quot;OSLOADERCOM&quot;
MsgBad      db &quot;Disk Error...&quot;,13,10,0
MsgDot      db &quot;.&quot;,0
MsgLoad     db &quot;doors loading&quot;,0
BootSig     db 0x55, 0xAA
[/code]</description>
    
    <lastBuildDate>Fri, 08 Jun 2007 06:42:18 +0000</lastBuildDate>
    <category>General Discussion</category>
    <atom:link href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@blade_arrow0 blade arrow0]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/blade_arrow0">@blade_arrow0</a> wrote:</p>
          <blockquote>
              <p>try again might work</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/13</link>
        <pubDate>Fri, 08 Jun 2007 06:42:18 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-13</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@Ca1lum Ca1lum]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ca1lum">@Ca1lum</a> wrote:</p>
          <blockquote>
              <p>I tried it but i couldnt do it lol  <img src="https://forum.moparisthebest.com/images/emoji/twitter/expressionless.png?v=6" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/12</link>
        <pubDate>Thu, 31 May 2007 13:54:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-12</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@blade_arrow0 blade arrow0]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/blade_arrow0">@blade_arrow0</a> wrote:</p>
          <blockquote>
              <p>o ok then i aint lockin it</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/11</link>
        <pubDate>Thu, 31 May 2007 08:09:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-11</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@ghostboy195 ghostboy195]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ghostboy195">@ghostboy195</a> wrote:</p>
          <blockquote>
              <p>yeah, too bad the links  to the dls are down <img src="https://forum.moparisthebest.com/images/emoji/twitter/frowning.png?v=6" title=":frowning:" class="emoji" alt=":frowning:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/10</link>
        <pubDate>Mon, 14 May 2007 07:51:31 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-10</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@Ron Ron]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ron">@Ron</a> wrote:</p>
          <blockquote>
              <blockquote>ty
credicts to:blade arrow0,groovyweb and Chris(not Mr.Chris)</blockquote>
That's in his second post in this tutorial. He credited them. :)
<p>Cool tutorial. Would be pretty sick if we made our own operating system.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/9</link>
        <pubDate>Sun, 13 May 2007 16:25:04 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-9</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@blade_arrow0 blade arrow0]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/blade_arrow0">@blade_arrow0</a> wrote:</p>
          <blockquote>
              <p>i did credict them</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/8</link>
        <pubDate>Sun, 13 May 2007 02:55:44 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-8</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@tomo6627 tomo6627]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/tomo6627">@tomo6627</a> wrote:</p>
          <blockquote>
              <p>All you have to do is credit them.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/7</link>
        <pubDate>Sat, 12 May 2007 10:49:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-7</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@blade_arrow0 blade arrow0]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/blade_arrow0">@blade_arrow0</a> wrote:</p>
          <blockquote>
              <p>how can i lock it?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/6</link>
        <pubDate>Tue, 08 May 2007 03:51:38 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-6</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@regecks1 regecks`]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/regecks1">@regecks1</a> wrote:</p>
          <blockquote>
              <p>First tutorial is dated 2006, the second isn’t dated at all.</p>
<p>The important thing is that you should cite all sources if you copy even parts of content, copyright &amp;c.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/5</link>
        <pubDate>Tue, 08 May 2007 03:43:55 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-5</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@blade_arrow0 blade arrow0]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/blade_arrow0">@blade_arrow0</a> wrote:</p>
          <blockquote>
              <p>i got mine from here <a href="http://www.groovyweb.uklinux.net/index.php?page_name=how%20to%20write%20your%20own%20os" rel="nofollow noopener">http://www.groovyweb.uklinux.net/index.php?page_name=how%20to%20write%20your%20own%20os</a>. so who actualy made this? the site u metioned or this 1</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/4</link>
        <pubDate>Tue, 08 May 2007 03:42:34 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-4</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@regecks1 regecks`]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/regecks1">@regecks1</a> wrote:</p>
          <blockquote>
              <p>Might want to mention that all of it was taken from <a href="http://www.free2code.net/tutorials/view/writing_your_own_operating_system-12/page1.html" rel="nofollow noopener">http://www.free2code.net/tutorials/view/writing_your_own_operating_system-12/page1.html</a></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/3</link>
        <pubDate>Tue, 08 May 2007 03:37:45 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-3</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@blade_arrow0 blade arrow0]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/blade_arrow0">@blade_arrow0</a> wrote:</p>
          <blockquote>
              <p>Anyways, copy the above program, save it, build it with nasm, copy it with copyboot.<br>
As you can guess above, it loads a program called ‘<a href="http://OSLOADER.COM" rel="nofollow noopener">OSLOADER.COM</a>’ off of the floppy. So, if you want a particularily funky os, build the following with nasm:</p>
<p>[code];Funky squares<br>
;<br>
;Assembles with NASM<br>
;Made by Frej  somewhere between april and may 2000<br>
;Bits reprogrammed to run within DeviatorOS<br>
;<br>
;This demo is just to show you how small graphical demos can get <img src="https://forum.moparisthebest.com/images/emoji/twitter/wink.png?v=6" title=":wink:" class="emoji" alt=":wink:"><br>
;Reprogrammed for DeviatorOS as demo program</p>
<pre><code>    org 0x0000
    mov ax,cs
    mov ds,ax
    mov es,ax         ; fix segment regs
</code></pre>
<p>start:  mov bx,cs         ;put codesegment to bx<br>
add bh,0x20       ;add 2000 to bx<br>
mov ds,bx         ;and put it to ds<br>
mov ax,0x13       ;set ax to videomode 13<br>
int 10h           ;and do that<br>
Main:   push ds           ;put buffer seg to stack<br>
pop es            ;and put that into es<br>
in ax,0x40        ;generate “random” number (timer)<br>
shl ax,4          ;multiply random # with 16<br>
mov di,ax         ;box offset (random)<br>
mov al,255        ;color of the box<br>
mov bx,50         ;height=50<br>
pl:     add di,270        ;di+270 (320-width(50))<br>
mov cx,50         ;# bytes to copy to buffer<br>
rep stosb         ;and do it<br>
dec bx            ;decrement bx<br>
jnz pl            ;jump if bx not zero<br>
mov bh,0xFA       ;assume bl = 0 (-&gt; bx = FA00)<br>
Smudge: mov al,[bx+1]     ;right color to al<br>
mov cl,[bx-1]     ;left color to cl<br>
add ax,cx         ;and add it to ax<br>
mov cl,[bx-320]   ;upper color to cl<br>
add ax,cx         ;and add it to ax<br>
mov cl,[bx+320]   ;lower color to cl<br>
add ax,cx         ;and add it to ax<br>
shr ax,2          ;divide with 4<br>
mov [bx],al       ;and but the avarage color to buffer<br>
dec bx            ;decrement bx<br>
jnz Smudge        ;jump if bx not zero<br>
mov ax,0xA000     ;vga seg<br>
mov es,ax         ;put it to es<br>
mov ch,0xFA       ;# bytes to copy to vga<br>
xor di,di         ;zero vga offset<br>
xor si,si         ;zero buffer offset<br>
rep movsb         ;and do that<br>
in al,0x60        ;check for keys<br>
dec al            ;was it esc?<br>
jnz Main          ;nope, continue<br>
mov ax,3          ;text mode<br>
int 10h           ;get back into text mode<br>
xor ah,ah         ;yes, return to OS<br>
int 0x18          ;back to good old kernel<br>
;Note:- This was, as you can guess, ripped by from an os. So when it goes back to the ‘good ol kernel’ it just restarts.</p>
<p>[/code]</p>
<p>Build it with nasm, but rather than faffing around copyboot, just name is as <a href="http://OSLOADER.COM" rel="nofollow noopener">OSLOADER.COM</a> and copy it to the floppy.<br>
Now restart and enjoy the funkiness. Woah dood.</p>
<p>Time to escape assembly language. The boot sector has to be written in assembly, but nothing else does. Unfortunately you can’t just go and write a cool shell with Visual C++. First of all, its has to be a .com program, not .exe.<br>
.exe programs are just .com with a bit of extra info. at the start giving some info on what the program is. It’s very easy to add .exe capabililty to an os, or you can download a program called exe2com.<br>
The serious problem though is that you can create your own ints to make things easier. EasyOs does this (look in kernel.asm under the src folder) and Dos does this too (Dos makes int 21). By default, compilers build a program with these ints.</p>
<p><span class="bbcode-b">For linux lovers</span></p>
<p>The following code is for Gcc on linux and nasm for dos or linux. Dos/ Windows users can download Djgpp from <a href="http://www.delorie.com/djgpp/" rel="nofollow noopener">http://www.delorie.com/djgpp/</a>, which is like gcc. The line<br>
gcc -c -O2 -Wall -g -o hello.o hello.c<br>
Tells gcc to build a plain binary. The following was probably written by Vikas Panchal. Thanks to Rod Pemberton for correcting the code.</p>
<p>[code]The smallest pmode + C program I could write is shown below,<br>
in three files. I compiled with GCC, not GPP, and got no<br>
warnings.</p>
<p>This code doesn’t check for a 32-bit CPU or V86 mode. If you<br>
try to run it inside a DOS box, Windows will kill it.</p>
<p>load.asm is assembled to aout format instead of COFF, because<br>
DJGPP COFF doesn’t let you mix 16- and 32-bit code.</p>
<p>;/****************************************************************************<br>
;       file load.asm<br>
;****************************************************************************/<br>
[SECTION .text]<br>
[BITS 16]<br>
[GLOBAL start]<br>
start:  xor ebx,ebx             ; now in real mode (16-bit)<br>
mov bx,cs<br>
shl ebx,4<br>
mov eax,ebx		; EAX=EBX=CS&lt;&lt;4<br>
lea eax,[ebx]<br>
mov [gdt2 + 2],ax	; set descriptor base address=EAX<br>
mov [gdt3 + 2],ax<br>
shr eax,16<br>
mov [gdt2 + 4],al<br>
mov [gdt3 + 4],al<br>
mov [gdt2 + 7],ah<br>
mov [gdt3 + 7],ah<br>
lea eax,[ebx + gdt]	; point gdt_ptr to the gdt<br>
mov [gdt_ptr + 2],eax	; EAX=linear address of gdt<br>
push dword 0		; zero EFLAGS (interrupts off,<br>
popfd			;  IOPL=0, NT bit=0)<br>
o32 lgdt [gdt_ptr]<br>
mov eax,cr0<br>
or al,1<br>
mov cr0,eax<br>
jmp SYS_CODE_SEL:do_pm<br>
[BITS 32]<br>
do_pm:  mov ax,SYS_DATA_SEL     ; now in 32-bit pmode<br>
mov ds,eax		; EAX works, one byte smaller <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=6" title=":slight_smile:" class="emoji" alt=":slight_smile:"><br>
mov ss,eax<br>
nop<br>
mov es,eax<br>
mov fs,eax<br>
mov gs,eax<br>
xor eax,eax		; zero top 16 bits of ESP<br>
mov ax,sp<br>
mov esp,eax<br>
[EXTERN _main]<br>
call _main		; call C code<br>
jmp $			; freeze</p>
<p>[SECTION .data]<br>
; null descriptor<br>
gdt:	dw 0			; limit 15:0<br>
dw 0			; base 15:0<br>
db 0			; base 23:16<br>
db 0			; type<br>
db 0			; limit 19:16, flags<br>
db 0			; base 31:24<br>
; linear data segment descriptor<br>
LINEAR_SEL	equ	$-gdt<br>
dw 0xFFFF               ; limit 0xFFFFF (1 meg? 4 gig?)<br>
dw 0			; base for this one is always 0<br>
db 0<br>
db 0x92			; present,ring 0,data,expand-up,writable<br>
db 0xCF                 ; page-granular (4 gig limit), 32-bit<br>
db 0<br>
; code segment descriptor<br>
SYS_CODE_SEL	equ	$-gdt<br>
gdt2:	dw 0xFFFF<br>
dw 0			; (base gets set above)<br>
db 0<br>
db 0x9A			; present,ring 0,code,non-conforming,readable<br>
db 0xCF<br>
db 0<br>
; data segment descriptor<br>
SYS_DATA_SEL	equ	$-gdt<br>
gdt3:	dw 0xFFFF<br>
dw 0			; (base gets set above)<br>
db 0<br>
db 0x92			; present,ring 0,data,expand-up,writable<br>
db 0xCF<br>
db 0<br>
gdt_end:</p>
<p>gdt_ptr:<br>
dw gdt_end - gdt - 1	; GDT limit<br>
dd gdt			; linear, physical address of GDT</p>
<p>;/****************************************************************************<br>
;       file hello.c<br>
;***************************************************************************<em>/<br>
<span class="hashtag">#include</span>  /</em> movedata() */</p>
<p><span class="hashtag">#define</span>	LINEAR_SEL	0x08<br>
<span class="hashtag">#define</span>	SYS_DATA_SEL	0x18</p>
<p>int main(void)<br>
{<br>
const char Msg[] = "h e l l o ";</p>
<pre><code>movedata(SYS_DATA_SEL, (unsigned)Msg,
	LINEAR_SEL, 0xB8000,
	sizeof(Msg));
return 0;
</code></pre>
<p>}</p>
<p>;/****************************************************************************<br>
;	file build.bat<br>
;*****************************************************************************/<br>
nasm -f aout -o load.o load.asm<br>
gcc -c -O2 -Wall -g -o hello.o hello.c<br>
ld -o <a href="http://pm.com" rel="nofollow noopener">pm.com</a> -oformat binary -Ttext=0x100 load.o hello.o /djgpp/lib/libc.a<br>
[/code]</p>
<p>ty<br>
credicts to:blade arrow0,groovyweb and Chris(not Mr.Chris)</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/2</link>
        <pubDate>Tue, 08 May 2007 03:30:58 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-2</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
      <item>
        <title>How to write an operating system(for windows and linux)</title>
        <dc:creator><![CDATA[@blade_arrow0 blade arrow0]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/blade_arrow0">@blade_arrow0</a> wrote:</p>
          <blockquote>
              <p>Writing an operating system is something that can not only be interesting but it is also a great learning experience. Through creating your own operating system you will learn exactly what goes on behind the scenes, elevating you above the average programmer that just writes in Visual Basic.</p>
<p>In this tutorial you will be tought by examples, and by the end you should have created your own operating system.</p>
<p>Tools:<br>
New version of easy os link:<a href="http://www.groovyweb.uklinux.net/index.php?page_name=groovyos" rel="nofollow noopener">http://www.groovyweb.uklinux.net/index.php?page_name=groovyos</a><br>
Most reliable version of Easyos.zip link:<a href="http://www.groovyweb.20m.com/easyos.htm" rel="nofollow noopener">http://www.groovyweb.20m.com/easyos.htm</a><br>
Easy os.zip link(300kb):<a href="http://www.geocities.com/solarsistem/gif/files/easyos.zip" rel="nofollow noopener">http://www.geocities.com/solarsistem/gif/files/easyos.zip</a></p>
<p>EasyOS is a very simple operating system, it contains all the tools needed to build an operating system.</p>
<p>The Tutorial:<br>
si and ah Think of si as something to put text into, and ah as something to put numbers into.<br>
mov This (mov)es data. mov ah,0 would move 0 into ah. (The data on the right is moved into the left)<br>
Int Think of these as functions. Different int’s do different things when ah is different. Ahem. Eg. when ah = 0 and you call int 10 it prints si to the screen.<br>
Stuff To put words and stuff in your program you can’t just do mov si,‘some words’ (well, you can but you wont like the resutls) so instead you have to declare the words first. You do this by putting the name of what you want the words to be called by, then the data type (nearly always db) then the words themselves. Eg:<br>
name db ‘some words’<br>
Jump To give sections of code a label, just type the label and add a : at the end, eg code: . You can then use jmp to jump to it, eg jmp code If To do an if in assembly you use cmp, eg cmp al,0 (if al=0). On the next line you then put je code, and if al=0 then the program jumps to the section of code called code. If you use jne code, then if al is not 0 the program will jump to code.<br>
The stack The stack is where stuff is stored. push pushes stuff into it, pop pulls stuff out. The following example would put cx into dx:<br>
push cx pop dx</p>
<p>Now you know everything there is to know about assembly, you can now understand most of the program that boot’s EasyOs. Drives (hard drives and floppy’s) are split into lots of bits, all 512 bytes long (enough to fit 512 letters in). These are calle sectors. The first sector is what the computer looks for when it boots. It is called the bootsector.<br>
Open the folder src and then open boot.asm. Or if you are lazy, just look at the code below (its the same).</p>
<p>[code]; This is a comment<br>
[ORG 0x7C00] ;This just tells the program where it is in the memory. Not important<br>
[BITS 16] ;Not important too.</p>
<p>jmp start		; Jump over BIOS parameter block</p>
<p>start: ;The label for the start of the actual program</p>
<p>push cs ;Put cs onto the stack<br>
pop ds ;Take it out and put it into ds</p>
<p>mov si,Print_loading     ;Print loading message<br>
call printstring		 ;Call is like jump, but it goes back. Like a function</p>
<pre><code>					 ;The complicated bit: Loads the next program
</code></pre>
<p>mov ah,02h               ;When ah=, int13 reads a disk sector<br>
mov al,4			 	 ;Al is how many sectors to read<br>
mov ch,0			 	 ;The track to read from<br>
mov cl,2			 	 ;Sector Id<br>
mov dh,0			 	 ;Head<br>
mov dl,0			 	 ;Drive (0 is floppy)<br>
mov bx,0x1000			 ;Es and Bx put together are where to load the program too (see jmp 0x1000:0x00)<br>
mov es,bx<br>
mov bx,0x00<br>
int 13h					;Int 13 is all functions for disks</p>
<p>mov si,putdot           ;Print a “.”.<br>
call printstring</p>
<p>jmp 0x1000:0x00         ;Run Bootinit from stack.</p>
<p>printstring:            ;Print string routine.<br>
mov ah,0eh				;Mov ah into 0, so int 10 prints<br>
stringloop:				;The following code loads each seperate charcter so it can be printed<br>
lodsb					<br>
cmp al,00				;If al =0, then the string has all been loaded<br>
je endstring<br>
int 10h					;When int 10 is called, and ah=, it prints<br>
jmp stringloop<br>
endstring:<br>
ret						;Ret returns</p>
<p>putdot        db ‘.’,0<br>
Print_loading db 13,10,‘Loading Easy OS v0.01a…’,0<br>
times 425 db 0 ;wastes 425 bytes on purpose, so the sector is full (The program must be 512 bytes long)<br>
[/code]</p>
<p>You may have noticed that numbers, like int 10h, end in h. They don’t have to, it just looks funky (there is a real reason, but it’s boring).<br>
Anyway, now copy the program called copyboot in the folder called utils to the folder with test.asm in. Open the dos prompt and type: (Make sure a blank floppy is inserted)<br>
copyboot <a href="http://test.com" rel="nofollow noopener">test.com</a> 0<br>
copyboot is the name of the program, <a href="http://test.com" rel="nofollow noopener">test.com</a> the name of the file to copy, and 0 is the sector.<br>
In the program above all it does is print a string then load whats at sector 1. The program that easyos loads under the src folder called bootinit. If you assemble it with nasm, then copy it to sector 1 and restart, the bootsector will load it.<br>
There isn’t much more to be learnt from EasyOs, so run either setup.exe or make.bat to build the whole thing. The difference is setup.exe lets you setup a root password for EasyOs. If you just run make.bat the passwords is the default password: monty (named after my psychotic dog).<br>
Now restart and be amazed. Wow. Pretty crappy, but it isn’t that bad.</p>
<p>If you try and access the floppy disk Windows will say it need s to be formatted. Formatted? You ask. Formatting is basically organising the sectors so you can give them names. Underneath Windows and Fat, you are still just accessing sectors. I won’t go into Fat here, check out <a href="http://www.maverick.subnet.dk/" rel="nofollow noopener">http://www.maverick.subnet.dk/</a> for some info. Anyway, the bootsector needs to have some information in it that when Windows reads it it tells it it is fat. The following BootSector was disgustingly ripped by me of NYAOS (I have no idea what i stands for). With your A* qualification in assembly language you can no doubt understand it.</p>
<p>[code]; NYAOS Boot Sector © Copyright Sean Tash 1998<br>
; assemble with:<br>
; nasm -f bin -o bootsect.bin bootsect.asm<br>
bits 16<br>
org 0x7C00</p>
<p>start:      jmp short begin<br>
nop<br>
bsOEM       db “NYAOS1.0”               ; OEM String<br>
bsSectSize  dw 512                      ; Bytes per sector<br>
bsClustSize db 1                        ; Sectors per cluster<br>
bsRessect   dw 1                        ; # of reserved sectors<br>
bsFatCnt    db 2                        ; # of fat copies<br>
bsRootSize  dw 224                      ; size of root directory<br>
bsTotalSect dw 2880                     ; total # of sectors if &lt; 32 meg<br>
bsMedia     db 0xF0                     ; Media Descriptor<br>
bsFatSize   dw 9                        ; Size of each FAT<br>
bsTrackSect dw 18                       ; Sectors per track<br>
bsHeadCnt   dw 2                        ; number of read-write heads<br>
bsHidenSect dd 0                        ; number of hidden sectors<br>
bsHugeSect  dd 0                        ; if bsTotalSect is 0 this value is<br>
; the number of sectors<br>
bsBootDrv   db 0                        ; holds drive that the bs came from<br>
bsReserv    db 0                        ; not used for anything<br>
bsBootSign  db 29h                      ; boot signature 29h<br>
bsVolID     dd 0                        ; Disk volume ID also used for temp<br>
; sector # / # sectors to load<br>
bsVoLabel   db "NO NAME    "            ; Volume Label<br>
bsFSType    db "FAT12   "               ; File System type</p>
<p>begin:      cli                         ; disable interrupts<br>
mov [bsBootDrv],dl          ; save drive number<br>
mov ax,0x9000               ; put stack at 0x98000<br>
mov ss,ax<br>
mov sp,0x8000</p>
<pre><code>        mov cx,[bsTrackSect]        ; update int 1E FDC param table
        mov bx,0x0078
        lds si,[ds:bx]
        mov byte [si+4], cl
        mov byte [si+9], 0x0F

        sti                         ; enable interrupts
        push ds
        mov dl,[bsBootDrv]          ; reset controller
        xor ax,ax
        int 0x13
        pop ds
        jc bootfail2                ; display error message
        jmp _l1
</code></pre>
<p>bootfail2:  jmp bootfail<br>
_l1:<br>
mov ax,0x0000<br>
mov es,ax<br>
mov ds,ax</p>
<pre><code>        mov si,MsgLoad              ; display load message
        call putstr

        ; find the root directory

        xor ax,ax
        mov al,[bsFatCnt]
        mov bx,[bsFatSize]
        mul bx
        add ax,word [bsHidenSect]
        adc ax,word [bsHidenSect+2]
        add ax,word [bsRessect]     ; ax holds root directory location
        mov word [BootSig],ax

        call checkroot

        xor ax,ax
        add ax,word [start]
        add ax,word [bsVolID]       ; sector number
        add ax,word [BootSig]
        sub ax,2                    ; correction for a mis-calc
        mov cx,word [bsVolID+2]     ; number of sectors

        mov bx,0x8000
        mov es,bx
</code></pre>
<p>nextsector: push ax                     ; save registers<br>
push cx<br>
push dx<br>
push es</p>
<pre><code>        xor bx,bx                   ; set zero offset
        call readsect               ; read a sector

        mov si,MsgDot               ; display a dot
        call putstr

        pop es                      ; restore registers
        pop dx
        pop cx
        pop ax
        mov bx,es
        add bx,20h                  ; increment address 512 bytes
        mov es,bx
        inc ax                      ; read next sector
        loopnz nextsector

        mov ax,0x8000               ; set segment registers and jump
        mov es,ax
        mov ds,ax
        push ax
        mov ax,0
        push ax
        retf
</code></pre>
<p>checkroot:<br>
push ax                     ; save registers<br>
push bx<br>
push cx<br>
push dx<br>
push si<br>
push di</p>
<pre><code>        mov ax,0x8000               ; put root directory at 0x80000
        mov es,ax
        mov ax,32                   ; AX = ((32*RootSize)/512) + 2
        mul word [bsRootSize]
        div word [bsSectSize]
        mov cx,ax                   ; cx holds # of sectors in root
        mov word [start],ax
        mov ax,word [BootSig]       ; get prev. saved loc. for root dir
</code></pre>
<p>r1:         xor bx,bx<br>
push cx                     ; save count<br>
push ax                     ; save sector number<br>
push es<br>
push dx<br>
call readsect<br>
xor bx,bx<br>
l_1:        mov di,bx                   ; set address to check from<br>
mov cx,11                   ; check 11 bytes<br>
mov si,FileName             ; address of string to check with<br>
repz cmpsb<br>
je foundit<br>
add bx,32                   ; check next entry<br>
cmp bx,[bsSectSize]         ; end of sector?<br>
je l_2<br>
jmp l_1<br>
l_2:        pop dx                      ; restore registers<br>
pop es<br>
pop ax<br>
pop cx<br>
inc ax                      ; read next sector<br>
loopnz r1<br>
jmp bootfail<br>
foundit:    pop dx                      ; get these off the stack<br>
pop es<br>
pop ax<br>
pop cx</p>
<pre><code>        mov di,0x1A                 ; get clustor #
        add di,bx
        push bx                     ; save bx for finding # of sectors
        mov ax,[es:di]
        xor bx,bx                   ; calculate sector #
        mov bl,[bsClustSize]
        mul bx                      ; ax holds sector #
        mov word [bsVolID],ax

        pop bx                      ; get location of directory entry
        mov di,0x1C
        add di,bx
        mov ax,[es:di]              ; put number of bytes in ax
        xor dx,dx
        mov bx,[bsClustSize]        ; # of bytes / 512
        div bx
        inc ax
        mov word [bsVolID+2],ax     ; save number of sectors to load

        pop di                      ; restore registers
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        
        ret                         ; return to caller
</code></pre>
<p>putstr:     ; SI = address of string to display<br>
lodsb<br>
or al,al<br>
jz short putstrd<br>
mov ah,0x0E<br>
mov bx,0x0007<br>
int 0x10<br>
jmp putstr<br>
putstrd:    retn                        ; return to caller</p>
<p>bootfail:   ; display failure message<br>
mov si,MsgBad               ; display error message<br>
call putstr<br>
xor ax,ax                   ; wait for keypress<br>
int 0x16<br>
int 0x19                    ; reboot</p>
<p>readsect:   ; ES:BX = Location ; AX = Sector<br>
mov si,[bsTrackSect]<br>
div si                      ; divide logical sect by track size<br>
inc dl                      ; sector # begins at 1<br>
mov [bsReserv],dl           ; sector to read<br>
xor dx,dx                   ; logical track left in ax<br>
div word [bsHeadCnt]        ; leaves head in dl, cyl in ax<br>
mov dh, [bsBootDrv]         ;<br>
xchg dl,dh                  ; head to dh, drive to dl<br>
mov cx,ax                   ; cyl to cx<br>
xchg cl,ch                  ; low 8 bits of cyl to ch, hi 2 bits<br>
shl cl,6                    ; shifted to bits 6 and 7<br>
or cl, byte [bsReserv]      ; or with sector number<br>
mov al,1                    ; number of sectors<br>
mov ah,2                    ; use read function of int 0x13<br>
int 0x13                    ; read sector<br>
jc bootfail                 ; display error message<br>
ret                         ; return to caller</p>
<p>padding     times 45 db 0<br>
FileName    db “OSLOADERCOM”<br>
MsgBad      db “Disk Error…”,13,10,0<br>
MsgDot      db “.”,0<br>
MsgLoad     db “doors loading”,0<br>
BootSig     db 0x55, 0xAA<br>
[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999/1</link>
        <pubDate>Tue, 08 May 2007 03:29:46 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-90999-1</guid>
        <source url="https://forum.moparisthebest.com/t/how-to-write-an-operating-system-for-windows-and-linux/90999.rss">How to write an operating system(for windows and linux)</source>
      </item>
  </channel>
</rss>
