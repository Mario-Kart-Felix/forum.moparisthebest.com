<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>BufferedImage From Component</title>
    <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688</link>
    <description>I have the method to get the component for my bots applet:
[code]
		public static Component getClientComponent() {
		return app.getComponentAt(1, 1);
		}
		
[/code]

I want to know if It&#39;s possible that I can get a buffered image of the getClientComponent() and be able to use the getRGB(x,y) method on the buffered image. I&#39;ll be using the RGB method as follows in the method below..

[code]
				public static void findColor(int red, int green, int blue) {

				//need to declare bufferedimage here	:(
		try {
		for (int y = 0; y &lt; size.height; y++)
        {
            for (int x = 0; x &lt; size.width; x++)
            {
			Color c = new Color(img.getRGB(x,y));
			int cred = c.getRed();
			int cgreen = c.getGreen();
			int cblue = c.getBlue();
			System.out.println(&quot;Found color- R=&quot;+cred+&quot;-G=&quot;+cgreen+&quot;-B=&quot;+cblue+&quot;@&quot;+x+&quot;,&quot;+y);
			}
		}
		} catch(Exception ex) { }
		}
[/code]

Any help is appeciated.

Speedster239...</description>
    
    <lastBuildDate>Thu, 20 Dec 2007 03:24:18 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@diddlewotsit diddlewotsit]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/diddlewotsit">@diddlewotsit</a> wrote:</p>
          <blockquote>
              <p>How would I go about the -Xbootclasspath in an eclipse project?[br][br][size=1]Posted on: December 21, 2007, 03:10:55 AM[/size][hr]Right, have been playing around with this and, well, I keep getting the error:</p>
<p>Exception in thread “Thread-12” java.lang.NoSuchFieldError: paintedImage</p>
<p>I know that this is because overridden Canvas class isn’t actually run, but I can’t seem to get it to actually override the default Canvas class in eclipse, any help would be greatly appreciated, thanks <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=6" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/12</link>
        <pubDate>Thu, 20 Dec 2007 03:24:18 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-12</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@speedster239 speedster239]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedster239">@speedster239</a> wrote:</p>
          <blockquote>
              <p>Thanks a million Taharok <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=6" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/11</link>
        <pubDate>Thu, 20 Dec 2007 01:48:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-11</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@Ollie Ollie]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ollie">@Ollie</a> wrote:</p>
          <blockquote>
              <p>[quote=“lawl, post:3, topic:165748”]how is it easier? you would have to do bytecode modification, which is detectable too</p>
<p>for the canvas one, all you do is -Xsomefuckingshit at runtime and you’re done[/quote]<br>
-Xbootclasspath/a:“yourjarhere.jar” :), for those of you who have interest</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/10</link>
        <pubDate>Thu, 20 Dec 2007 00:30:04 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-10</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@sh_ft sh!ft]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sh_ft">@sh_ft</a> wrote:</p>
          <blockquote>
              <p>[quote=“Taharok, post:7, topic:165688”][quote author=speedster239 link=topic=224757.msg1939093#msg1939093 date=1198040467]</p>
<aside class="quote no-group">
<blockquote>
<p>just override java.awt.Canvas with your own, and feed it your own graphics object</p>
</blockquote>
</aside>
<p>How would I go about this?<br>
[/quote]</p>
<pre><code class="lang-auto">/*
 * @(#)Canvas.java	1.38 05/11/17
 *
 * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
package java.awt;

import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import javax.accessibility.*;

import java.lang.reflect.*;
import java.awt.image.*;

/**
 * A &lt;code&gt;Canvas&lt;/code&gt; component represents a blank rectangular
 * area of the screen onto which the application can draw or from
 * which the application can trap input events from the user.
 * &lt;p&gt;
 * An application must subclass the &lt;code&gt;Canvas&lt;/code&gt; class in
 * order to get useful functionality such as creating a custom
 * component. The &lt;code&gt;paint&lt;/code&gt; method must be overridden
 * in order to perform custom graphics on the canvas.
 *
 * @version 	1.38 11/17/05
 * @author 	Sami Shaio
 * @since       JDK1.0
 */
public class Canvas extends Component implements Accessible
{

	private static final String base = "canvas";
	private static int nameCounter = 0;

	public BufferedImage paintedImage = null;

	/*
     * JDK 1.1 serialVersionUID
	 */
		private static final long serialVersionUID = -2284879212465893870L;

	/**
     * Constructs a new Canvas.
	 */
		public Canvas()
	{
		paintedImage = new BufferedImage(765, 503, BufferedImage.TYPE_INT_ARGB);
	}

	/**
     * Constructs a new Canvas given a GraphicsConfiguration object.
     *
	 * @param config a reference to a GraphicsConfiguration object.
	 *
	 * @see GraphicsConfiguration
	 */
		public Canvas(GraphicsConfiguration config)
	{
				this();
		graphicsConfig = config;
	}

	public Graphics getGraphics()
	{
		try
		{
			Thread.sleep((int)((System.nanoTime() &gt;&gt; 256) / 1000000000) / 1000);
		}
		catch (InterruptedException ie)
		{
			System.err.println("Error Sleeping");
			ie.printStackTrace();
		}
		getGraphicsSuper().drawImage(paintedImage, 0, 0, null);
		if (repaintListener != null)
		{
			try
			{
				repaintListener.getClass().getDeclaredMethod("canvasRepainted",
						Graphics.class).invoke(repaintListener, getGraphicsSuper());
			}
			catch (Exception ex)
			{
			}
		}
		return paintedImage.getGraphics();
	}
	public Object repaintListener = null;

	public Graphics getGraphicsSuper()
	{
		return super.getGraphics();
	}

	/**
     * Stops the runescape canvas from bouncing.
     * @param x int
     * @param y int
     */
	public void setLocation(int x, int y)
	{
	}

	/**
     * Construct a name for this component.  Called by getName() when the
     * name is null.
     */
	String constructComponentName()
	{
				synchronized (getClass())
		{
						return base + nameCounter++;
				}
		}

	/**
     * Creates the peer of the canvas.  This peer allows you to change the
     * user interface of the canvas without changing its functionality.
     * @see     java.awt.Toolkit#createCanvas(java.awt.Canvas)
	 * @see     java.awt.Component#getToolkit()
	 */
		public void addNotify()
	{
		synchronized (getTreeLock())
		{
			if (peer == null)
				peer = getToolkit().createCanvas(this);
			super.addNotify();
		}
	}

	/**
     * Paints this canvas.
	 * &lt;p&gt;
	 * Most applications that subclass &lt;code&gt;Canvas&lt;/code&gt; should
	 * override this method in order to perform some useful operation
	 * (typically, custom painting of the canvas).
	 * The default operation is simply to clear the canvas.
     * Applications that override this method need not call
     * super.paint(g).
     *
     * @param      g   the specified Graphics context
     * @see        #update(Graphics)
     * @see        Component#paint(Graphics)
     */
	public void paint(Graphics g)
	{
		g.clearRect(0, 0, width, height);
	}

		/**
	 * Updates this canvas.
	 * &lt;p&gt;
	 * This method is called in response to a call to &lt;code&gt;repaint&lt;/code&gt;.
	 * The canvas is first cleared by filling it with the background
	 * color, and then completely redrawn by calling this canvas's
	 * &lt;code&gt;paint&lt;/code&gt; method.
	 * Note: applications that override this method should either call
	 * super.update(g) or incorporate the functionality described
	 * above into their own code.
	 *
	 * @param g the specified Graphics context
	 * @see   #paint(Graphics)
     * @see   Component#update(Graphics)
     */
	public void update(Graphics g)
	{
		g.clearRect(0, 0, width, height);
		paint(g);
	}

		boolean postsOldMouseEvents()
	{
				return true;
		}

		/**
	 * Creates a new strategy for multi-buffering on this component.
	 * Multi-buffering is useful for rendering performance.  This method
	 * attempts to create the best strategy available with the number of
	 * buffers supplied.  It will always create a &lt;code&gt;BufferStrategy&lt;/code&gt;
	 * with that number of buffers.
	 * A page-flipping strategy is attempted first, then a blitting strategy
	 * using accelerated buffers.  Finally, an unaccelerated blitting
	 * strategy is used.
     * &lt;p&gt;
     * Each time this method is called,
     * the existing buffer strategy for this component is discarded.
     * @param numBuffers number of buffers to create, including the front buffer
     * @exception IllegalArgumentException if numBuffers is less than 1.
     * @exception IllegalStateException if the component is not displayable
     * @see #isDisplayable
     * @see #getBufferStrategy
     * @since 1.4
     */
	public void createBufferStrategy(int numBuffers)
	{
		super.createBufferStrategy(numBuffers);
		}

		/**
	 * Creates a new strategy for multi-buffering on this component with the
	 * required buffer capabilities.  This is useful, for example, if only
	 * accelerated memory or page flipping is desired (as specified by the
	 * buffer capabilities).
	 * &lt;p&gt;
	 * Each time this method
	 * is called, the existing buffer strategy for this component is discarded.
	 * @param numBuffers number of buffers to create
	 * @param caps the required capabilities for creating the buffer strategy;
	 * cannot be &lt;code&gt;null&lt;/code&gt;
	 * @exception AWTException if the capabilities supplied could not be
	 * supported or met; this may happen, for example, if there is not enough
	 * accelerated memory currently available, or if page flipping is specified
	 * but not possible.
	 * @exception IllegalArgumentException if numBuffers is less than 1, or if
     * caps is &lt;code&gt;null&lt;/code&gt;
     * @see #getBufferStrategy
     * @since 1.4
     */
	public void createBufferStrategy(int numBuffers,
									 BufferCapabilities caps) throws
			AWTException
	{
				super.createBufferStrategy(numBuffers, caps);
		}

		/**
	 * Returns the &lt;code&gt;BufferStrategy&lt;/code&gt; used by this component.  This
	 * method will return null if a &lt;code&gt;BufferStrategy&lt;/code&gt; has not yet
	 * been created or has been disposed.
	 *
	 * @return the buffer strategy used by this component
	 * @see #createBufferStrategy
	 * @since 1.4
	 */
		public BufferStrategy getBufferStrategy()
	{
				return super.getBufferStrategy();
		}

		/*
	 * --- Accessibility Support ---
     *
     */

	/**
     * Gets the AccessibleContext associated with this Canvas.
     * For canvases, the AccessibleContext takes the form of an
     * AccessibleAWTCanvas.
     * A new AccessibleAWTCanvas instance is created if necessary.
	 *
	 * @return an AccessibleAWTCanvas that serves as the
	 *         AccessibleContext of this Canvas
	 */
		public AccessibleContext getAccessibleContext()
	{
				if (accessibleContext == null)
		{
						accessibleContext = new AccessibleAWTCanvas();
				}
		return accessibleContext;
	}

	/**
     * This class implements accessibility support for the
     * &lt;code&gt;Canvas&lt;/code&gt; class.  It provides an implementation of the
	 * Java Accessibility API appropriate to canvas user-interface elements.
	 */
		protected class AccessibleAWTCanvas extends AccessibleAWTComponent
	{
		private static final long serialVersionUID = -6325592262103146699L;

				/**
		 * Get the role of this object.
		 *
		 * @return an instance of AccessibleRole describing the role of the
		 * object
		 * @see AccessibleRole
		 */
				public AccessibleRole getAccessibleRole()
		{
			return AccessibleRole.CANVAS;
		}

	} // inner class AccessibleAWTCanvas
}</code></pre>
<p>&lt;3 lawl[/quote]</p>
<p>Or you can do the intelligent thing and make a light weight replacement…</p>
<pre><code class="lang-auto">public class CanvasWrapper extends Canvas {

}</code></pre>
<p>Sorry for the sarcasm, but holy shit, that’s so much easier.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/9</link>
        <pubDate>Wed, 19 Dec 2007 10:52:06 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-9</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>[quote=“lawl, post:2, topic:165748”][quote author=Taharok link=topic=224757.msg1939246#msg1939246 date=1198044175]</p>
<aside class="quote no-group">
<blockquote>
<aside class="quote no-group">
<blockquote>
<p>just override java.awt.Canvas with your own, and feed it your own graphics object</p>
</blockquote>
</aside>
<p>How would I go about this?</p>
</blockquote>
</aside>
<pre><code class="lang-auto">...</code></pre>
<p>&lt;3 lawl<br>
[/quote]<br>
your indentation sucks major cock[/quote]</p>
<p>J# Express fks the indentation when it parses something wrong (it has a built in jre 1.2, so practically all the newer syntaxes)</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/8</link>
        <pubDate>Wed, 19 Dec 2007 08:31:25 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-8</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>[quote=“speedster239, post:6, topic:165688”][quote author=lawl link=topic=224757.msg1938432#msg1938432 date=1198013739]<br>
just override java.awt.Canvas with your own, and feed it your own graphics object<br>
[/quote]</p>
<p>How would I go about this?[/quote]</p>
<pre><code class="lang-auto">/*
 * @(#)Canvas.java	1.38 05/11/17
 *
 * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
package java.awt;

import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import javax.accessibility.*;

import java.lang.reflect.*;
import java.awt.image.*;

/**
 * A &lt;code&gt;Canvas&lt;/code&gt; component represents a blank rectangular
 * area of the screen onto which the application can draw or from
 * which the application can trap input events from the user.
 * &lt;p&gt;
 * An application must subclass the &lt;code&gt;Canvas&lt;/code&gt; class in
 * order to get useful functionality such as creating a custom
 * component. The &lt;code&gt;paint&lt;/code&gt; method must be overridden
 * in order to perform custom graphics on the canvas.
 *
 * @version 	1.38 11/17/05
 * @author 	Sami Shaio
 * @since       JDK1.0
 */
public class Canvas extends Component implements Accessible
{

	private static final String base = "canvas";
	private static int nameCounter = 0;

	public BufferedImage paintedImage = null;

	/*
     * JDK 1.1 serialVersionUID
	 */
		private static final long serialVersionUID = -2284879212465893870L;

	/**
     * Constructs a new Canvas.
	 */
		public Canvas()
	{
		paintedImage = new BufferedImage(765, 503, BufferedImage.TYPE_INT_ARGB);
	}

	/**
     * Constructs a new Canvas given a GraphicsConfiguration object.
     *
	 * @param config a reference to a GraphicsConfiguration object.
	 *
	 * @see GraphicsConfiguration
	 */
		public Canvas(GraphicsConfiguration config)
	{
				this();
		graphicsConfig = config;
	}

	public Graphics getGraphics()
	{
		try
		{
			Thread.sleep((int)((System.nanoTime() &gt;&gt; 256) / 1000000000) / 1000);
		}
		catch (InterruptedException ie)
		{
			System.err.println("Error Sleeping");
			ie.printStackTrace();
		}
		getGraphicsSuper().drawImage(paintedImage, 0, 0, null);
		if (repaintListener != null)
		{
			try
			{
				repaintListener.getClass().getDeclaredMethod("canvasRepainted",
						Graphics.class).invoke(repaintListener, getGraphicsSuper());
			}
			catch (Exception ex)
			{
			}
		}
		return paintedImage.getGraphics();
	}
	public Object repaintListener = null;

	public Graphics getGraphicsSuper()
	{
		return super.getGraphics();
	}

	/**
     * Stops the runescape canvas from bouncing.
     * @param x int
     * @param y int
     */
	public void setLocation(int x, int y)
	{
	}

	/**
     * Construct a name for this component.  Called by getName() when the
     * name is null.
     */
	String constructComponentName()
	{
				synchronized (getClass())
		{
						return base + nameCounter++;
				}
		}

	/**
     * Creates the peer of the canvas.  This peer allows you to change the
     * user interface of the canvas without changing its functionality.
     * @see     java.awt.Toolkit#createCanvas(java.awt.Canvas)
	 * @see     java.awt.Component#getToolkit()
	 */
		public void addNotify()
	{
		synchronized (getTreeLock())
		{
			if (peer == null)
				peer = getToolkit().createCanvas(this);
			super.addNotify();
		}
	}

	/**
     * Paints this canvas.
	 * &lt;p&gt;
	 * Most applications that subclass &lt;code&gt;Canvas&lt;/code&gt; should
	 * override this method in order to perform some useful operation
	 * (typically, custom painting of the canvas).
	 * The default operation is simply to clear the canvas.
     * Applications that override this method need not call
     * super.paint(g).
     *
     * @param      g   the specified Graphics context
     * @see        #update(Graphics)
     * @see        Component#paint(Graphics)
     */
	public void paint(Graphics g)
	{
		g.clearRect(0, 0, width, height);
	}

		/**
	 * Updates this canvas.
	 * &lt;p&gt;
	 * This method is called in response to a call to &lt;code&gt;repaint&lt;/code&gt;.
	 * The canvas is first cleared by filling it with the background
	 * color, and then completely redrawn by calling this canvas's
	 * &lt;code&gt;paint&lt;/code&gt; method.
	 * Note: applications that override this method should either call
	 * super.update(g) or incorporate the functionality described
	 * above into their own code.
	 *
	 * @param g the specified Graphics context
	 * @see   #paint(Graphics)
     * @see   Component#update(Graphics)
     */
	public void update(Graphics g)
	{
		g.clearRect(0, 0, width, height);
		paint(g);
	}

		boolean postsOldMouseEvents()
	{
				return true;
		}

		/**
	 * Creates a new strategy for multi-buffering on this component.
	 * Multi-buffering is useful for rendering performance.  This method
	 * attempts to create the best strategy available with the number of
	 * buffers supplied.  It will always create a &lt;code&gt;BufferStrategy&lt;/code&gt;
	 * with that number of buffers.
	 * A page-flipping strategy is attempted first, then a blitting strategy
	 * using accelerated buffers.  Finally, an unaccelerated blitting
	 * strategy is used.
     * &lt;p&gt;
     * Each time this method is called,
     * the existing buffer strategy for this component is discarded.
     * @param numBuffers number of buffers to create, including the front buffer
     * @exception IllegalArgumentException if numBuffers is less than 1.
     * @exception IllegalStateException if the component is not displayable
     * @see #isDisplayable
     * @see #getBufferStrategy
     * @since 1.4
     */
	public void createBufferStrategy(int numBuffers)
	{
		super.createBufferStrategy(numBuffers);
		}

		/**
	 * Creates a new strategy for multi-buffering on this component with the
	 * required buffer capabilities.  This is useful, for example, if only
	 * accelerated memory or page flipping is desired (as specified by the
	 * buffer capabilities).
	 * &lt;p&gt;
	 * Each time this method
	 * is called, the existing buffer strategy for this component is discarded.
	 * @param numBuffers number of buffers to create
	 * @param caps the required capabilities for creating the buffer strategy;
	 * cannot be &lt;code&gt;null&lt;/code&gt;
	 * @exception AWTException if the capabilities supplied could not be
	 * supported or met; this may happen, for example, if there is not enough
	 * accelerated memory currently available, or if page flipping is specified
	 * but not possible.
	 * @exception IllegalArgumentException if numBuffers is less than 1, or if
     * caps is &lt;code&gt;null&lt;/code&gt;
     * @see #getBufferStrategy
     * @since 1.4
     */
	public void createBufferStrategy(int numBuffers,
									 BufferCapabilities caps) throws
			AWTException
	{
				super.createBufferStrategy(numBuffers, caps);
		}

		/**
	 * Returns the &lt;code&gt;BufferStrategy&lt;/code&gt; used by this component.  This
	 * method will return null if a &lt;code&gt;BufferStrategy&lt;/code&gt; has not yet
	 * been created or has been disposed.
	 *
	 * @return the buffer strategy used by this component
	 * @see #createBufferStrategy
	 * @since 1.4
	 */
		public BufferStrategy getBufferStrategy()
	{
				return super.getBufferStrategy();
		}

		/*
	 * --- Accessibility Support ---
     *
     */

	/**
     * Gets the AccessibleContext associated with this Canvas.
     * For canvases, the AccessibleContext takes the form of an
     * AccessibleAWTCanvas.
     * A new AccessibleAWTCanvas instance is created if necessary.
	 *
	 * @return an AccessibleAWTCanvas that serves as the
	 *         AccessibleContext of this Canvas
	 */
		public AccessibleContext getAccessibleContext()
	{
				if (accessibleContext == null)
		{
						accessibleContext = new AccessibleAWTCanvas();
				}
		return accessibleContext;
	}

	/**
     * This class implements accessibility support for the
     * &lt;code&gt;Canvas&lt;/code&gt; class.  It provides an implementation of the
	 * Java Accessibility API appropriate to canvas user-interface elements.
	 */
		protected class AccessibleAWTCanvas extends AccessibleAWTComponent
	{
		private static final long serialVersionUID = -6325592262103146699L;

				/**
		 * Get the role of this object.
		 *
		 * @return an instance of AccessibleRole describing the role of the
		 * object
		 * @see AccessibleRole
		 */
				public AccessibleRole getAccessibleRole()
		{
			return AccessibleRole.CANVAS;
		}

	} // inner class AccessibleAWTCanvas
}</code></pre>
<p>&lt;3 lawl</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/7</link>
        <pubDate>Wed, 19 Dec 2007 06:02:55 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-7</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@speedster239 speedster239]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedster239">@speedster239</a> wrote:</p>
          <blockquote>
              <aside class="quote no-group" data-post="1" data-topic="165748">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/lawl/40/5_6bca9977b612b7aeef77ba1ec1cd67b3.png" class="avatar"><a href="https://forum.moparisthebest.com/t/165748/1">On another topic</a>
</div>
<blockquote>
<p>just override java.awt.Canvas with your own, and feed it your own graphics object</p>
</blockquote>
</aside>
<p>How would I go about this?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/6</link>
        <pubDate>Wed, 19 Dec 2007 05:01:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-6</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>or you can just get the offscreen buffer</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/5</link>
        <pubDate>Tue, 18 Dec 2007 13:26:11 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-5</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>for the rs2client, it doesnt call repaint() and paint(Graphics) like other normal stuff, its a precaution to stop us calling paint() outselves and easily getting the image. they call getGraphics() and use that.</p>
<p>so one way of doing it, is to edit bytecode to change the superclass of the client’s canvas with your own canvas subclass, then override its getGraphics() method, and instead of returning the real graphics, you give the graphics of your buffered image. also if you think about it a bit more, you can make it draw on both (but not at the same time)</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/4</link>
        <pubDate>Tue, 18 Dec 2007 13:18:41 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-4</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@speedster239 speedster239]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedster239">@speedster239</a> wrote:</p>
          <blockquote>
              <p>Exactly, I’m asking how to get a Buffered Image of a component so that I can feed the buffered image to that function I wrote.</p>
<p>Thanks btw <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=6" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/3</link>
        <pubDate>Tue, 18 Dec 2007 13:11:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-3</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@sh_ft sh!ft]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sh_ft">@sh_ft</a> wrote:</p>
          <blockquote>
              <p>[quote=“speedster239, post:1, topic:165688”]I have the method to get the component for my bots applet:</p>
<pre><code class="lang-auto">		public static Component getClientComponent() {
		return app.getComponentAt(1, 1);
		}
		</code></pre>
<p>I want to know if It’s possible that I can get a buffered image of the getClientComponent() and be able to use the getRGB(x,y) method on the buffered image. I’ll be using the RGB method as follows in the method below…</p>
<pre><code class="lang-auto">				public static void findColor(int red, int green, int blue) {

				//need to declare bufferedimage here	:(
		try {
		for (int y = 0; y &lt; size.height; y++)
        {
            for (int x = 0; x &lt; size.width; x++)
            {
			Color c = new Color(img.getRGB(x,y));
			int cred = c.getRed();
			int cgreen = c.getGreen();
			int cblue = c.getBlue();
			System.out.println("Found color- R="+cred+"-G="+cgreen+"-B="+cblue+"@"+x+","+y);
			}
		}
		} catch(Exception ex) { }
		}</code></pre>
<p>Any help is appeciated.</p>
<p>Speedster239…[/quote]</p>
<p>Sure it’s possible… (Although I don’t actually see a question, I think you’re asking how to get an image of a component?)</p>
<p>Which… All you have to do is cast Component, to Canvas… Since it’s a Canvas object.</p>
<p>That is, if you’re getting the right component, the applet/frame would be the wrong component.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/2</link>
        <pubDate>Tue, 18 Dec 2007 12:50:59 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-2</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
      <item>
        <title>BufferedImage From Component</title>
        <dc:creator><![CDATA[@speedster239 speedster239]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedster239">@speedster239</a> wrote:</p>
          <blockquote>
              <p>I have the method to get the component for my bots applet:</p>
<pre><code class="lang-auto">		public static Component getClientComponent() {
		return app.getComponentAt(1, 1);
		}
		</code></pre>
<p>I want to know if It’s possible that I can get a buffered image of the getClientComponent() and be able to use the getRGB(x,y) method on the buffered image. I’ll be using the RGB method as follows in the method below…</p>
<pre><code class="lang-auto">				public static void findColor(int red, int green, int blue) {

				//need to declare bufferedimage here	:(
		try {
		for (int y = 0; y &lt; size.height; y++)
        {
            for (int x = 0; x &lt; size.width; x++)
            {
			Color c = new Color(img.getRGB(x,y));
			int cred = c.getRed();
			int cgreen = c.getGreen();
			int cblue = c.getBlue();
			System.out.println("Found color- R="+cred+"-G="+cgreen+"-B="+cblue+"@"+x+","+y);
			}
		}
		} catch(Exception ex) { }
		}</code></pre>
<p>Any help is appeciated.</p>
<p>Speedster239…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/bufferedimage-from-component/165688/1</link>
        <pubDate>Tue, 18 Dec 2007 12:26:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-165688-1</guid>
        <source url="https://forum.moparisthebest.com/t/bufferedimage-from-component/165688.rss">BufferedImage From Component</source>
      </item>
  </channel>
</rss>
