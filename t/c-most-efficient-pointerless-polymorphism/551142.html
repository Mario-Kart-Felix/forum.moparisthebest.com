<!DOCTYPE html>
<html lang="en-US">
  
<!-- Mirrored from forum.moparisthebest.com/t/c-most-efficient-pointerless-polymorphism/551142 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>[C++] Most Efficient Pointerless Polymorphism? - General Programming - moparisthebest.com</title>
    <meta name="description" content="So I know in C++, polymorphism has to be done with pointers. When you have an is-a relationship, variables of the parent type need to be pointers, then children (or parents) have to be allocated on the heap if they are t&amp;hellip;">
    <meta name="generator" content="Discourse 2.3.2 - https://github.com/discourse/discourse version c587df7e2a03c2962f4c8cefd6f03969bb87d525">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/1/1f0dc167bcf798bdbd70b03bf0fd1bc836e54e1a_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff_2_180x180.png">
<meta name="theme-color" content="#0088cc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="551142.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.moparisthebest.com","potentialAction":{"@type":"SearchAction","target":"https://forum.moparisthebest.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="moparisthebest.com Search">

      <link href="../../stylesheets/desktop_1_ec9f75e3d0b2a904642ce53663991837b70cda3334fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="../../stylesheets/desktop_theme_2_6707e7ee46ac9f2f0510c29ddd10e8f6ce21c1ae34fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;[C++] Most Efficient Pointerless Polymorphism?&#39;" href="551142.rss" />
  <meta property="og:site_name" content="moparisthebest.com" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:url" content="https://forum.moparisthebest.com/t/c-most-efficient-pointerless-polymorphism/551142" />
<meta name="twitter:url" content="https://forum.moparisthebest.com/t/c-most-efficient-pointerless-polymorphism/551142" />
<meta property="og:title" content="[C++] Most Efficient Pointerless Polymorphism?" />
<meta name="twitter:title" content="[C++] Most Efficient Pointerless Polymorphism?" />
<meta property="og:description" content="So I know in C++, polymorphism has to be done with pointers. When you have an is-a relationship, variables of the parent type need to be pointers, then children (or parents) have to be allocated on the heap if they are to be kept outside the function. However, allocation on the heap for tons of objects is very costly, and when we’re in the realm of thousands upon thousands of objects needing to be allocated and deallocated frequently, it becomes a poor choice for performance.  However, I am in n..." />
<meta name="twitter:description" content="So I know in C++, polymorphism has to be done with pointers. When you have an is-a relationship, variables of the parent type need to be pointers, then children (or parents) have to be allocated on the heap if they are to be kept outside the function. However, allocation on the heap for tons of objects is very costly, and when we’re in the realm of thousands upon thousands of objects needing to be allocated and deallocated frequently, it becomes a poor choice for performance.  However, I am in n..." />
<meta property="article:published_time" content="2015-04-17T23:15:11+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html">
          <img src="../../uploads/default/original/2X/3/37bba8fb3bd06c372ab54fa72ec38bf9f8f40b37.gif" alt="moparisthebest.com" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1 class="crawler-topic-title">
  <a href="551142.html">[C++] Most Efficient Pointerless Polymorphism?</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/general-programming.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>General Programming</span>
      </a>
    </div>
</div>





  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Lin.html'><span itemprop='name'>Lin</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-04-17T23:15:11Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:04:02Z' class='post-time'>
              August 4, 2016,  3:04pm
            </time>
        <span itemprop='position'>#1</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>So I know in C++, polymorphism has to be done with pointers. When you have an is-a relationship, variables of the parent type need to be pointers, then children (or parents) have to be allocated on the heap if they are to be kept outside the function. However, allocation on the heap for tons of objects is very costly, and when we’re in the realm of thousands upon thousands of objects needing to be allocated and deallocated frequently, it becomes a poor choice for performance.</p>
<p>However, I am in need of polymorphism. I need a way to store parent objects allocated on the stack that can also be child objects. Obviously because of how C++ works, this would compile but the parent’s functions and variables would be used all the time and there are no child objects.</p>
<p>Possible ideas:</p>
<p><span class="bbcode-b">1.</span> Store what type the object is inside of the object class and adjust the functions accordingly. Ugly, but it would work. Also it would require storing a pointer to additional data that extends a base class “Data”, and here, general polymorphism would be allowed. This is an efficient solution because static casts don’t cost anything, but again, it’s pretty ugly. The other downside is it requires allocation on the heap and making copies of the object containing the additional data means additional cleanup is necessary when the class containing the parent objects is terminated.</p>
<p><span class="bbcode-b">2.</span> Borrowing similar ideas to <span class="hashtag">#1</span>, make the “Data” class contain a maximum of X bytes and use reinterpret_cast to determine <span class="bbcode-i">how</span> the data is interpreted, then use a vector to store the data. This wouldn’t require any heap management, but god is it ugly. Plus I really dislike the minimum bytes allocated when only an extra byte might be needed.</p>
<p>Any suggestions? Ideally, the code would be clean and elegant, the method wouldn’t require heap management or individual allocations on the heap, no dynamic casting, and there would be no minimum size required for the additional data.</p>
<p>Thank you. Any input is greatly appreciated. <img src="../../images/emoji/twitter/slight_smileae52.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>~Lin</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/iKilem.html'><span itemprop='name'>iKilem</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-04-23T18:26:57Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:04:44Z' class='post-time'>
              August 4, 2016,  3:04pm
            </time>
        <span itemprop='position'>#2</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Depending on what you want to do exactly, you can use template classes for polymorphism.</p>
<pre><code class="lang-auto">template&lt;class T&gt;
class Base {
public:
    void foo() {
        static_cast&lt;T *&gt;(this)-&gt;foo();
    }
};

class Derived : public Base&lt;Derived&gt; {
public:
    void foo();
};</code></pre>
<p>Dubbed the curiously reccuring template pattern (CRTP). Use as you would any other template class.</p>
<p>As a side note, maybe virtual classes aren’t as bad as you think. Before considering alternatives, are you sure they’re a concern for performance? Those awful allocations/deallocations and indirections might not be so bad, especially if the compiler can optimise them away, which is the case if it can determine the derived type at compile-time. It’s something to consider on a per-application basis.</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Lin.html'><span itemprop='name'>Lin</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-04-24T04:28:36Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:04:47Z' class='post-time'>
              August 4, 2016,  3:04pm
            </time>
        <span itemprop='position'>#3</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=“iKilem, post:2, topic:551142”]Depending on what you want to do exactly, you can use template classes for polymorphism.</p>
<pre><code class="lang-auto">template&lt;class T&gt;
class Base {
public:
    void foo() {
        static_cast&lt;T *&gt;(this)-&gt;foo();
    }
};

class Derived : public Base&lt;Derived&gt; {
public:
    void foo();
};</code></pre>
<p>Dubbed the curiously reccuring template pattern (CRTP). Use as you would any other template class.</p>
<p>As a side note, maybe virtual classes aren’t as bad as you think. Before considering alternatives, are you sure they’re a concern for performance? Those awful allocations/deallocations and indirections might not be so bad, especially if the compiler can optimise them away, which is the case if it can determine the derived type at compile-time. It’s something to consider on a per-application basis.[/quote]Holy crap that’s brilliant, and base class doesn’t even have a virtual function pointer table. That looks like it’s definitely the answer! And yes, in my game, each chunk would require at least 4096 allocations (16^3) when created, 4096 frees when deleted, and the data will be fragmented so it’s bad for cache performance. In practice, we’re looking at 961 * 4096 allocations and frees with up to * 5 depending on how quickly the player moves. 19681280 allocations, 19681280 frees. I don’t think that’s very practical compared to 961 * 5. Thank you for the input, it will definitely help <img src="../../images/emoji/twitter/slight_smileae52.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/lawl.html'><span itemprop='name'>lawl</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-04-30T03:58:17Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:05:38Z' class='post-time'>
              August 4, 2016,  3:05pm
            </time>
        <span itemprop='position'>#4</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>if you’re going to do a lot of allocations at once that will be freed together, consider using an arena / memory pool (malloc one huge chunk)</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/T41.html'><span itemprop='name'>T41</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-01T03:09:57Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:05:46Z' class='post-time'>
              August 4, 2016,  3:05pm
            </time>
        <span itemprop='position'>#5</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>all about that scrap buffer bro</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Lin.html'><span itemprop='name'>Lin</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-08T00:11:40Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:06:54Z' class='post-time'>
              August 4, 2016,  3:06pm
            </time>
        <span itemprop='position'>#6</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=“lawl, post:4, topic:551142”]if you’re going to do a lot of allocations at once that will be freed together, consider using an arena / memory pool (malloc one huge chunk)[/quote]I looked into this and you’re right, this is definitely the best option. However, I was thinking that since I would know the types to be allocated ahead of time, I could store a pool for each type, and if I’m doing that, I could just use a vector for each type. Not sure how good cache performance would be, but it would guaranteed be way faster than using the default new/delete. I figured I could count how many objects would be needed to load a part of the game, reserve that many elements, and then only expand it when necessary so world loading is optimal in terms of memory usage and only the first modification would be relatively costly (although hardly).</p>
<p>So in short, something like this:</p>
<p>[code=cpp]class Parent { … };<br>
class ChildA : public Parent { … };<br>
class ChildB : public Parent { … };</p>
<p>…</p>
<p>class Block<br>
{<br>
Parent* additional_data;<br>
}</p>
<p>…</p>
<p>std::vector child_a_data;<br>
std::vector child_b_data;</p>
<p>…</p>
<p>m_blocks[10].additional_data = &amp;child_a_data[4];<br>
m_blocks[20].additional_data = &amp;child_b_data[7];[/code]</p>
<p>I’m not <span class="bbcode-i">entirely</span> sure if this would work, but I really see no reason why it shouldn’t. I’ll try it out and report my findings. <img src="../../images/emoji/twitter/slight_smileae52.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/davidi2.html'><span itemprop='name'>davidi2</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-08T02:20:04Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:06:55Z' class='post-time'>
              August 4, 2016,  3:06pm
            </time>
        <span itemprop='position'>#7</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>more like POINTLESS polymorphism amirite? XD</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Lin.html'><span itemprop='name'>Lin</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-08T02:38:56Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:06:55Z' class='post-time'>
              August 4, 2016,  3:06pm
            </time>
        <span itemprop='position'>#8</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=“Davidi2, post:7, topic:551142”]more like POINTLESS polymorphism amirite? XD[/quote]Oh boy <img src="../../images/emoji/twitter/stuck_out_tongueae52.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
<p>I implemented the vector idea and shut down times are <span class="bbcode-b">significantly</span> faster. From 10+ seconds in the debug build to about a second and even less in the release build.</p>
<p>Inb4 don’t benchmark on debug builds - I make sure the game runs more than just fine on the debug build so I have at least <span class="bbcode-i">some</span> hope of the game running on low-end hardware. I know this isn’t valid, since the end-user bottlenecks will be because of memory and the GPU that won’t (I think) be affected in most instances by compiler optimization, and it’s a stupid idea to optimize for debug builds since optimized final code could throw hand-made optimizations away, but it’s a preference that I don’t think does more good than harm.</p>
<p><span class="bbcode-b">EDIT: </span>Ah I just realized the vector idea won’t work when the vectors get resized because the pointers are invalidated. Time to think of something else.</p>
<p><span class="bbcode-b">EDIT 2: </span>Just decided to go with a memory pool and performance is great with the vector problem fixed.</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/_s11.html'><span itemprop='name'>_s11</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-11T13:25:07Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:07:30Z' class='post-time'>
              August 4, 2016,  3:07pm
            </time>
        <span itemprop='position'>#9</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>holy shit c++ hurts my brain</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/relmitos.html'><span itemprop='name'>relmitos</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-11T17:16:17Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:07:33Z' class='post-time'>
              August 4, 2016,  3:07pm
            </time>
        <span itemprop='position'>#10</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Whats up with microsoft and stds.</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/bowserjr2.html'><span itemprop='name'>bowserjr2</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-11T17:45:20Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:07:33Z' class='post-time'>
              August 4, 2016,  3:07pm
            </time>
        <span itemprop='position'>#11</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <aside class="quote" data-post="10" data-topic="551142">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="../../letter_avatar/relmitos/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> relmitos:</div>
<blockquote>
<p>Whats up with microsoft and stds.</p>
</blockquote>
</aside>
<p>STanDard.</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/mod_taharok.html'><span itemprop='name'>mod_taharok</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-25T04:11:01Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:08:46Z' class='post-time'>
              August 4, 2016,  3:08pm
            </time>
        <span itemprop='position'>#12</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Lin, if the vector isn’t going to be resized once you populate it, you could just use std::vector::reserve to guarantee it won’t expand on a push_back, then all pointers to data within it will not be invalidated. This is a more efficient way to populate a vector, anyway.</p>
<p>I’m not sure I really understand the original problem, though.</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Lin.html'><span itemprop='name'>Lin</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2015-05-25T04:22:21Z'>
            <time itemprop='dateModified' datetime='2016-08-04T15:08:46Z' class='post-time'>
              August 4, 2016,  3:08pm
            </time>
        <span itemprop='position'>#13</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=“Taharok, post:12, topic:551142”]Lin, if the vector isn’t going to be resized once you populate it, you could just use std::vector::reserve to guarantee it won’t expand on a push_back, then all pointers to data within it will not be invalidated. This is a more efficient way to populate a vector, anyway.</p>
<p>I’m not sure I really understand the original problem, though.[/quote]Yep, that’s what I did and the performance was great but the vector did sometimes get resized so it was not a viable option <img src="../../images/emoji/twitter/slight_smileae52.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"> The original problem was basically how to have child classes contain additional members and assign them to a group of parents without using new. I tried other standard library containers, but even ones built to expand and keep pointers were as slow as using new because the amount of space reserved was <span class="bbcode-i">very</span> limited (I think something like 16 bytes but it’s been too long so I don’t remember). A memory pool solved this issue just fine.</p>
      </div>

      <meta itemprop='headline' content='[C++] Most Efficient Pointerless Polymorphism?'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav' itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <ul>
        <li itemprop="name"><a href='../../index.html' itemprop="url">Home </a></li>
        <li itemprop="name"><a href='../../categories.html' itemprop="url">Categories </a></li>
        <li itemprop="name"><a href='../../guidelines.html' itemprop="url">FAQ/Guidelines </a></li>
        <li itemprop="name"><a href='../../tos.html' itemprop="url">Terms of Service </a></li>
        <li itemprop="name"><a href='../../privacy.html' itemprop="url">Privacy Policy </a></li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
  </body>
  

<!-- Mirrored from forum.moparisthebest.com/t/c-most-efficient-pointerless-polymorphism/551142 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:34 GMT -->
</html>
