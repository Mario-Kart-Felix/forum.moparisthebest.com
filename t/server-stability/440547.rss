<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Server stability</title>
    <link>https://forum.moparisthebest.com/t/server-stability/440547</link>
    <description>if i servers stability depends on the proccess() method, then how stable would me delta be with this 

[code]	public boolean process() throws NullPointerException {
		if (handleagility.inGnomeAgility() || handleagility.inBarbarianAgility() || handleagility.inPyramidAgility()) { //agility
            followID = 0;
            if (handleagility.isPassing == true)
                    isRunning = false;
            if (absX == handleagility.neededX &amp;&amp; absY == handleagility.neededY) {
                    handleagility.resetAgility();
            }
    } //agility ^
		handlecombat.CalculateMaxHit();
		if (getLevelForXP(playerXP[playerHitpoints]) &lt; playerLevel[playerHitpoints]) {
			if (refillHp == true) {
				if (PrayerAction.rapidHeal) {
					if (System.currentTimeMillis() - lastIncrease &gt;= 7000) {
						playerXP[playerHitpoints] =+ 1;
					} else {
						if (System.currentTimeMillis() - lastIncrease &gt;= 14000) {
							playerXP[playerHitpoints] =+ 1;
						}
					}
				}
			} 
		}
		sendQuest(&quot;@yel@Utopia Points: @gre@&quot;+pkPoints+&quot;&quot;, 7383);
		sendQuest(&quot;@yel@MultiPK Points: @gre@&quot;+multiPkPoints+&quot;&quot;, 7339);
		if (isInWilderness(absX, absY, 2) == true &amp;&amp; WildernessWarning == false &amp;&amp; !multiPK()) {
			resetWalkingQueue();
			sendFrame248(1908, 3213);
			WildernessWarning = true;
		} 
		appendPos();

		if (tradeTimer != 0){
			tradeTimer--;
		}
		if (disconnectedDelay == 1){
			disconnected = true;
		}
		if(!isInWilderness(absX, absY, 1) || !multiPK()){
			//setInterfaceWalkable(-1);
			hasWildySign = false;
		}
		if(isInWilderness == false) {
			outStream.createFrameVarSize(104);
			outStream.writeByteC(3);
			outStream.writeByteA(0);
			outStream.writeString(&quot;null&quot;);
			outStream.endFrameVarSize();
		}
		if(isInWilderness(absX, absY, 1) || multiPK()) {
			outStream.createFrameVarSize(104);
			outStream.writeByteC(3);
			outStream.writeByteA(0);
			outStream.writeString(&quot;Attack&quot;);
			outStream.endFrameVarSize();
		}
		if (System.currentTimeMillis() - lastSave &gt; 120000 &amp;&amp; !inTrade){
			CharacterSave.savegame(true);
			lastSave = System.currentTimeMillis();
		}
		if (System.currentTimeMillis() - lastBookSwitch &gt; 30000 &amp;&amp; switchingBook) {
			setSidebarInterface(6, 18787);
			lastBookSwitch = System.currentTimeMillis();
			switchingBook = false;
		}
		if (System.currentTimeMillis() - offTimer &gt; 6000){
			hitID = 0;
		}
		if(System.currentTimeMillis() - lastSkull &gt;= 1200000 &amp;&amp; isSkulled){
			turnOffHead();
			updateRequired = true;
			appearanceUpdateRequired = true;
			isSkulled = false;
		}
		if (disconnectedDelay &gt; 0) {
			disconnectedDelay--;
		}
		if (spellHitTimer &gt; 0) {
			spellHitTimer -= 1;
		}
		if(poisoned &amp;&amp; System.currentTimeMillis() - poisonDelay &gt; 15000){
			poisonDmg = true;
			applyPoisonToMe();
			poisonDmg = false;
			poisonDelay = System.currentTimeMillis();
		}
		if(System.currentTimeMillis() - lastSpecial &gt; 50000 &amp;&amp; specialAmount &lt; 100){
			specialAmount += 25;
			lastSpecial = System.currentTimeMillis();
			specAttack();
		}
		if (hasMultiSign) {
			frame61(-1);
			hasMultiSign = false;
		} 
		if (isInWilderness(absX, absY, 1) &amp;&amp; !multiPK()) {
				if (!hasWildySign) {
					hasWildySign = true;
					outStream.createFrame(208);
					outStream.writeWordBigEndian_dup(197);
					sendQuest(&quot;Level: &quot; + wildyLevel, 199);
				}
				int level = ((absY - 3520) / 8) + 1;
				if (level != wildyLevel) {
					wildyLevel = level;
					sendQuest(&quot;Level: &quot; + wildyLevel, 199);
				} 
				if(isinsafewild()){
					level = 20;
				}		
				if (level != wildyLevel) {
					if(isinsafewild()){
						sendQuest(&quot;@whi@test&quot;, 199);
					} else {
						wildyLevel = level;
						sendQuest(&quot;Level: &quot; + wildyLevel, 199);
					}
				}
		}
		
		Calendar cal = new GregorianCalendar();
		int day = cal.get(Calendar.DAY_OF_MONTH);
		int month = cal.get(Calendar.MONTH);
		int year = cal.get(Calendar.YEAR);
		int calc = ((year * 10000) + (month * 100) + day);
		playerLastLogin = calc;

		if (System.currentTimeMillis() - statIncrease &gt; 120000) {
			for (int i1 = 0; i1 &lt; playerLevel.length; i1++) {
				if (playerLevel[i1] &lt; getLevelForXP(playerXP[i1])) {
					playerLevel[i1] += 1;
					setSkillLevel(i1, playerLevel[i1], playerXP[i1]);
					NewHP = playerLevel[3];
					for(int rF = 0; rF &lt; 22; rF++)
						refreshSkill(rF);
				} else if (playerLevel[i1] &gt; getLevelForXP(playerXP[i1])) {
					playerLevel[i1] -= 1;
					setSkillLevel(i1, playerLevel[i1], playerXP[i1]);
					NewHP = playerLevel[3];
					for(int rF = 0; rF &lt; 22; rF++)
						refreshSkill(rF);
				}
			}
			statIncrease = System.currentTimeMillis();
		}	
		if(PlayerHandler.getPlayerID(playerName) != playerId){	
			disconnected = true;
		}
		if (inCombat) {
		long current = System.currentTimeMillis();
		if(current - lastCombat &gt;= 10000) {
			inCombat = false;
		}
		}
		if (currentHealth &lt; 1) {
			deathStage = 1;
		}
		if(hitDiff &gt; 0){
			sendQuest(&quot;&quot; + currentHealth, 4016);
		}
		if (NpcDialogue &gt; 0 &amp;&amp; NpcDialogueSend == false) {
			UpdateNPCChat();
		}
		if (isinsafewild()) {
			followID = 0;
		}

	if (followID &gt; 0) {
		FollowHandler.followDirection();
	}
	if (followID2 &gt; 0) {
		followDirection2();
	}	
	
	if (tStage == 1 &amp;&amp; tTime == 0) {
	      setAnimation(1979);
	      lowGFX(392, 0);
	      updateRequired = true;
	      appearanceUpdateRequired = true;
	      tTime = System.currentTimeMillis();
	      tStage = 2;
	    }
	    if (tStage == 2 &amp;&amp; System.currentTimeMillis()-tTime &gt;= 10) {
	      toX = tX;
	      toY = tY;
	      heightLevel = tH;
	      updateRequired = true;
	      appearanceUpdateRequired = true;
	      tStage = 0;
	      tTime = 0;
	      resetAnimation();
	      resetfollowers();
	      closeInterface();
	    }
	    if (tStage == 3 &amp;&amp; tTime2 == 0) {
	      setAnimation(714);
	      updateRequired = true;
	      appearanceUpdateRequired = true;
	      tTime2 = System.currentTimeMillis();
	      tStage = 4;
	    }
	    if (tStage == 4 &amp;&amp; System.currentTimeMillis()-tTime2 &gt;= 10) {
	      specGFX(308);
	      tStage = 5;
	    }
	    if (tStage == 5 &amp;&amp; System.currentTimeMillis()-tTime2 &gt;= 10) {
	      setAnimation(715);
	      toX = tX;
	      toY = tY;
	      heightLevel = tH;
	      updateRequired = true;
	      appearanceUpdateRequired = true;
	      tStage = 0;
	      tTime = 0;
	      resetAnimation();
	      resetfollowers();
	      closeInterface();
	    }


    playerLevel[24] = total;
    for (int d = 0; d &lt;= 10; d++) {
        if (total &gt;= ServerConstants.ranks[d]) {
            if (d == 0) {
            	ServerConstants.ranks[d] = total;
            	ServerConstants.rankPpl[d] = playerName;
            } else if (d &lt; 10){
                if (total &lt; ServerConstants.ranks[d-1]) {
                	ServerConstants.ranks[d] = total;
                	ServerConstants.rankPpl[d] = playerName;
                }
            } else {
                if (total &lt; ServerConstants.ranks[d-1]) {
                }
            }
        }
    }
		/** Full magic spell system for process() starts here * */
		if (spellHitTimer == 0) {
			if (castSpell) {
				castSpell = false;
				if (isSpellNPC &amp;&amp; (spellNpcIndex != -1)) {
					appendHitToNpc(spellNpcIndex, spellHit, isStillSpell);
				} else if (!isSpellNPC &amp;&amp; (spellPlayerIndex != -1)) {
					appendHitToPlayer(spellPlayerIndex, spellHit, isStillSpell);
			}
		}
			spellHitTimer = -1;
	}
		/** Full magic spell system for process() ends here * */
		if(System.currentTimeMillis() - lastArrow &gt; 500 &amp;&amp; arrow){
			int arrowgfx = getarrowgfxnow();
			if(AttackingOn &gt; 0){
				rangeGFX(70, arrowgfx);
			}
			if(attacknpc &gt; 0){
				rangeGFXNPC(70, arrowgfx);
			}
			arrow = false;
			arrow2 = true;
		}
		if(System.currentTimeMillis() - lastArrow &gt; 1500 &amp;&amp; arrow2){
			lastArrow = System.currentTimeMillis();
			arrow2 = false;
			if(AttackingOn &gt; 0 &amp;&amp; isInWilderness(absX, absY, 1) == true &amp;&amp; getClient(AttackingOn).isInWilderness(getClient(AttackingOn).absX, getClient(AttackingOn).absY, 1) == true){
				Client AttackingOn2 = (Client) ServerConstants.playerHandler.players[AttackingOn];
				if(AttackingOn2 != null){
					hitDiff = Misc.random(maxRangeHit());
					PlayerHandler.players[AttackingOn].hitDiff = hitDiff;
					PlayerHandler.players[AttackingOn].updateRequired = true;
					PlayerHandler.players[AttackingOn].appearanceUpdateRequired = true;
					PlayerHandler.players[AttackingOn].hitUpdateRequired = true;
					PlayerHandler.players[AttackingOn].dealDamage(hitDiff);
					PlayerHandler.players[AttackingOn].offTimer = System.currentTimeMillis();
					PlayerHandler.players[AttackingOn].hitID = playerId;
					PlayerHandler.players[AttackingOn].KilledBy[playerId] += hitDiff;
				}
			}
			if(attacknpc &gt; 0){
				ServerConstants.npcHandler.npcs[attacknpc].hitDiff = NpcHitting.npcRangeDamage();
				ServerConstants.npcHandler.npcs[attacknpc].updateRequired = true;
				ServerConstants.npcHandler.npcs[attacknpc].hitUpdateRequired = true;
				ServerConstants.npcHandler.npcs[attacknpc].hit = true;
			}
		}
	if(apickupid &gt; 0)
		scanPickup();
        if ((IsAttackingNPC) &amp;&amp; DDS2Damg == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
            SpecDamgNPC(playerMaxHit + 8);
            DDS2Damg = false;
        }
        if (IsAttacking == true &amp;&amp; DDS2Damg == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
		if (AttackingOn &gt; 0) {
	    		getHitDouble(8);	
            	DDS2Damg = false;
			}
        }
        if (IsAttacking == true &amp;&amp; DDS2Damg2 == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
		if (AttackingOn &gt; 0) {
			if(playerEquipment[playerWeapon] == 4827){
	    			getHit2();	
            			DDS2Damg2 = false;
			}
			if(playerEquipment[playerWeapon] == 861){
	    			getHit2();
	    			DDS2Damg2 = false;
			}
		}
	}
	if (IsAttackingNPC == true &amp;&amp; DDS2Damg2 == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
		if (attacknpc &gt; 0){
			if(playerEquipment[playerWeapon] == 4827){
	    			getHit2();
            			DDS2Damg2 = false;
			}
			if(playerEquipment[playerWeapon] == 861){
	    			getHit2();
	    			DDS2Damg2 = false;
			}
		}
	}
        if (IsAttacking == true &amp;&amp; DDS2Damg3 == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
	    getHit2();
	    DDS2Damg3 = false;
	}
        if(playerLevel[5] &lt; 0){
        	playerLevel[5] = 0;
        	sendQuest(&quot;&quot; + playerLevel[5] + &quot;&quot;, 4012);
        	sendFrame(&quot;Prayer: &quot;+playerLevel[5]+&quot;/&quot;+getLevelForXP(playerXP[5])+&quot;&quot;, 687);
        }
        if(prayer.checkPrayOn() &amp;&amp; playerLevel[5] &lt; 1){
        	playerLevel[5] = 0;
        	prayer.prayOff();
        }
        if(prayer.checkPrayOn() &amp;&amp; System.currentTimeMillis() - lastPray &gt; prayInterval){
        	prayInterval = prayer.checkPrayStat();
        	lastPray = System.currentTimeMillis();
        	prayer.prayerDrain();
        	sendQuest(&quot;&quot; + playerLevel[5] + &quot;&quot;, 4012);
        	sendFrame(&quot;Prayer: &quot;+playerLevel[5]+&quot;/&quot;+getLevelForXP(playerXP[5])+&quot;&quot;, 687);
        }
			if (originalS &gt; 0) {
				wearing.wear(originalS, playerShield);
			}
		if (inTrade &amp;&amp; tradeResetNeeded) {
			Client o = getClient(trade_reqId);
			if (o.tradeResetNeeded) {
				trading.resetTrade();
				trading.resetTrade();
			}
		}
		// Shop
		if (UpdateShop == true) {
			resetItems(3823);
			resetShop(MyShopID);
		}
		// check banking
		if (WanneBank &gt; 0) {
			if (GoodDistance(skillX, skillY, absX, absY, WanneBank) == true) {
				openUpBank();
				WanneBank = 0;
			}
		}
		// check stairs
		if (stairs &gt; 0) {
			if (GoodDistance(skillX, skillY, absX, absY, stairDistance) == true) {
				stairs(stairs, absX, absY);
			}
		}

		// Attacking in wilderness
		//long thisTime = System.currentTimeMillis();
		if ((IsAttacking == true) &amp;&amp; (deathStage == 0)
				&amp;&amp; (System.currentTimeMillis() - lastAction &gt; actionInterval)) {
			if (PlayerHandler.players[AttackingOn] != null) {
				if (PlayerHandler.players[AttackingOn].currentHealth &gt; 0) {
					handlecombat.Attack();
				} else {
				}
			} else {
				handlecombat.ResetAttack();
			}
		}
		// Attacking an NPC
		if ((IsAttackingNPC == true) &amp;&amp; (deathStage == 0) &amp;&amp; System.currentTimeMillis() - lastAction &gt; actionInterval) {
			if (ServerConstants.npcHandler.npcs[attacknpc] != null) {
				if ((ServerConstants.npcHandler.npcs[attacknpc].IsDead == false) &amp;&amp; (ServerConstants.npcHandler.npcs[attacknpc].MaxHP &gt; 0)) {
					handlecombat.AttackNPC();
		if(firstLogin == true &amp;&amp; currentHealth != 10) {
			currentHealth = 10;
		}
				} else {
				}
			} else {
				handlecombat.ResetAttackNPC();
			}
		}
		if (deathStage == 1) {
			if (attacknpc &gt; 0) { 
				ServerConstants.npcHandler.ResetAttackPlayer(attacknpc);
			}
			handlecombat.ResetAttack();
			handlecombat.ResetAttackNPC();
			deathStage = 2;
			poisoned = false;
			poisonDmg = false;
			fighting = false;
			hits = 0;
		  	setAnimation(2304);
		  	updateRequired = true;
		  	appearanceUpdateRequired = true;
		  	deathTimer = System.currentTimeMillis();
		  	currentHealth = playerLevel[playerHitpoints];
		  	playerLevel[0] = getLevelForXP(playerXP[0]);
		  	playerLevel[1] = getLevelForXP(playerXP[1]);
		  	playerLevel[2] = getLevelForXP(playerXP[2]);
		  	playerLevel[4] = getLevelForXP(playerXP[4]);
		  	playerLevel[5] = getLevelForXP(playerXP[5]);
		  	playerLevel[6] = getLevelForXP(playerXP[6]);
		  	sendFrame(&quot;Prayer: &quot;+playerLevel[5]+&quot;/&quot;+getLevelForXP(playerXP[5])+&quot;&quot;, 687);
		  	resetfollowers();
		  	for(int rF = 0; rF &lt; 22; rF++)
		  		refreshSkill(rF);
		  	killMyNPCs();
		  	skulledBy = &quot;&quot;;
		}
		if (deathStage == 2) {
			if (isInWilderness(absX, absY, 1) == true &amp;&amp; !multiPK()) {
				Client killerz = (Client) ServerConstants.playerHandler.players[KillerId];
				killerz.handlecombat.ResetAttack();
			}
		}
			else if (multiPK()) {
				Client killerz = (Client) ServerConstants.playerHandler.players[KillerId];
				if (isinsafewild() == false) {
					killerz.sM(&quot;You have defeated &quot;+playerName+&quot;.&quot;);
					if(killerz != null)
						if(playerRights &lt; 4)
							if(tradeTimer == 0)
								if(!inDuel()) {
									youdied();
								}
				}

			if (deathStage == 2); {
				toX = 3222;
				toY = 3222;
				PrayHeal = false;
				PrayerAction.resetPrayer();
				isSkulled = false;
				lastSkull = 0;
				headIcon = 0;
				headIconPk = 0;
				prayer.turnpray();
				heightLevel = 0;
				currentHealth = playerLevel[playerHitpoints];
				currentHealth = getLevelForXP(playerXP[3]);
				deathStage = 0;
				frame1();
				specialAmount = 100;
				sM(&quot;Oh dear you have died!&quot;);
				deathStage = 0;
				resetOtherAtk();
				resetAnimation();
				appearanceUpdateRequired = true;
				updateRequired = true;
			}
			}
	
		if (isKicked) {
			disconnected = true;
			if (saveNeeded)
				CharacterSave.savegame(true);
				outStream.createFrame(109);
		}
		return false;
	}[/code]</description>
    
    <lastBuildDate>Tue, 24 Apr 2012 21:21:15 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/server-stability/440547.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Server stability</title>
        <dc:creator><![CDATA[@Skiire Skiire]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/skiire">@Skiire</a> wrote:</p>
          <blockquote>
              <p>Lag is not dependent on the process(). Removing unnecessary code from the process() can help though.</p>
<p>Every time the server cycles (every 600ms [one tick]) all code is reused. Therefore when you’re doing things such as:</p>
<pre><code class="lang-auto">if (handleagility.inGnomeAgility() || handleagility.inBarbarianAgility() || handleagility.inPyramidAgility()) { //agility
            followID = 0;
            if (handleagility.isPassing == true)
                    isRunning = false;
            if (absX == handleagility.neededX &amp;&amp; absY == handleagility.neededY) {
                    handleagility.resetAgility();
            }
    } //agility ^</code></pre>
<p>In this particular case detecting whether the player is in an Agility course. Does that need to be run every tick? No. That’s why converting this garbage into an event to run when and only when necessary can relieve the server from stress. Be careful when converting this into an event though as some event handlers are called and initiated every cycle, same as the process.</p>
<p>Nonetheless to answer your question your process() is crammed with a ton of garbage and I’m so, so, so glad I’ve never had the  misfortune of trying to make a serious project out of a Delta.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/server-stability/440547/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/server-stability/440547/2</link>
        <pubDate>Tue, 24 Apr 2012 21:21:15 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-440547-2</guid>
        <source url="https://forum.moparisthebest.com/t/server-stability/440547.rss">Server stability</source>
      </item>
      <item>
        <title>Server stability</title>
        <dc:creator><![CDATA[@202685 202685]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/202685">@202685</a> wrote:</p>
          <blockquote>
              <p>if i servers stability depends on the proccess() method, then how stable would me delta be with this</p>
<p>[code]	public boolean process() throws NullPointerException {<br>
if (handleagility.inGnomeAgility() || handleagility.inBarbarianAgility() || handleagility.inPyramidAgility()) { //agility<br>
followID = 0;<br>
if (handleagility.isPassing == true)<br>
isRunning = false;<br>
if (absX == handleagility.neededX &amp;&amp; absY == handleagility.neededY) {<br>
handleagility.resetAgility();<br>
}<br>
} //agility ^<br>
handlecombat.CalculateMaxHit();<br>
if (getLevelForXP(playerXP[playerHitpoints]) &lt; playerLevel[playerHitpoints]) {<br>
if (refillHp == true) {<br>
if (PrayerAction.rapidHeal) {<br>
if (System.currentTimeMillis() - lastIncrease &gt;= 7000) {<br>
playerXP[playerHitpoints] =+ 1;<br>
} else {<br>
if (System.currentTimeMillis() - lastIncrease &gt;= 14000) {<br>
playerXP[playerHitpoints] =+ 1;<br>
}<br>
}<br>
}<br>
}<br>
}<br>
sendQuest("<span class="mention">@yel</span>@Utopia Points: <span class="mention">@gre</span>@"+pkPoints+"", 7383);<br>
sendQuest("<span class="mention">@yel</span>@MultiPK Points: <span class="mention">@gre</span>@"+multiPkPoints+"", 7339);<br>
if (isInWilderness(absX, absY, 2) == true &amp;&amp; WildernessWarning == false &amp;&amp; !multiPK()) {<br>
resetWalkingQueue();<br>
sendFrame248(1908, 3213);<br>
WildernessWarning = true;<br>
}<br>
appendPos();</p>
<pre><code>	if (tradeTimer != 0){
		tradeTimer--;
	}
	if (disconnectedDelay == 1){
		disconnected = true;
	}
	if(!isInWilderness(absX, absY, 1) || !multiPK()){
		//setInterfaceWalkable(-1);
		hasWildySign = false;
	}
	if(isInWilderness == false) {
		outStream.createFrameVarSize(104);
		outStream.writeByteC(3);
		outStream.writeByteA(0);
		outStream.writeString("null");
		outStream.endFrameVarSize();
	}
	if(isInWilderness(absX, absY, 1) || multiPK()) {
		outStream.createFrameVarSize(104);
		outStream.writeByteC(3);
		outStream.writeByteA(0);
		outStream.writeString("Attack");
		outStream.endFrameVarSize();
	}
	if (System.currentTimeMillis() - lastSave &gt; 120000 &amp;&amp; !inTrade){
		CharacterSave.savegame(true);
		lastSave = System.currentTimeMillis();
	}
	if (System.currentTimeMillis() - lastBookSwitch &gt; 30000 &amp;&amp; switchingBook) {
		setSidebarInterface(6, 18787);
		lastBookSwitch = System.currentTimeMillis();
		switchingBook = false;
	}
	if (System.currentTimeMillis() - offTimer &gt; 6000){
		hitID = 0;
	}
	if(System.currentTimeMillis() - lastSkull &gt;= 1200000 &amp;&amp; isSkulled){
		turnOffHead();
		updateRequired = true;
		appearanceUpdateRequired = true;
		isSkulled = false;
	}
	if (disconnectedDelay &gt; 0) {
		disconnectedDelay--;
	}
	if (spellHitTimer &gt; 0) {
		spellHitTimer -= 1;
	}
	if(poisoned &amp;&amp; System.currentTimeMillis() - poisonDelay &gt; 15000){
		poisonDmg = true;
		applyPoisonToMe();
		poisonDmg = false;
		poisonDelay = System.currentTimeMillis();
	}
	if(System.currentTimeMillis() - lastSpecial &gt; 50000 &amp;&amp; specialAmount &lt; 100){
		specialAmount += 25;
		lastSpecial = System.currentTimeMillis();
		specAttack();
	}
	if (hasMultiSign) {
		frame61(-1);
		hasMultiSign = false;
	} 
	if (isInWilderness(absX, absY, 1) &amp;&amp; !multiPK()) {
			if (!hasWildySign) {
				hasWildySign = true;
				outStream.createFrame(208);
				outStream.writeWordBigEndian_dup(197);
				sendQuest("Level: " + wildyLevel, 199);
			}
			int level = ((absY - 3520) / 8) + 1;
			if (level != wildyLevel) {
				wildyLevel = level;
				sendQuest("Level: " + wildyLevel, 199);
			} 
			if(isinsafewild()){
				level = 20;
			}		
			if (level != wildyLevel) {
				if(isinsafewild()){
					sendQuest("@whi@test", 199);
				} else {
					wildyLevel = level;
					sendQuest("Level: " + wildyLevel, 199);
				}
			}
	}
	
	Calendar cal = new GregorianCalendar();
	int day = cal.get(Calendar.DAY_OF_MONTH);
	int month = cal.get(Calendar.MONTH);
	int year = cal.get(Calendar.YEAR);
	int calc = ((year * 10000) + (month * 100) + day);
	playerLastLogin = calc;

	if (System.currentTimeMillis() - statIncrease &gt; 120000) {
		for (int i1 = 0; i1 &lt; playerLevel.length; i1++) {
			if (playerLevel[i1] &lt; getLevelForXP(playerXP[i1])) {
				playerLevel[i1] += 1;
				setSkillLevel(i1, playerLevel[i1], playerXP[i1]);
				NewHP = playerLevel[3];
				for(int rF = 0; rF &lt; 22; rF++)
					refreshSkill(rF);
			} else if (playerLevel[i1] &gt; getLevelForXP(playerXP[i1])) {
				playerLevel[i1] -= 1;
				setSkillLevel(i1, playerLevel[i1], playerXP[i1]);
				NewHP = playerLevel[3];
				for(int rF = 0; rF &lt; 22; rF++)
					refreshSkill(rF);
			}
		}
		statIncrease = System.currentTimeMillis();
	}	
	if(PlayerHandler.getPlayerID(playerName) != playerId){	
		disconnected = true;
	}
	if (inCombat) {
	long current = System.currentTimeMillis();
	if(current - lastCombat &gt;= 10000) {
		inCombat = false;
	}
	}
	if (currentHealth &lt; 1) {
		deathStage = 1;
	}
	if(hitDiff &gt; 0){
		sendQuest("" + currentHealth, 4016);
	}
	if (NpcDialogue &gt; 0 &amp;&amp; NpcDialogueSend == false) {
		UpdateNPCChat();
	}
	if (isinsafewild()) {
		followID = 0;
	}

if (followID &gt; 0) {
	FollowHandler.followDirection();
}
if (followID2 &gt; 0) {
	followDirection2();
}	

if (tStage == 1 &amp;&amp; tTime == 0) {
      setAnimation(1979);
      lowGFX(392, 0);
      updateRequired = true;
      appearanceUpdateRequired = true;
      tTime = System.currentTimeMillis();
      tStage = 2;
    }
    if (tStage == 2 &amp;&amp; System.currentTimeMillis()-tTime &gt;= 10) {
      toX = tX;
      toY = tY;
      heightLevel = tH;
      updateRequired = true;
      appearanceUpdateRequired = true;
      tStage = 0;
      tTime = 0;
      resetAnimation();
      resetfollowers();
      closeInterface();
    }
    if (tStage == 3 &amp;&amp; tTime2 == 0) {
      setAnimation(714);
      updateRequired = true;
      appearanceUpdateRequired = true;
      tTime2 = System.currentTimeMillis();
      tStage = 4;
    }
    if (tStage == 4 &amp;&amp; System.currentTimeMillis()-tTime2 &gt;= 10) {
      specGFX(308);
      tStage = 5;
    }
    if (tStage == 5 &amp;&amp; System.currentTimeMillis()-tTime2 &gt;= 10) {
      setAnimation(715);
      toX = tX;
      toY = tY;
      heightLevel = tH;
      updateRequired = true;
      appearanceUpdateRequired = true;
      tStage = 0;
      tTime = 0;
      resetAnimation();
      resetfollowers();
      closeInterface();
    }


playerLevel[24] = total;
for (int d = 0; d &lt;= 10; d++) {
    if (total &gt;= ServerConstants.ranks[d]) {
        if (d == 0) {
        	ServerConstants.ranks[d] = total;
        	ServerConstants.rankPpl[d] = playerName;
        } else if (d &lt; 10){
            if (total &lt; ServerConstants.ranks[d-1]) {
            	ServerConstants.ranks[d] = total;
            	ServerConstants.rankPpl[d] = playerName;
            }
        } else {
            if (total &lt; ServerConstants.ranks[d-1]) {
            }
        }
    }
}
	/** Full magic spell system for process() starts here * */
	if (spellHitTimer == 0) {
		if (castSpell) {
			castSpell = false;
			if (isSpellNPC &amp;&amp; (spellNpcIndex != -1)) {
				appendHitToNpc(spellNpcIndex, spellHit, isStillSpell);
			} else if (!isSpellNPC &amp;&amp; (spellPlayerIndex != -1)) {
				appendHitToPlayer(spellPlayerIndex, spellHit, isStillSpell);
		}
	}
		spellHitTimer = -1;
}
	/** Full magic spell system for process() ends here * */
	if(System.currentTimeMillis() - lastArrow &gt; 500 &amp;&amp; arrow){
		int arrowgfx = getarrowgfxnow();
		if(AttackingOn &gt; 0){
			rangeGFX(70, arrowgfx);
		}
		if(attacknpc &gt; 0){
			rangeGFXNPC(70, arrowgfx);
		}
		arrow = false;
		arrow2 = true;
	}
	if(System.currentTimeMillis() - lastArrow &gt; 1500 &amp;&amp; arrow2){
		lastArrow = System.currentTimeMillis();
		arrow2 = false;
		if(AttackingOn &gt; 0 &amp;&amp; isInWilderness(absX, absY, 1) == true &amp;&amp; getClient(AttackingOn).isInWilderness(getClient(AttackingOn).absX, getClient(AttackingOn).absY, 1) == true){
			Client AttackingOn2 = (Client) ServerConstants.playerHandler.players[AttackingOn];
			if(AttackingOn2 != null){
				hitDiff = Misc.random(maxRangeHit());
				PlayerHandler.players[AttackingOn].hitDiff = hitDiff;
				PlayerHandler.players[AttackingOn].updateRequired = true;
				PlayerHandler.players[AttackingOn].appearanceUpdateRequired = true;
				PlayerHandler.players[AttackingOn].hitUpdateRequired = true;
				PlayerHandler.players[AttackingOn].dealDamage(hitDiff);
				PlayerHandler.players[AttackingOn].offTimer = System.currentTimeMillis();
				PlayerHandler.players[AttackingOn].hitID = playerId;
				PlayerHandler.players[AttackingOn].KilledBy[playerId] += hitDiff;
			}
		}
		if(attacknpc &gt; 0){
			ServerConstants.npcHandler.npcs[attacknpc].hitDiff = NpcHitting.npcRangeDamage();
			ServerConstants.npcHandler.npcs[attacknpc].updateRequired = true;
			ServerConstants.npcHandler.npcs[attacknpc].hitUpdateRequired = true;
			ServerConstants.npcHandler.npcs[attacknpc].hit = true;
		}
	}
if(apickupid &gt; 0)
	scanPickup();
    if ((IsAttackingNPC) &amp;&amp; DDS2Damg == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
        SpecDamgNPC(playerMaxHit + 8);
        DDS2Damg = false;
    }
    if (IsAttacking == true &amp;&amp; DDS2Damg == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
	if (AttackingOn &gt; 0) {
    		getHitDouble(8);	
        	DDS2Damg = false;
		}
    }
    if (IsAttacking == true &amp;&amp; DDS2Damg2 == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
	if (AttackingOn &gt; 0) {
		if(playerEquipment[playerWeapon] == 4827){
    			getHit2();	
        			DDS2Damg2 = false;
		}
		if(playerEquipment[playerWeapon] == 861){
    			getHit2();
    			DDS2Damg2 = false;
		}
	}
}
if (IsAttackingNPC == true &amp;&amp; DDS2Damg2 == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
	if (attacknpc &gt; 0){
		if(playerEquipment[playerWeapon] == 4827){
    			getHit2();
        			DDS2Damg2 = false;
		}
		if(playerEquipment[playerWeapon] == 861){
    			getHit2();
    			DDS2Damg2 = false;
		}
	}
}
    if (IsAttacking == true &amp;&amp; DDS2Damg3 == true &amp;&amp; System.currentTimeMillis() - lastDds &gt; ddsInterval) {
    getHit2();
    DDS2Damg3 = false;
}
    if(playerLevel[5] &lt; 0){
    	playerLevel[5] = 0;
    	sendQuest("" + playerLevel[5] + "", 4012);
    	sendFrame("Prayer: "+playerLevel[5]+"/"+getLevelForXP(playerXP[5])+"", 687);
    }
    if(prayer.checkPrayOn() &amp;&amp; playerLevel[5] &lt; 1){
    	playerLevel[5] = 0;
    	prayer.prayOff();
    }
    if(prayer.checkPrayOn() &amp;&amp; System.currentTimeMillis() - lastPray &gt; prayInterval){
    	prayInterval = prayer.checkPrayStat();
    	lastPray = System.currentTimeMillis();
    	prayer.prayerDrain();
    	sendQuest("" + playerLevel[5] + "", 4012);
    	sendFrame("Prayer: "+playerLevel[5]+"/"+getLevelForXP(playerXP[5])+"", 687);
    }
		if (originalS &gt; 0) {
			wearing.wear(originalS, playerShield);
		}
	if (inTrade &amp;&amp; tradeResetNeeded) {
		Client o = getClient(trade_reqId);
		if (o.tradeResetNeeded) {
			trading.resetTrade();
			trading.resetTrade();
		}
	}
	// Shop
	if (UpdateShop == true) {
		resetItems(3823);
		resetShop(MyShopID);
	}
	// check banking
	if (WanneBank &gt; 0) {
		if (GoodDistance(skillX, skillY, absX, absY, WanneBank) == true) {
			openUpBank();
			WanneBank = 0;
		}
	}
	// check stairs
	if (stairs &gt; 0) {
		if (GoodDistance(skillX, skillY, absX, absY, stairDistance) == true) {
			stairs(stairs, absX, absY);
		}
	}

	// Attacking in wilderness
	//long thisTime = System.currentTimeMillis();
	if ((IsAttacking == true) &amp;&amp; (deathStage == 0)
			&amp;&amp; (System.currentTimeMillis() - lastAction &gt; actionInterval)) {
		if (PlayerHandler.players[AttackingOn] != null) {
			if (PlayerHandler.players[AttackingOn].currentHealth &gt; 0) {
				handlecombat.Attack();
			} else {
			}
		} else {
			handlecombat.ResetAttack();
		}
	}
	// Attacking an NPC
	if ((IsAttackingNPC == true) &amp;&amp; (deathStage == 0) &amp;&amp; System.currentTimeMillis() - lastAction &gt; actionInterval) {
		if (ServerConstants.npcHandler.npcs[attacknpc] != null) {
			if ((ServerConstants.npcHandler.npcs[attacknpc].IsDead == false) &amp;&amp; (ServerConstants.npcHandler.npcs[attacknpc].MaxHP &gt; 0)) {
				handlecombat.AttackNPC();
	if(firstLogin == true &amp;&amp; currentHealth != 10) {
		currentHealth = 10;
	}
			} else {
			}
		} else {
			handlecombat.ResetAttackNPC();
		}
	}
	if (deathStage == 1) {
		if (attacknpc &gt; 0) { 
			ServerConstants.npcHandler.ResetAttackPlayer(attacknpc);
		}
		handlecombat.ResetAttack();
		handlecombat.ResetAttackNPC();
		deathStage = 2;
		poisoned = false;
		poisonDmg = false;
		fighting = false;
		hits = 0;
	  	setAnimation(2304);
	  	updateRequired = true;
	  	appearanceUpdateRequired = true;
	  	deathTimer = System.currentTimeMillis();
	  	currentHealth = playerLevel[playerHitpoints];
	  	playerLevel[0] = getLevelForXP(playerXP[0]);
	  	playerLevel[1] = getLevelForXP(playerXP[1]);
	  	playerLevel[2] = getLevelForXP(playerXP[2]);
	  	playerLevel[4] = getLevelForXP(playerXP[4]);
	  	playerLevel[5] = getLevelForXP(playerXP[5]);
	  	playerLevel[6] = getLevelForXP(playerXP[6]);
	  	sendFrame("Prayer: "+playerLevel[5]+"/"+getLevelForXP(playerXP[5])+"", 687);
	  	resetfollowers();
	  	for(int rF = 0; rF &lt; 22; rF++)
	  		refreshSkill(rF);
	  	killMyNPCs();
	  	skulledBy = "";
	}
	if (deathStage == 2) {
		if (isInWilderness(absX, absY, 1) == true &amp;&amp; !multiPK()) {
			Client killerz = (Client) ServerConstants.playerHandler.players[KillerId];
			killerz.handlecombat.ResetAttack();
		}
	}
		else if (multiPK()) {
			Client killerz = (Client) ServerConstants.playerHandler.players[KillerId];
			if (isinsafewild() == false) {
				killerz.sM("You have defeated "+playerName+".");
				if(killerz != null)
					if(playerRights &lt; 4)
						if(tradeTimer == 0)
							if(!inDuel()) {
								youdied();
							}
			}

		if (deathStage == 2); {
			toX = 3222;
			toY = 3222;
			PrayHeal = false;
			PrayerAction.resetPrayer();
			isSkulled = false;
			lastSkull = 0;
			headIcon = 0;
			headIconPk = 0;
			prayer.turnpray();
			heightLevel = 0;
			currentHealth = playerLevel[playerHitpoints];
			currentHealth = getLevelForXP(playerXP[3]);
			deathStage = 0;
			frame1();
			specialAmount = 100;
			sM("Oh dear you have died!");
			deathStage = 0;
			resetOtherAtk();
			resetAnimation();
			appearanceUpdateRequired = true;
			updateRequired = true;
		}
		}

	if (isKicked) {
		disconnected = true;
		if (saveNeeded)
			CharacterSave.savegame(true);
			outStream.createFrame(109);
	}
	return false;
}[/code]</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/server-stability/440547/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/server-stability/440547/1</link>
        <pubDate>Tue, 24 Apr 2012 20:41:50 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-440547-1</guid>
        <source url="https://forum.moparisthebest.com/t/server-stability/440547.rss">Server stability</source>
      </item>
  </channel>
</rss>
