<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Delete</title>
    <link>https://forum.moparisthebest.com/t/delete/408458</link>
    <description>Delete</description>
    
    <lastBuildDate>Sat, 06 Aug 2011 04:14:14 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/delete/408458.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Metho D, post:9, topic:408458”][quote author=T4_ link=topic=509741.msg3698703#msg3698703 date=1312600600]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>The client internally use an implementation of Dijkstra’s algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo()</p>
</blockquote>
</aside>
<p>It’s actually just a breadth-first search, not Dijkstra’s algorithm.</p>
</blockquote>
</aside>
<p>Because each tile is the same length/size, correct?</p>
</blockquote>
</aside>
<p>I don’t think tile size has anything to do with it, no. The client just doesn’t prioritize the tiles in the list of traversable tiles; instead, the list acts as a simple queue.</p>
</blockquote>
</aside>
<p>Yes, but Dijkstra’s algorithm is normally used to pick paths with different sized vertices (a prioritized queue)?<br>
[/quote]</p>
<p>As far as I know, the priority queue orders the nodes based on their distance from the start node. I don’t think the “size” of nodes in the graph is relevant.[/quote]<br>
What I meant to say was all tiles are the same size, thus each node is the same distance from its neighbor.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/10</link>
        <pubDate>Sat, 06 Aug 2011 04:14:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-10</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@Metho_D Method]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/metho_d">@Metho_D</a> wrote:</p>
          <blockquote>
              <p>[quote=“T4_, post:8, topic:408458”][quote author=Metho D link=topic=509741.msg3698688#msg3698688 date=1312599971]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>The client internally use an implementation of Dijkstra’s algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo()</p>
</blockquote>
</aside>
<p>It’s actually just a breadth-first search, not Dijkstra’s algorithm.</p>
</blockquote>
</aside>
<p>Because each tile is the same length/size, correct?</p>
</blockquote>
</aside>
<p>I don’t think tile size has anything to do with it, no. The client just doesn’t prioritize the tiles in the list of traversable tiles; instead, the list acts as a simple queue.<br>
[/quote]<br>
Yes, but Dijkstra’s algorithm is normally used to pick paths with different sized vertices (a prioritized queue)?[/quote]</p>
<p>As far as I know, the priority queue orders the nodes based on their distance from the start node. I don’t think the “size” of nodes in the graph is relevant.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/9</link>
        <pubDate>Sat, 06 Aug 2011 03:22:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-9</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Metho D, post:6, topic:408458”][quote author=T4_ link=topic=509741.msg3698672#msg3698672 date=1312599437]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>The client internally use an implementation of Dijkstra’s algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo()</p>
</blockquote>
</aside>
<p>It’s actually just a breadth-first search, not Dijkstra’s algorithm.</p>
</blockquote>
</aside>
<p>Because each tile is the same length/size, correct?<br>
[/quote]</p>
<p>I don’t think tile size has anything to do with it, no. The client just doesn’t prioritize the tiles in the list of traversable tiles; instead, the list acts as a simple queue.[/quote]<br>
Yes, but Dijkstra’s algorithm is normally used to pick paths with different sized vertices (a prioritized queue)?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/8</link>
        <pubDate>Sat, 06 Aug 2011 03:16:40 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-8</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@slavemaster veer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/slavemaster">@slavemaster</a> wrote:</p>
          <blockquote>
              <p>[quote=“Metho D, post:4, topic:408458”][quote author=slavemaster link=topic=509741.msg3698648#msg3698648 date=1312598566]<br>
The client internally use an implementation of Dijkstra’s algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo()<br>
[/quote]</p>
<p>It’s actually just a breadth-first search, not Dijkstra’s algorithm.[/quote]</p>
<p>You’re right, I assumed there was some code there that I just didn’t see. :o</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/7</link>
        <pubDate>Sat, 06 Aug 2011 03:08:00 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-7</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@Metho_D Method]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/metho_d">@Metho_D</a> wrote:</p>
          <blockquote>
              <p>[quote=“T4_, post:5, topic:408458”][quote author=Metho D link=topic=509741.msg3698663#msg3698663 date=1312599203]</p>
<aside class="quote">
<blockquote>
<p>The client internally use an implementation of Dijkstra’s algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo()</p>
</blockquote>
</aside>
<p>It’s actually just a breadth-first search, not Dijkstra’s algorithm.<br>
[/quote]<br>
Because each tile is the same length/size, correct?[/quote]</p>
<p>I don’t think tile size has anything to do with it, no. The client just doesn’t prioritize the tiles in the list of traversable tiles; instead, the list acts as a simple queue.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/6</link>
        <pubDate>Sat, 06 Aug 2011 03:06:11 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-6</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Metho D, post:4, topic:408458”][quote author=slavemaster link=topic=509741.msg3698648#msg3698648 date=1312598566]<br>
The client internally use an implementation of Dijkstra’s algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo()<br>
[/quote]</p>
<p>It’s actually just a breadth-first search, not Dijkstra’s algorithm.[/quote]<br>
Because each tile is the same length/size, correct?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/5</link>
        <pubDate>Sat, 06 Aug 2011 02:57:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-5</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@Metho_D Method]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/metho_d">@Metho_D</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="3" data-topic="408458">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/slavemaster/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> slavemaster:</div>
<blockquote>
<p>The client internally use an implementation of Dijkstra’s algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo()</p>
</blockquote>
</aside>
<p>It’s actually just a breadth-first search, not Dijkstra’s algorithm.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/4</link>
        <pubDate>Sat, 06 Aug 2011 02:53:23 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-4</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@slavemaster veer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/slavemaster">@slavemaster</a> wrote:</p>
          <blockquote>
              <p>The client internally used an implementation of <span class="bbcode-s">Dijkstra’s</span> a breadth-first search algorithm to route through the tile network; so, that is, the client generated its own path information. In the client moparisthebest released (<a href="http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz" rel="nofollow noopener">http://moparisthebest.com/downloads/srcAllDummiesRemoved.tar.gz</a>), the algorithm is located in what he named doWalkTo() (slightly annotated)</p>
<p>[code]    private boolean doWalkTo(int i, int j, int k, int i1, int j1, int k1,<br>
int l1, int i2, int j2, boolean flag, int k2)<br>
{<br>
byte byte0 = 104; /* area width <em>/<br>
byte byte1 = 104; /</em> area height <em>/<br>
for(int l2 = 0; l2 &lt; byte0; l2++)<br>
{<br>
for(int i3 = 0; i3 &lt; byte1; i3++)<br>
{<br>
anIntArrayArray901[l2][i3] = 0;            /</em> peer <em>/<br>
anIntArrayArray825[l2][i3] = 0x5f5e0ff; /</em> cost */<br>
}</p>
<pre><code>    }

    int j3 = j2; /* origin x */
    int k3 = j1; /* origin y */
    anIntArrayArray901[j2][j1] = 99; /* no peer for origin */
    anIntArrayArray825[j2][j1] = 0; /* no cost for origin */
    int l3 = 0; /* cost-prioritized-queue write pointer */
    int i4 = 0; /* queue read pointer */
    bigX[l3] = j2; /* add origin to queue */
    bigY[l3++] = j1; /* '' */
    boolean flag1 = false; /* destination reached */
    int j4 = bigX.length; /* route buffer size */
    int ai[][] = aClass11Array1230[plane].anIntArrayArray294;
    while(i4 != l3) /* queue non-empty */
    {
        j3 = bigX[i4]; /* pull least cost from queue */
        k3 = bigY[i4];
        i4 = (i4 + 1) % j4; /* increment read pointer */
        if(j3 == k2 &amp;&amp; k3 == i2) /* reached the destination */
        {
            flag1 = true; /* hit */
            break;
        }
        if(i1 != 0) /* what's this? */
        {
            if((i1 &lt; 5 || i1 == 10) &amp;&amp; aClass11Array1230[plane].method219(k2, j3, k3, j, i1 - 1, i2))
            {
                flag1 = true; /* hit */
                break;
            }
            if(i1 &lt; 10 &amp;&amp; aClass11Array1230[plane].method220(k2, i2, k3, i1 - 1, j, j3))
            {
                flag1 = true; /* hit */
                break;
            }
        }
        if(k1 != 0 &amp;&amp; k != 0 &amp;&amp; aClass11Array1230[plane].method221(i2, k2, j3, k, l1, k1, k3)) /* what about this? :o */
        {
            flag1 = true;
            break;
        }
        int l4 = anIntArrayArray825[j3][k3] + 1; /* direct neighbor distance is peer distance +1 */
        if(j3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 - 1][k3] == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0) /* left tile exists, has no peer (i.e. hasn't been used), and is open from it's right */
        {
            bigX[l3] = j3 - 1; /* add to route */
            bigY[l3] = k3; /* '' */
            l3 = (l3 + 1) % j4; /* increment write pointer */
            anIntArrayArray901[j3 - 1][k3] = 2; /* previous tile to the right */
            anIntArrayArray825[j3 - 1][k3] = l4; /* update distance */
        }
        if(j3 &lt; byte0 - 1 &amp;&amp; anIntArrayArray901[j3 + 1][k3] == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0) /* right tile exists, has no peer, open from left */
        {
            bigX[l3] = j3 + 1; 
            bigY[l3] = k3;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 + 1][k3] = 8;
            anIntArrayArray825[j3 + 1][k3] = l4;
        }
        if(k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3][k3 - 1] == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0) /* tile underneath exists, has no peer, open from top */
        {
            bigX[l3] = j3;
            bigY[l3] = k3 - 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3][k3 - 1] = 1;
            anIntArrayArray825[j3][k3 - 1] = l4;
        }
        if(k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3][k3 + 1] == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0) /* tile above exists, has no peer, open from bottom */
        {
            bigX[l3] = j3;
            bigY[l3] = k3 + 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3][k3 + 1] = 4;
            anIntArrayArray825[j3][k3 + 1] = l4;
        }
        if(j3 &gt; 0 &amp;&amp; k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 - 1][k3 - 1] == 0 &amp;&amp; (ai[j3 - 1][k3 - 1] &amp; 0x128010e) == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0) 
        {
            bigX[l3] = j3 - 1;
            bigY[l3] = k3 - 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 - 1][k3 - 1] = 3;
            anIntArrayArray825[j3 - 1][k3 - 1] = l4;
        }
        if(j3 &lt; byte0 - 1 &amp;&amp; k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 + 1][k3 - 1] == 0 &amp;&amp; (ai[j3 + 1][k3 - 1] &amp; 0x1280183) == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0)
        {
            bigX[l3] = j3 + 1;
            bigY[l3] = k3 - 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 + 1][k3 - 1] = 9;
            anIntArrayArray825[j3 + 1][k3 - 1] = l4;
        }
        if(j3 &gt; 0 &amp;&amp; k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3 - 1][k3 + 1] == 0 &amp;&amp; (ai[j3 - 1][k3 + 1] &amp; 0x1280138) == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
        {
            bigX[l3] = j3 - 1;
            bigY[l3] = k3 + 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 - 1][k3 + 1] = 6;
            anIntArrayArray825[j3 - 1][k3 + 1] = l4;
        }
        if(j3 &lt; byte0 - 1 &amp;&amp; k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3 + 1][k3 + 1] == 0 &amp;&amp; (ai[j3 + 1][k3 + 1] &amp; 0x12801e0) == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
        {
            bigX[l3] = j3 + 1;
            bigY[l3] = k3 + 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 + 1][k3 + 1] = 12;
            anIntArrayArray825[j3 + 1][k3 + 1] = l4;
        }
    }
    anInt1264 = 0;
    if(!flag1)
    {
        if(flag)
        {
            int i5 = 100;
            for(int k5 = 1; k5 &lt; 2; k5++)
            {
                for(int i6 = k2 - k5; i6 &lt;= k2 + k5; i6++)
                {
                    for(int l6 = i2 - k5; l6 &lt;= i2 + k5; l6++)
                        if(i6 &gt;= 0 &amp;&amp; l6 &gt;= 0 &amp;&amp; i6 &lt; 104 &amp;&amp; l6 &lt; 104 &amp;&amp; anIntArrayArray825[i6][l6] &lt; i5)
                        {
                            i5 = anIntArrayArray825[i6][l6];
                            j3 = i6;
                            k3 = l6;
                            anInt1264 = 1;
                            flag1 = true;
                        }

                }

                if(flag1)
                    break;
            }

        }
        if(!flag1)
            return false;
    }
    i4 = 0;
    bigX[i4] = j3;
    bigY[i4++] = k3;
    int l5;
    for(int j5 = l5 = anIntArrayArray901[j3][k3]; j3 != j2 || k3 != j1; j5 = anIntArrayArray901[j3][k3])
    {
        if(j5 != l5)
        {
            l5 = j5;
            bigX[i4] = j3;
            bigY[i4++] = k3;
        }
        if((j5 &amp; 2) != 0)
            j3++;
        else
        if((j5 &amp; 8) != 0)
            j3--;
        if((j5 &amp; 1) != 0)
            k3++;
        else
        if((j5 &amp; 4) != 0)
            k3--;
    }
</code></pre>
<p>//	if(cancelWalk) { return i4 &gt; 0; }</p>
<pre><code>    if(i4 &gt; 0)
    {
        int k4 = i4;
        if(k4 &gt; 25)
            k4 = 25;
        i4--;
        int k6 = bigX[i4]; 
        int i7 = bigY[i4]; 
        anInt1288 += k4;
        if(anInt1288 &gt;= 92)
        {
            stream.createFrame(36);
            stream.writeDWord(0);
            anInt1288 = 0;
        }
        if(i == 0)
        {
            stream.createFrame(164);
            stream.writeWordBigEndian(k4 + k4 + 3);
        }
        if(i == 1)
        {
            stream.createFrame(248);
            stream.writeWordBigEndian(k4 + k4 + 3 + 14);
        }
        if(i == 2)
        {
            stream.createFrame(98);
            stream.writeWordBigEndian(k4 + k4 + 3);
        }
        stream.method433(k6 + baseX);
        destX = bigX[0];
        destY = bigY[0];
        for(int j7 = 1; j7 &lt; k4; j7++)
        {
            i4--;
            stream.writeWordBigEndian(bigX[i4] - k6);
            stream.writeWordBigEndian(bigY[i4] - i7);
        }

        stream.method431(i7 + baseY);
        stream.method424(super.keyArray[5] != 1 ? 0 : 1);
        return true;
    }
    return i != 1;
}
</code></pre>
<p>[/code]</p>
<p>The logic for the ::noclip command:</p>
<p>[code]                        if(inputString.equals("::noclip"))<br>
{<br>
for(int k1 = 0; k1 &lt; 4; k1++)<br>
{<br>
for(int i2 = 1; i2 &lt; 103; i2++)<br>
{<br>
for(int k2 = 1; k2 &lt; 103; k2++)<br>
aClass11Array1230[k1].anIntArrayArray294[i2][k2] = 0;</p>
<pre><code>                            }

                        }

                    }
</code></pre>
<p>[/code]</p>
<p>The terminology I used here is a bit networking inspired <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> A tile’s direct, adjacent predecessor in the route is referred to as its /peer/, and the distance from the origin of the route I called it’s /cost/.</p>
<p>aClass11Array1230 has a depth of 4, corresponding to the number of floors or <em>planes</em> there are in the game world. The range [0, 103] covers 104 elements, corresponding to the size of the local area (104x104 tiles). Class11 is a sort of collision map used for tiles, describing the various means of traversing a tile (it’s state – open or closed – from north, south, east, west, northeast, northwest, southeast, southwest), which are encoded in bit flags in the int[][] field there.</p>
<p>The algorithm as you can see tests for different means of traversal to tiles using bit masks. What ::noclip does is mark each and every tile in your area as open from all sides, meaning the algorithm has no obstacles to overcome and quickly finds a perfectly straight path to the destination.</p>
<p>When the client comes to send the server the route it discovers, it only uses “turn-points”, or joints, if you will, where direction changes, and encodes them as relative offsets from the route’s origin coordinate – an effective lossless compression scheme.</p>
<p>The server follows the instructions from the client, however also considers what it knows of non-walkable territory, so you are stopped short by any obstacles in the “direct” route. The encoding doesn’t send an end point, only joints, so a tile sitting on the shore is mistaken by the server for the tile in the middle of the adjacent river that you are really targeting. The server only disables checking for non-walkable territory if it picks up a ::noclip command by a staff member.</p>
<p>As of ~525, the doWalkTo() algorithm was ported to the server.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/3</link>
        <pubDate>Sat, 06 Aug 2011 02:42:46 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-3</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>Curiosity.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/2</link>
        <pubDate>Sat, 06 Aug 2011 00:36:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-2</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
      <item>
        <title>Delete</title>
        <dc:creator><![CDATA[@yo123 yo123]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yo123">@yo123</a> wrote:</p>
          <blockquote>
              <p>Delete</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/delete/408458/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/delete/408458/1</link>
        <pubDate>Sat, 06 Aug 2011 00:33:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-408458-1</guid>
        <source url="https://forum.moparisthebest.com/t/delete/408458.rss">Delete</source>
      </item>
  </channel>
</rss>
