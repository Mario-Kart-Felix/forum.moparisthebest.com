<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>[NEED INPUT] New Dialogue System - For the Intermediate Programmer</title>
    <link>https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748</link>
    <description>[CENTER][IMG]http://puu.sh/n9y6z/710d772ea0.png[/img][/CENTER]

Since I am a content developer, I figured I would start revamping some current systems to make my content spew out faster. Thus, this came. Made in approximately 2 hours.

[B][COLOR=&quot;#FF0000&quot;]Some things I&#39;m unsure about or have questions on are stated in the code comments.[/COLOR][/B]

[hr]

[B]Requirements: [URL=http://&quot;https://projectlombok.org/&quot;]Project Lombok[/URL][/B]

[SIZE=5][B]Implementing the System[/B][/SIZE]

To start off, make a new enum called State. In it, add this:
[code=java]
package com.rs.game.player.dialogues.test;

/**
 * Created by Arham 4 on 2/15/2016.
 * 
 * I&#39;m not sure about using this, but can&#39;t find a better way to do this. I need this for Option dialogue.
 */
public enum State {
    TALKING, NOT_TALKING
}

[/code]

This represents the current state of a dialogue.

Next, make a new enum in the same area and name it Expression. In it, add this:
[code=java]
package com.rs.game.player.dialogues.test;

import lombok.Getter;

/**
 * Created by Arham 4 on 2/15/2016.
 *
 * Think some of these names could be improved lol.
 */
public enum Expression {

    TERRIFIED(9750),
    TERRIFIED_NO_YELL(9753),
    THANK_YOU(9757),
    SAD(9760),
    SADDER(9761),
    SADDER_LOOKS_RIGHT(9762),
    SADDEST_DISGRACED(9765),
    SADDEST(9768),
    NEAR_TO_SAD(9769),
    SCARED_GET_AWAY_FROM_ME(9773),
    SCARED_PINCHED_EYES(9777),
    SCARED(9780),
    GET_OFF_MY_LAWN(9781),
    GET_OFF_MY_LAWN_ANGRIER(9782),
    GET_OFF_MY_LAWN_ANGRIEST(9783),
    ANGRY(9789),
    ANGRY_MOVING_FACE_ONLY(9792),
    MOVE_HEAD_FRONT_AND_BACK(9793),
    SLEEPY(9802),
    NEUTRAL(9803),
    BLINKING(9804),
    PARANOID(9806),
    PARANOID_AT_PLAYER(9808),
    INVESTIGATIVE(9811),
    TALK_TO_RIGHT(9814),
    QUESTION(9827),
    PLAIN_LOOK(9830),
    INVESTIGATIVE_TALKING(9831),
    WEE_DRUNK(9835),
    WISE(9836),
    VERY_JOLLY(9840),
    FUN_LAUGHING(9841),
    EVIL_MUHAHAHA(9842),
    GET_OFF_MY_LAWN_HAPPY(9843),
    HAPPY_EYEBROWS(9847),
    HAPPY(9850),
    VERY_FUN_LAUGHING(9851),
    BEGGING(9877),
    STICK_TONGUE_OUT(9878);

    @Getter
    private final int id;

    Expression(int id) {
        this.id = id;
    }
}
[/code]
This represents the player and NPC expressions in the 718 cache.

Next, we need to make the class that represents a Dialogue, so make a new class and name it Dialogue. Add this in it:
[code=java]
package com.rs.game.player.dialogues.test;

import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.message.Message;
import com.rs.game.player.dialogues.test.message.OptionMessage;

import java.util.HashMap;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a Dialogue (which contains Messages)
 */

/**
 * Thinking about using a builder for this for short dialogues? I don&#39;t know.
 */
public abstract class Dialogue {

    protected final HashMap&lt;Integer, Message&gt; dialogue;
    /**
     * I can&#39;t think of any other way to handle option dialogue closing rather than States.
     */
    protected State state;
    private Player player;

    private int key = 1;

    /**
     * @param dialogue So I can assure a new dialogue is being made per class rather than reusing the same one per class.
     */
    protected Dialogue(Player player, HashMap&lt;Integer, Message&gt; dialogue) {
        this.player = player;
        this.dialogue = dialogue;
        state = State.TALKING;
    }

    /**
     * Where we make the magic with the dialogue HashMap happen.
     */
    public abstract void buildDialogue();

    public void communicate() {
        dialogue.get(key).display(player);
        dialogue.get(key).executeAction();
    }

    /**
     * Better name?
     */
    public void communicateNext() {
        key++;
        if (isFinished()) {
            player.getTestDialogueManager().finish();
            return;
        }
        communicate();
    }

    /**
     * Better name? Possibly a better way to do this?
     */
    public void communicateNext(OptionMessage.Option option) {
        OptionMessage message = (OptionMessage) dialogue.get(key);
        message.onClick(option);
        communicate();
    }

    /**
     * I don&#39;t want to obligate the State enum, but its needed for option dialogues. However, if you don&#39;t use the
     * option dialogue, then the key will handle the job for you.
     */
    private boolean isFinished() {
        return state == State.NOT_TALKING || key &gt; dialogue.size();
    }

    /**
     * Used for option dialogue.
     */
    protected void setKey(int key) {
        this.key = key;
        communicate();
    }

    /**
     * I didn&#39;t feel like using @Getter because I wanted this to be protected for security use.
     */
    protected Player getPlayer() {
        return player;
    }
}

[/code]

This Dialogue system sort of gets complicated here - especially when seeing isFinished(). The isFinished() message is complicated due to option dialogue, because the option dialogue then redirects the dialogue to a different key, which sort of disrupts the patterns of +1 key per dialogue. Perhaps this can be simplified if somebody suggests how.

Next, lets manage these Dialogues by making a new class called DialogueManager and add the following in it:
[code=java]
package com.rs.game.player.dialogues.test;

import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.message.OptionMessage;
import lombok.Setter;

/**
 * Created by Arham 4 on 2/15/2016.
 */
public class DialogueManager {

    private final Player player;
    @Setter
    private Dialogue lastDialogue;

    public DialogueManager(Player player) {
        this.player = player;
    }

    public void next() {
        if (lastDialogue == null) {
            return;
        }
        lastDialogue.communicateNext();
    }

    public void start(Dialogue dialogue) {
        if (lastDialogue != null) {
            finish();
        }
        setLastDialogue(dialogue);
        dialogue.buildDialogue();
        dialogue.communicate();
    }

    public void finish() {
        if (lastDialogue == null) {
            return;
        }
        lastDialogue = null;
        if (player.getInterfaceManager().containsChatBoxInter()) {
            player.getInterfaceManager().closeChatBoxInterface();
        }
    }

    /**
     * Better way to do this?
     */
    public void onClick(OptionMessage.Option option) {
        if (lastDialogue == null) {
            return;
        }
        lastDialogue.communicateNext(option);
    }
}
[/code]
onClick is sort of that one random method in this, but ignoring that, this class allows the dialogue system to belong to the player (as noticed by the constructor). I&#39;m still debating whether to make a setPlayer in Dialogue and not make it an obligatory call every time the Dialogue method is called, or just keep it as is.

Next, the messengers are going to be added. Through this, the dialogue will be a) formulated and b) displayed. Prepare for a barrage of classes to add (6 classes). Before doing this, make a new package called &quot;message.&quot; Add the following in the package:
[B]Message[/B]
[code=java]
package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;

/**
 * Created by Arham 4 on 2/15/2016.
 */
public interface Message {

    void executeAction();

    void display(Player player);
}
[/code]
[B]PlainMessage[/B]
[code=java]
package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;

/**
 * Created by admin on 2/15/2016.
 * &lt;p&gt;
 * Represents a plain message, with no entities in the dialogue.
 */
public class PlainMessage implements Message {

    private final String[] message;

    public PlainMessage(String... message) {
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (int line = 0; line &lt; message.length; line++)
            builder.append(line == 0 ? &quot;&lt;p=1&gt;&quot; : &quot;&lt;br&gt;&quot;).append(message[line]);
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1186);
        player.getPackets().sendIComponentText(1186, 1, text);
    }
}
[/code]
[B]PlayerMessage[/B]
[code=java]
package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.Expression;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular message with a Player talking.
 */
public class PlayerMessage implements Message {

    private final Expression expression;
    private final String[] message;

    public PlayerMessage(Expression expression, String... message) {
        this.expression = expression;
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (String line : message) {
            builder.append(&quot; &quot;).append(line);
        }
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1191);
        player.getPackets().sendIComponentText(1191, 8, player.getDisplayName());
        player.getPackets().sendIComponentText(1191, 17, text);
        player.getPackets().sendPlayerOnIComponent(1191, 15);
        player.getPackets().sendIComponentAnimation(expression.getId(), 1191, 15);
    }

    /**
     * Should I just do this with a boolean?
     */
    public class NonContinuable extends PlayerMessage {

        public NonContinuable(Expression expression, String... message) {
            super(expression, message);
        }

        /**
         * DO NOT OVERRIDE
         */
        @Override
        public void display(Player player) {
            StringBuilder builder = new StringBuilder();
            for (String line : message) {
                builder.append(&quot; &quot;).append(line);
            }
            String text = builder.toString();
            player.getInterfaceManager().replaceRealChatBoxInterface(1192);
            player.getPackets().sendIComponentText(1192, 16, player.getDisplayName());
            player.getPackets().sendIComponentText(1192, 12, text);
            player.getPackets().sendPlayerOnIComponent(1192, 11);
            player.getPackets().sendIComponentAnimation(expression.getId(), 1192, 11);
        }
    }
}
[/code]
[B]NPCMessage[/B]
[code=java]
package com.rs.game.player.dialogues.test.message;

import com.rs.cache.loaders.NPCDefinitions;
import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.Expression;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular message with an NPC talking.
 */
public class NPCMessage implements Message {

    private final Expression expression;
    private final int npcId;
    private final String[] message;

    public NPCMessage(int npcId, Expression expression, String... message) {
        this.npcId = npcId;
        this.expression = expression;
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (String line : message) {
            builder.append(&quot; &quot;).append(line);
        }
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1184);
        player.getPackets().sendIComponentText(1184, 17, NPCDefinitions.getNPCDefinitions(npcId).getName());
        player.getPackets().sendIComponentText(1184, 13, text);
        player.getPackets().sendNPCOnIComponent(1184, 11, npcId);
        player.getPackets().sendIComponentAnimation(expression.getId(), 1184, 11);
    }

    /**
     * Should I just do this with a boolean?
     */
    public class NonContinuable extends NPCMessage {

        public NonContinuable(int npcId, Expression expression, String... message) {
            super(npcId, expression, message);
        }

        /**
         * DO NOT OVERRIDE
         */
        @Override
        public void display(Player player) {
            StringBuilder builder = new StringBuilder();
            for (String line : message) {
                builder.append(&quot; &quot;).append(line);
            }
            String text = builder.toString();
            player.getInterfaceManager().replaceRealChatBoxInterface(1192);
            player.getPackets().sendIComponentText(1192, 16, NPCDefinitions.getNPCDefinitions(npcId).getName());
            player.getPackets().sendIComponentText(1192, 12, text);
            player.getPackets().sendEntityOnIComponent(false, npcId, 1192, 11);
            player.getPackets().sendIComponentAnimation(expression.getId(), 1192, 11);
        }
    }
}
[/code]
[B]ItemMessage[/B]
[code=java]
package com.rs.game.player.dialogues.test.message;

import com.rs.game.item.Item;
import com.rs.game.player.Player;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular message with an Item in it.
 */
public class ItemMessage implements Message {

    private final Item item;
    private final String[] message;

    public ItemMessage(Item item, String... message) {
        this.item = item;
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (String line : message) {
            builder.append(&quot; &quot;).append(line);
        }
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1189);
        player.getPackets().sendItemOnIComponent(1189, 1, item.getId(), item.getAmount());
        player.getPackets().sendIComponentText(1189, 4, text);
    }

    /**
     * Should I just do this with a boolean?
     */
    public class NonContinuable extends ItemMessage {

        public NonContinuable(Item item, String... message) {
            super(item, message);
        }

        /**
         * DO NOT OVERRIDE
         */
        @Override
        public void display(Player player) {
            StringBuilder builder = new StringBuilder();
            for (String line : message) {
                builder.append(&quot; &quot;).append(line);
            }
            String text = builder.toString();
            player.getInterfaceManager().replaceRealChatBoxInterface(1190);
            player.getPackets().sendItemOnIComponent(1190, 1, item.getId(), item.getAmount());
            player.getPackets().sendIComponentText(1190, 4, text);
        }
    }
}
[/code]
[B]OptionDialogue[/B]
[code=java]
package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;
import lombok.Getter;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular option dialogue with onClick handling each option.
 */

/**
 * I was thinking about maybe even making a SubDialogue class for the option dialogue. Though, I think that&#39;s
 * complicating things.
 */
public abstract class OptionMessage implements Message {

    public static final int OPTION_INTERFACE = 1188;
    public static final String DEFAULT_TITLE = &quot;Select an Option&quot;;

    private final String title;
    private final String[] options;

    public OptionMessage(String title, String... options) {
        this.title = title;
        this.options = options;
    }

    public abstract void onClick(Option option);

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        player.getInterfaceManager().sendChatBoxInterface(1188);
        player.getPackets().sendIComponentText(1188, 20, title);
        for (int line = 0; line &lt; 5; line++) {
            if (line &lt; options.length) {
                if (line == 0)
                    player.getPackets().sendIComponentText(1188, 3, options[line]);
                else if (line == 1)
                    player.getPackets().sendIComponentText(1188, 24, options[line]);
                else if (line == 2)
                    player.getPackets().sendIComponentText(1188, 29, options[line]);
                else if (line == 3)
                    player.getPackets().sendIComponentText(1188, 34, options[line]);
                else if (line == 4)
                    player.getPackets().sendIComponentText(1188, 39, options[line]);
            } else {
                if (line == 2) {
                    player.getPackets().sendHideIComponent(1188, 14, true);
                } else if (line == 3) {
                    player.getPackets().sendHideIComponent(1188, 15, true);
                } else if (line == 4) {
                    player.getPackets().sendHideIComponent(1188, 16, true);
                }
            }
        }
    }

    public enum Option {
        ONE(11), TWO(13), THREE(14), FOUR(15), FIVE(16);

        private static final List&lt;Option&gt; VALUES = Collections.unmodifiableList(Arrays.asList(values()));
        @Getter
        private final int componentId;

        Option(int componentId) {
            this.componentId = componentId;
        }

        public static Option getOption(int componentId) {
            for (Option option : VALUES) {
                if (option.getComponentId() == componentId) {
                    return option;
                }
            }
            return null;
        }
    }
}
[/code]

Next, make an &quot;impl&quot; package. Here is where all your dialogue will be.

[SIZE=5][B]Integrating the System[/B][/SIZE]

What we&#39;re going to be doing next is just a bunch of adding our dialogue system in place of the old one, to allow our system to finish properly and continue the dialogue properly.

Add the following to Player.java:
[code=java]
private transient DialogueManager testDialogueManager;
[/code]
We&#39;re going to name it testDialogueManager because of the amount of times our current system is called. [B]Be sure to import the right one! Also, my Player class is a @Data class, if its not for you, make the @Getter for this![/B]

Find the following:
[code=java]
dialogueManager = new 
[/code]
Below this line, add the following:
[code=java]
testDialogueManager = new DialogueManager(this);
[/code]
Errors? Consider doing &quot;com.rs.game.player.dialogue.test.DialogueManager instead of just plain DialogueManager. Do this for the errors later if you see them too.

Next, go to WorldPacketsDecoder and find the following:
[code=java]
if (player.getEquipment().wearingArmour()) {
[/code]
Either delete the finishDialogue() method call there or just add the following beneath it:
[code=java]
player.getTestDialogueManager().finish();
[/code]

Next, find:
[code=java]
player.getSkills().setXp(skillId, Skills.getXPForLevel(value));[/code]
Again, either delete finishDialogue() or add below it:
[code=java]
player.getTestDialogueManager().finish();
[/code]

Next, find:
[code=java]
player.getDialogueManager().continueDialogue(interfaceId
[/code]
And replace it with:
[code=java]
            if (interfaceId == OptionMessage.OPTION_INTERFACE) {
                player.getTestDialogueManager().onClick(OptionMessage.Option.getOption(componentId));
            } else {
                player.getTestDialogueManager().next();
            }
[/code]

The option dialogue is the reason for any bit of complication in this, and you can see its root cause here. Where does the option dialogue continue to? All determined here. Is this a normal dialogue or an option dialogue? *dun dun dun*

Alright, successfully integrated!

[SIZE=5][B]Example[/B][/SIZE]
Lets use our drunk buddy Hans to show us how this dialogue system works.
[code=java]
package com.rs.game.player.dialogues.test.impl;

import com.rs.game.item.Item;
import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.Dialogue;
import com.rs.game.player.dialogues.test.Expression;
import com.rs.game.player.dialogues.test.State;
import com.rs.game.player.dialogues.test.message.ItemMessage;
import com.rs.game.player.dialogues.test.message.NPCMessage;
import com.rs.game.player.dialogues.test.message.OptionMessage;
import com.rs.game.player.dialogues.test.message.PlayerMessage;
import lombok.NonNull;

import java.util.HashMap;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Sample dialogue for the new dialogue system.
 */
public class Hans extends Dialogue {

    private final int npcId;

    public Hans(Player player, int npcId) {
        super(player, new HashMap&lt;&gt;());
        this.npcId = npcId;
    }

    @Override
    public void buildDialogue() {
        dialogue.put(1, new PlayerMessage(Expression.HAPPY, &quot;Hi!&quot;));
        dialogue.put(2, new NPCMessage(npcId, Expression.WEE_DRUNK, &quot;Wassup ma nigga&quot;));
        dialogue.put(3, new PlayerMessage(Expression.QUESTION, &quot;Umm, nothing much?&quot;));
        dialogue.put(4, new NPCMessage(npcId, Expression.WEE_DRUNK, &quot;Wanna be my.. friend..?&quot;));
        dialogue.put(5, new OptionMessage(OptionMessage.DEFAULT_TITLE, &quot;Wtf man?&quot;, &quot;Yess!!, I need friends!!&quot;) {
            /**
             * After seeing this, I feel that onClick could be simplified into something, just what?
             */
            @Override
            public void onClick(@NonNull Option option) {
                switch (option) {
                    case ONE:
                        setKey(6);
                        break;
                    case TWO:
                        setKey(12);
                        break;
                }
            }
        });
        dialogue.put(6, new PlayerMessage(Expression.ANGRY, &quot;Wtf man?&quot;));
        dialogue.put(7, new NPCMessage(npcId, Expression.WEE_DRUNK, &quot;Idk man, I&#39;m drunk..&quot;));
        dialogue.put(8, new PlayerMessage(Expression.GET_OFF_MY_LAWN, &quot;Just, stop.&quot;));
        dialogue.put(9, new NPCMessage(npcId, Expression.WEE_DRUNK, &quot;Take some money?&quot;));
        /*
         * I wanted to use the val type that Lombok provides, but there&#39;s a glitch with it which makes the enum spit out
         * &quot;cannot call super method in enumeration&quot; even though the val variable is all the way here and the enum is
         * in the OptionMessage? So stupid... Oh well.
         */
        final Item money = new Item(995, 20000);
        dialogue.put(10, new ItemMessage(money, &quot;The man gives you some money.&quot;) {
            @Override
            public void executeAction() {
                getPlayer().getInventory().addItem(money);
            }
        });
        dialogue.put(11, new PlayerMessage(Expression.HAPPY_EYEBROWS, &quot;Omg thank u!!!&quot;) {
            @Override
            public void executeAction() {
                state = State.NOT_TALKING;
            }
        });
        dialogue.put(12, new PlayerMessage(Expression.HAPPY_EYEBROWS, &quot;Yess!!, I need friends!!&quot;));
        dialogue.put(13, new NPCMessage(npcId, Expression.HAPPY_EYEBROWS, &quot;YAYYYYY!&quot;));
    }
}
[/code]
And in NPCHandler&#39;s handleOption1():
[code=java]
                if (npc.getId() == 0) {
                    player.getTestDialogueManager().start(new Hans(player, npc.getId()));
                }
[/code]

As you can see, you can summarize a lot of functions pretty concisely.

[hr]

- Arham</description>
    
    <lastBuildDate>Mon, 11 Apr 2016 01:01:45 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>[NEED INPUT] New Dialogue System - For the Intermediate Programmer</title>
        <dc:creator><![CDATA[@arham_4 arham 4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/arham_4">@arham_4</a> wrote:</p>
          <blockquote>
              <p>[quote=“Sessy Pk3r, post:4, topic:554748”]Very dynamic AND low extensibility? Sounds like a contradiction.</p>
<p><span class="mention">@OP</span> How would you go about adding function to each option of the optionMessage? From the looks of the implementation, it could get very messy very fast.[/quote]<br>
onClick method is there for that. Either do it then set key or add an executeAction to the key that is being set.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/5</link>
        <pubDate>Mon, 11 Apr 2016 01:01:45 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-554748-5</guid>
        <source url="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748.rss">[NEED INPUT] New Dialogue System - For the Intermediate Programmer</source>
      </item>
      <item>
        <title>[NEED INPUT] New Dialogue System - For the Intermediate Programmer</title>
        <dc:creator><![CDATA[@Sessy_Pk3r Sessy Pk3r]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sessy_pk3r">@Sessy_Pk3r</a> wrote:</p>
          <blockquote>
              <p>Very dynamic AND low extensibility? Sounds like a contradiction.</p>
<p><span class="mention">@OP</span> How would you go about adding function to each option of the optionMessage? From the looks of the implementation, it could get very messy very fast.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/4</link>
        <pubDate>Sun, 10 Apr 2016 06:21:01 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-554748-4</guid>
        <source url="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748.rss">[NEED INPUT] New Dialogue System - For the Intermediate Programmer</source>
      </item>
      <item>
        <title>[NEED INPUT] New Dialogue System - For the Intermediate Programmer</title>
        <dc:creator><![CDATA[@Xversial Xversial]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xversial">@Xversial</a> wrote:</p>
          <blockquote>
              <p>This lacks simplicity and elegance as well, this adds unnecessary overhead. I think that you would be much better off just handling the dialogue through either:</p>
<p>[ul]    [li]A simple (Soft Recursive) method with a progressive switch statement (The best for a quick and extendable solution)[/li]<br>
[li]Load dialogue through the database (Dialogue loads through row-based order referencing, and possibly multiple cross-referencing tables)<br>
[list]<br>
[li]Pros<br>
[list]<br>
[li]Organized data[/li]<br>
[li]Very dynamic[/li]<br>
[li]Highly scalable[/li]<br>
[li]High performance[/li]<br>
[/list]<br>
[/li]<br>
[li]Cons<br>
[list]<br>
[li]Extremely low extensibility[/li]<br>
[/list]<br>
[/li]<br>
[/list]<br>
[/li]<br>
[li]A proprietary (or if time is an issue, third-party) scripting engine that allows you to:<br>
[list]<br>
[li]dynamically load dialogue[/li]<br>
[li]simply write dialogue[/li]<br>
[li]statically compile the scripts[/li]<br>
[li]cache them in-memory (reading them from the disk every time would just be silly)[/li]<br>
[/list]<br>
[/li][/ul]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/3</link>
        <pubDate>Sat, 12 Mar 2016 07:06:03 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-554748-3</guid>
        <source url="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748.rss">[NEED INPUT] New Dialogue System - For the Intermediate Programmer</source>
      </item>
      <item>
        <title>[NEED INPUT] New Dialogue System - For the Intermediate Programmer</title>
        <dc:creator><![CDATA[@tehjamdude tehjamdude]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/tehjamdude">@tehjamdude</a> wrote:</p>
          <blockquote>
              <p>Wait, why has no one replied to this???</p>
<p>I haven’t been on these forums forever but this looks awesome… Im just getting back into RSPS again</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/2</link>
        <pubDate>Wed, 09 Mar 2016 16:59:35 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-554748-2</guid>
        <source url="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748.rss">[NEED INPUT] New Dialogue System - For the Intermediate Programmer</source>
      </item>
      <item>
        <title>[NEED INPUT] New Dialogue System - For the Intermediate Programmer</title>
        <dc:creator><![CDATA[@arham_4 arham 4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/arham_4">@arham_4</a> wrote:</p>
          <blockquote>
              <p>[CENTER]<img src="http://puu.sh/n9y6z/710d772ea0.png" alt width="212" height="298">[/CENTER]</p>
<p>Since I am a content developer, I figured I would start revamping some current systems to make my content spew out faster. Thus, this came. Made in approximately 2 hours.</p>
<p>[B][COLOR="<span class="hashtag">#FF0000</span>"]Some things I’m unsure about or have questions on are stated in the code comments.[/COLOR][/B]</p>
<p>[hr]</p>
<p>[B]Requirements: [URL=http://“<a href="https://projectlombok.org/" rel="nofollow noopener">https://projectlombok.org/</a>”]Project Lombok[/URL][/B]</p>
<p>[SIZE=5][B]Implementing the System[/B][/SIZE]</p>
<p>To start off, make a new enum called State. In it, add this:</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test;

/**
 * Created by Arham 4 on 2/15/2016.
 * 
 * I'm not sure about using this, but can't find a better way to do this. I need this for Option dialogue.
 */
public enum State {
    TALKING, NOT_TALKING
}
</code></pre>
<p>This represents the current state of a dialogue.</p>
<p>Next, make a new enum in the same area and name it Expression. In it, add this:</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test;

import lombok.Getter;

/**
 * Created by Arham 4 on 2/15/2016.
 *
 * Think some of these names could be improved lol.
 */
public enum Expression {

    TERRIFIED(9750),
    TERRIFIED_NO_YELL(9753),
    THANK_YOU(9757),
    SAD(9760),
    SADDER(9761),
    SADDER_LOOKS_RIGHT(9762),
    SADDEST_DISGRACED(9765),
    SADDEST(9768),
    NEAR_TO_SAD(9769),
    SCARED_GET_AWAY_FROM_ME(9773),
    SCARED_PINCHED_EYES(9777),
    SCARED(9780),
    GET_OFF_MY_LAWN(9781),
    GET_OFF_MY_LAWN_ANGRIER(9782),
    GET_OFF_MY_LAWN_ANGRIEST(9783),
    ANGRY(9789),
    ANGRY_MOVING_FACE_ONLY(9792),
    MOVE_HEAD_FRONT_AND_BACK(9793),
    SLEEPY(9802),
    NEUTRAL(9803),
    BLINKING(9804),
    PARANOID(9806),
    PARANOID_AT_PLAYER(9808),
    INVESTIGATIVE(9811),
    TALK_TO_RIGHT(9814),
    QUESTION(9827),
    PLAIN_LOOK(9830),
    INVESTIGATIVE_TALKING(9831),
    WEE_DRUNK(9835),
    WISE(9836),
    VERY_JOLLY(9840),
    FUN_LAUGHING(9841),
    EVIL_MUHAHAHA(9842),
    GET_OFF_MY_LAWN_HAPPY(9843),
    HAPPY_EYEBROWS(9847),
    HAPPY(9850),
    VERY_FUN_LAUGHING(9851),
    BEGGING(9877),
    STICK_TONGUE_OUT(9878);

    @Getter
    private final int id;

    Expression(int id) {
        this.id = id;
    }
}</code></pre>
<p>This represents the player and NPC expressions in the 718 cache.</p>
<p>Next, we need to make the class that represents a Dialogue, so make a new class and name it Dialogue. Add this in it:</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test;

import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.message.Message;
import com.rs.game.player.dialogues.test.message.OptionMessage;

import java.util.HashMap;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a Dialogue (which contains Messages)
 */

/**
 * Thinking about using a builder for this for short dialogues? I don't know.
 */
public abstract class Dialogue {

    protected final HashMap&lt;Integer, Message&gt; dialogue;
    /**
     * I can't think of any other way to handle option dialogue closing rather than States.
     */
    protected State state;
    private Player player;

    private int key = 1;

    /**
     * @param dialogue So I can assure a new dialogue is being made per class rather than reusing the same one per class.
     */
    protected Dialogue(Player player, HashMap&lt;Integer, Message&gt; dialogue) {
        this.player = player;
        this.dialogue = dialogue;
        state = State.TALKING;
    }

    /**
     * Where we make the magic with the dialogue HashMap happen.
     */
    public abstract void buildDialogue();

    public void communicate() {
        dialogue.get(key).display(player);
        dialogue.get(key).executeAction();
    }

    /**
     * Better name?
     */
    public void communicateNext() {
        key++;
        if (isFinished()) {
            player.getTestDialogueManager().finish();
            return;
        }
        communicate();
    }

    /**
     * Better name? Possibly a better way to do this?
     */
    public void communicateNext(OptionMessage.Option option) {
        OptionMessage message = (OptionMessage) dialogue.get(key);
        message.onClick(option);
        communicate();
    }

    /**
     * I don't want to obligate the State enum, but its needed for option dialogues. However, if you don't use the
     * option dialogue, then the key will handle the job for you.
     */
    private boolean isFinished() {
        return state == State.NOT_TALKING || key &gt; dialogue.size();
    }

    /**
     * Used for option dialogue.
     */
    protected void setKey(int key) {
        this.key = key;
        communicate();
    }

    /**
     * I didn't feel like using @Getter because I wanted this to be protected for security use.
     */
    protected Player getPlayer() {
        return player;
    }
}
</code></pre>
<p>This Dialogue system sort of gets complicated here - especially when seeing isFinished(). The isFinished() message is complicated due to option dialogue, because the option dialogue then redirects the dialogue to a different key, which sort of disrupts the patterns of +1 key per dialogue. Perhaps this can be simplified if somebody suggests how.</p>
<p>Next, lets manage these Dialogues by making a new class called DialogueManager and add the following in it:</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test;

import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.message.OptionMessage;
import lombok.Setter;

/**
 * Created by Arham 4 on 2/15/2016.
 */
public class DialogueManager {

    private final Player player;
    @Setter
    private Dialogue lastDialogue;

    public DialogueManager(Player player) {
        this.player = player;
    }

    public void next() {
        if (lastDialogue == null) {
            return;
        }
        lastDialogue.communicateNext();
    }

    public void start(Dialogue dialogue) {
        if (lastDialogue != null) {
            finish();
        }
        setLastDialogue(dialogue);
        dialogue.buildDialogue();
        dialogue.communicate();
    }

    public void finish() {
        if (lastDialogue == null) {
            return;
        }
        lastDialogue = null;
        if (player.getInterfaceManager().containsChatBoxInter()) {
            player.getInterfaceManager().closeChatBoxInterface();
        }
    }

    /**
     * Better way to do this?
     */
    public void onClick(OptionMessage.Option option) {
        if (lastDialogue == null) {
            return;
        }
        lastDialogue.communicateNext(option);
    }
}</code></pre>
<p>onClick is sort of that one random method in this, but ignoring that, this class allows the dialogue system to belong to the player (as noticed by the constructor). I’m still debating whether to make a setPlayer in Dialogue and not make it an obligatory call every time the Dialogue method is called, or just keep it as is.</p>
<p>Next, the messengers are going to be added. Through this, the dialogue will be a) formulated and b) displayed. Prepare for a barrage of classes to add (6 classes). Before doing this, make a new package called “message.” Add the following in the package:<br>
[B]Message[/B]</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;

/**
 * Created by Arham 4 on 2/15/2016.
 */
public interface Message {

    void executeAction();

    void display(Player player);
}</code></pre>
<p>[B]PlainMessage[/B]</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;

/**
 * Created by admin on 2/15/2016.
 * &lt;p&gt;
 * Represents a plain message, with no entities in the dialogue.
 */
public class PlainMessage implements Message {

    private final String[] message;

    public PlainMessage(String... message) {
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (int line = 0; line &lt; message.length; line++)
            builder.append(line == 0 ? "&lt;p=1&gt;" : "&lt;br&gt;").append(message[line]);
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1186);
        player.getPackets().sendIComponentText(1186, 1, text);
    }
}</code></pre>
<p>[B]PlayerMessage[/B]</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.Expression;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular message with a Player talking.
 */
public class PlayerMessage implements Message {

    private final Expression expression;
    private final String[] message;

    public PlayerMessage(Expression expression, String... message) {
        this.expression = expression;
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (String line : message) {
            builder.append(" ").append(line);
        }
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1191);
        player.getPackets().sendIComponentText(1191, 8, player.getDisplayName());
        player.getPackets().sendIComponentText(1191, 17, text);
        player.getPackets().sendPlayerOnIComponent(1191, 15);
        player.getPackets().sendIComponentAnimation(expression.getId(), 1191, 15);
    }

    /**
     * Should I just do this with a boolean?
     */
    public class NonContinuable extends PlayerMessage {

        public NonContinuable(Expression expression, String... message) {
            super(expression, message);
        }

        /**
         * DO NOT OVERRIDE
         */
        @Override
        public void display(Player player) {
            StringBuilder builder = new StringBuilder();
            for (String line : message) {
                builder.append(" ").append(line);
            }
            String text = builder.toString();
            player.getInterfaceManager().replaceRealChatBoxInterface(1192);
            player.getPackets().sendIComponentText(1192, 16, player.getDisplayName());
            player.getPackets().sendIComponentText(1192, 12, text);
            player.getPackets().sendPlayerOnIComponent(1192, 11);
            player.getPackets().sendIComponentAnimation(expression.getId(), 1192, 11);
        }
    }
}</code></pre>
<p>[B]NPCMessage[/B]</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test.message;

import com.rs.cache.loaders.NPCDefinitions;
import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.Expression;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular message with an NPC talking.
 */
public class NPCMessage implements Message {

    private final Expression expression;
    private final int npcId;
    private final String[] message;

    public NPCMessage(int npcId, Expression expression, String... message) {
        this.npcId = npcId;
        this.expression = expression;
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (String line : message) {
            builder.append(" ").append(line);
        }
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1184);
        player.getPackets().sendIComponentText(1184, 17, NPCDefinitions.getNPCDefinitions(npcId).getName());
        player.getPackets().sendIComponentText(1184, 13, text);
        player.getPackets().sendNPCOnIComponent(1184, 11, npcId);
        player.getPackets().sendIComponentAnimation(expression.getId(), 1184, 11);
    }

    /**
     * Should I just do this with a boolean?
     */
    public class NonContinuable extends NPCMessage {

        public NonContinuable(int npcId, Expression expression, String... message) {
            super(npcId, expression, message);
        }

        /**
         * DO NOT OVERRIDE
         */
        @Override
        public void display(Player player) {
            StringBuilder builder = new StringBuilder();
            for (String line : message) {
                builder.append(" ").append(line);
            }
            String text = builder.toString();
            player.getInterfaceManager().replaceRealChatBoxInterface(1192);
            player.getPackets().sendIComponentText(1192, 16, NPCDefinitions.getNPCDefinitions(npcId).getName());
            player.getPackets().sendIComponentText(1192, 12, text);
            player.getPackets().sendEntityOnIComponent(false, npcId, 1192, 11);
            player.getPackets().sendIComponentAnimation(expression.getId(), 1192, 11);
        }
    }
}</code></pre>
<p>[B]ItemMessage[/B]</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test.message;

import com.rs.game.item.Item;
import com.rs.game.player.Player;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular message with an Item in it.
 */
public class ItemMessage implements Message {

    private final Item item;
    private final String[] message;

    public ItemMessage(Item item, String... message) {
        this.item = item;
        this.message = message;
    }

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        StringBuilder builder = new StringBuilder();
        for (String line : message) {
            builder.append(" ").append(line);
        }
        String text = builder.toString();
        player.getInterfaceManager().sendChatBoxInterface(1189);
        player.getPackets().sendItemOnIComponent(1189, 1, item.getId(), item.getAmount());
        player.getPackets().sendIComponentText(1189, 4, text);
    }

    /**
     * Should I just do this with a boolean?
     */
    public class NonContinuable extends ItemMessage {

        public NonContinuable(Item item, String... message) {
            super(item, message);
        }

        /**
         * DO NOT OVERRIDE
         */
        @Override
        public void display(Player player) {
            StringBuilder builder = new StringBuilder();
            for (String line : message) {
                builder.append(" ").append(line);
            }
            String text = builder.toString();
            player.getInterfaceManager().replaceRealChatBoxInterface(1190);
            player.getPackets().sendItemOnIComponent(1190, 1, item.getId(), item.getAmount());
            player.getPackets().sendIComponentText(1190, 4, text);
        }
    }
}</code></pre>
<p>[B]OptionDialogue[/B]</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test.message;

import com.rs.game.player.Player;
import lombok.Getter;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Represents a singular option dialogue with onClick handling each option.
 */

/**
 * I was thinking about maybe even making a SubDialogue class for the option dialogue. Though, I think that's
 * complicating things.
 */
public abstract class OptionMessage implements Message {

    public static final int OPTION_INTERFACE = 1188;
    public static final String DEFAULT_TITLE = "Select an Option";

    private final String title;
    private final String[] options;

    public OptionMessage(String title, String... options) {
        this.title = title;
        this.options = options;
    }

    public abstract void onClick(Option option);

    @Override
    public void executeAction() {
    }

    /**
     * DO NOT OVERRIDE
     */
    @Override
    public void display(Player player) {
        player.getInterfaceManager().sendChatBoxInterface(1188);
        player.getPackets().sendIComponentText(1188, 20, title);
        for (int line = 0; line &lt; 5; line++) {
            if (line &lt; options.length) {
                if (line == 0)
                    player.getPackets().sendIComponentText(1188, 3, options[line]);
                else if (line == 1)
                    player.getPackets().sendIComponentText(1188, 24, options[line]);
                else if (line == 2)
                    player.getPackets().sendIComponentText(1188, 29, options[line]);
                else if (line == 3)
                    player.getPackets().sendIComponentText(1188, 34, options[line]);
                else if (line == 4)
                    player.getPackets().sendIComponentText(1188, 39, options[line]);
            } else {
                if (line == 2) {
                    player.getPackets().sendHideIComponent(1188, 14, true);
                } else if (line == 3) {
                    player.getPackets().sendHideIComponent(1188, 15, true);
                } else if (line == 4) {
                    player.getPackets().sendHideIComponent(1188, 16, true);
                }
            }
        }
    }

    public enum Option {
        ONE(11), TWO(13), THREE(14), FOUR(15), FIVE(16);

        private static final List&lt;Option&gt; VALUES = Collections.unmodifiableList(Arrays.asList(values()));
        @Getter
        private final int componentId;

        Option(int componentId) {
            this.componentId = componentId;
        }

        public static Option getOption(int componentId) {
            for (Option option : VALUES) {
                if (option.getComponentId() == componentId) {
                    return option;
                }
            }
            return null;
        }
    }
}</code></pre>
<p>Next, make an “impl” package. Here is where all your dialogue will be.</p>
<p>[SIZE=5][B]Integrating the System[/B][/SIZE]</p>
<p>What we’re going to be doing next is just a bunch of adding our dialogue system in place of the old one, to allow our system to finish properly and continue the dialogue properly.</p>
<p>Add the following to Player.java:</p>
<pre><code class="lang-auto">private transient DialogueManager testDialogueManager;</code></pre>
<p>We’re going to name it testDialogueManager because of the amount of times our current system is called. [B]Be sure to import the right one! Also, my Player class is a <a class="mention" href="/u/data">@Data</a> class, if its not for you, make the <span class="mention">@Getter</span> for this![/B]</p>
<p>Find the following:</p>
<pre><code class="lang-auto">dialogueManager = new </code></pre>
<p>Below this line, add the following:</p>
<pre><code class="lang-auto">testDialogueManager = new DialogueManager(this);</code></pre>
<p>Errors? Consider doing "com.rs.game.player.dialogue.test.DialogueManager instead of just plain DialogueManager. Do this for the errors later if you see them too.</p>
<p>Next, go to WorldPacketsDecoder and find the following:</p>
<pre><code class="lang-auto">if (player.getEquipment().wearingArmour()) {</code></pre>
<p>Either delete the finishDialogue() method call there or just add the following beneath it:</p>
<pre><code class="lang-auto">player.getTestDialogueManager().finish();</code></pre>
<p>Next, find:</p>
<p><code>
player.getSkills().setXp(skillId, Skills.getXPForLevel(value));</code><br>
Again, either delete finishDialogue() or add below it:</p>
<pre><code class="lang-auto">player.getTestDialogueManager().finish();</code></pre>
<p>Next, find:</p>
<pre><code class="lang-auto">player.getDialogueManager().continueDialogue(interfaceId</code></pre>
<p>And replace it with:</p>
<pre><code class="lang-auto">            if (interfaceId == OptionMessage.OPTION_INTERFACE) {
                player.getTestDialogueManager().onClick(OptionMessage.Option.getOption(componentId));
            } else {
                player.getTestDialogueManager().next();
            }</code></pre>
<p>The option dialogue is the reason for any bit of complication in this, and you can see its root cause here. Where does the option dialogue continue to? All determined here. Is this a normal dialogue or an option dialogue? <em>dun dun dun</em></p>
<p>Alright, successfully integrated!</p>
<p>[SIZE=5][B]Example[/B][/SIZE]<br>
Lets use our drunk buddy Hans to show us how this dialogue system works.</p>
<pre><code class="lang-auto">package com.rs.game.player.dialogues.test.impl;

import com.rs.game.item.Item;
import com.rs.game.player.Player;
import com.rs.game.player.dialogues.test.Dialogue;
import com.rs.game.player.dialogues.test.Expression;
import com.rs.game.player.dialogues.test.State;
import com.rs.game.player.dialogues.test.message.ItemMessage;
import com.rs.game.player.dialogues.test.message.NPCMessage;
import com.rs.game.player.dialogues.test.message.OptionMessage;
import com.rs.game.player.dialogues.test.message.PlayerMessage;
import lombok.NonNull;

import java.util.HashMap;

/**
 * Created by Arham 4 on 2/15/2016.
 * &lt;p&gt;
 * Sample dialogue for the new dialogue system.
 */
public class Hans extends Dialogue {

    private final int npcId;

    public Hans(Player player, int npcId) {
        super(player, new HashMap&lt;&gt;());
        this.npcId = npcId;
    }

    @Override
    public void buildDialogue() {
        dialogue.put(1, new PlayerMessage(Expression.HAPPY, "Hi!"));
        dialogue.put(2, new NPCMessage(npcId, Expression.WEE_DRUNK, "Wassup ma nigga"));
        dialogue.put(3, new PlayerMessage(Expression.QUESTION, "Umm, nothing much?"));
        dialogue.put(4, new NPCMessage(npcId, Expression.WEE_DRUNK, "Wanna be my.. friend..?"));
        dialogue.put(5, new OptionMessage(OptionMessage.DEFAULT_TITLE, "Wtf man?", "Yess!!, I need friends!!") {
            /**
             * After seeing this, I feel that onClick could be simplified into something, just what?
             */
            @Override
            public void onClick(@NonNull Option option) {
                switch (option) {
                    case ONE:
                        setKey(6);
                        break;
                    case TWO:
                        setKey(12);
                        break;
                }
            }
        });
        dialogue.put(6, new PlayerMessage(Expression.ANGRY, "Wtf man?"));
        dialogue.put(7, new NPCMessage(npcId, Expression.WEE_DRUNK, "Idk man, I'm drunk.."));
        dialogue.put(8, new PlayerMessage(Expression.GET_OFF_MY_LAWN, "Just, stop."));
        dialogue.put(9, new NPCMessage(npcId, Expression.WEE_DRUNK, "Take some money?"));
        /*
         * I wanted to use the val type that Lombok provides, but there's a glitch with it which makes the enum spit out
         * "cannot call super method in enumeration" even though the val variable is all the way here and the enum is
         * in the OptionMessage? So stupid... Oh well.
         */
        final Item money = new Item(995, 20000);
        dialogue.put(10, new ItemMessage(money, "The man gives you some money.") {
            @Override
            public void executeAction() {
                getPlayer().getInventory().addItem(money);
            }
        });
        dialogue.put(11, new PlayerMessage(Expression.HAPPY_EYEBROWS, "Omg thank u!!!") {
            @Override
            public void executeAction() {
                state = State.NOT_TALKING;
            }
        });
        dialogue.put(12, new PlayerMessage(Expression.HAPPY_EYEBROWS, "Yess!!, I need friends!!"));
        dialogue.put(13, new NPCMessage(npcId, Expression.HAPPY_EYEBROWS, "YAYYYYY!"));
    }
}</code></pre>
<p>And in NPCHandler’s handleOption1():</p>
<pre><code class="lang-auto">                if (npc.getId() == 0) {
                    player.getTestDialogueManager().start(new Hans(player, npc.getId()));
                }</code></pre>
<p>As you can see, you can summarize a lot of functions pretty concisely.</p>
<p>[hr]</p>
<ul>
<li>Arham</li>
</ul>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748/1</link>
        <pubDate>Tue, 16 Feb 2016 02:59:02 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-554748-1</guid>
        <source url="https://forum.moparisthebest.com/t/need-input-new-dialogue-system-for-the-intermediate-programmer/554748.rss">[NEED INPUT] New Dialogue System - For the Intermediate Programmer</source>
      </item>
  </channel>
</rss>
