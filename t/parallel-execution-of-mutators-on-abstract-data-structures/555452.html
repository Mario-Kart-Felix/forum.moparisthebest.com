<!DOCTYPE html>
<html lang="en-US">
  
<!-- Mirrored from forum.moparisthebest.com/t/parallel-execution-of-mutators-on-abstract-data-structures/555452 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:13 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>Parallel Execution of Mutators on Abstract Data Structures - Runescape - moparisthebest.com</title>
    <meta name="description" content="The jist: 

This algorithm is meant to calculate the order that mutators, or functions that modify data containers, must be executed in parallel without any race conditions. This assumes that all of the mutators being ca&amp;hellip;">
    <meta name="generator" content="Discourse 2.3.2 - https://github.com/discourse/discourse version c587df7e2a03c2962f4c8cefd6f03969bb87d525">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/1/1f0dc167bcf798bdbd70b03bf0fd1bc836e54e1a_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff_2_180x180.png">
<meta name="theme-color" content="#0088cc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="555452.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.moparisthebest.com","potentialAction":{"@type":"SearchAction","target":"https://forum.moparisthebest.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="moparisthebest.com Search">

      <link href="../../stylesheets/desktop_1_ec9f75e3d0b2a904642ce53663991837b70cda3334fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="../../stylesheets/desktop_theme_2_6707e7ee46ac9f2f0510c29ddd10e8f6ce21c1ae34fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;Parallel Execution of Mutators on Abstract Data Structures&#39;" href="555452.rss" />
  <meta property="og:site_name" content="moparisthebest.com" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:url" content="https://forum.moparisthebest.com/t/parallel-execution-of-mutators-on-abstract-data-structures/555452" />
<meta name="twitter:url" content="https://forum.moparisthebest.com/t/parallel-execution-of-mutators-on-abstract-data-structures/555452" />
<meta property="og:title" content="Parallel Execution of Mutators on Abstract Data Structures" />
<meta name="twitter:title" content="Parallel Execution of Mutators on Abstract Data Structures" />
<meta property="og:description" content="The jist:  This algorithm is meant to calculate the order that mutators, or functions that modify data containers, must be executed in parallel without any race conditions. This assumes that all of the mutators being called are instantaneous and without step. Further expansion on that would require that mutators indicate an argument for their presidence. I have not worked on exactly how that would function but I imagine it wouldn’t take too much thought.  The concept for gaming in this algorithm..." />
<meta name="twitter:description" content="The jist:  This algorithm is meant to calculate the order that mutators, or functions that modify data containers, must be executed in parallel without any race conditions. This assumes that all of the mutators being called are instantaneous and without step. Further expansion on that would require that mutators indicate an argument for their presidence. I have not worked on exactly how that would function but I imagine it wouldn’t take too much thought.  The concept for gaming in this algorithm..." />
<meta property="article:published_time" content="2016-05-21T01:37:58+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html">
          <img src="../../uploads/default/original/2X/3/37bba8fb3bd06c372ab54fa72ec38bf9f8f40b37.gif" alt="moparisthebest.com" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1 class="crawler-topic-title">
  <a href="555452.html">Parallel Execution of Mutators on Abstract Data Structures</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
        itemref="breadcrumb-1"
      >
      <a href="../../c/games.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>Games</span>
      </a>
    </div>
    <div id="breadcrumb-1" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/games/runescape.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>Runescape</span>
      </a>
    </div>
</div>





  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/_nova1.html'><span itemprop='name'>_nova1</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2016-05-21T01:37:58Z'>
            <time itemprop='dateModified' datetime='2016-08-04T18:31:03Z' class='post-time'>
              August 4, 2016,  6:31pm
            </time>
        <span itemprop='position'>#1</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p><span class="bbcode-u">The jist:</span></p>
<p>This algorithm is meant to calculate the order that mutators, or functions that modify data containers, must be executed in parallel without any race conditions. This assumes that all of the mutators being called are instantaneous and without step. Further expansion on that would require that mutators indicate an argument for their presidence. I have not worked on exactly how that would function but I imagine it wouldn’t take too much thought.</p>
<p>The concept for gaming in this algorithm works as follows:</p>
<p>A). You have a mutator that moves a player north one tile.<br>
B). You have a mutator that changes the text a player has over their head to ‘hello’.<br>
C). You have a mutator that moves a player south one tile.</p>
<p>These mutators explicitly state their dependencies of an abstract data container. These dependencies are components. Components are logical organizations of data.</p>
<p>A). Location<br>
B). HeadText<br>
C). Location</p>
<p>A dependency is described as a pointer to these components which have a universal identifier. This algorithm only works if abstract data containers do not share components. You can describe these components as pointers then create a list of what dependencies a mutator operating on a data container will access and use the following code to calculate the order in which they have to be executed in parallel. If A, B, C are each mutator different data containers then they can be executed in parallel because they will have access to different data.</p>
<p>However a generalization can be made. This generalization can be made at a macro level for the logical organization of data. This is possible because components of data containers do not have access to any other data container. If it is possible, it makes calculating the dependencies slightly more complex so this rule is employed to simplify the process. We can assume that mutator A and B would not share dependencies to data, and mutator B and C would not as well. However A and C would and therefore could not be ran in parallel in any case.</p>
<p>O(N**2/2) (I believe, correct me if I’m wrong my math is terrible)</p>
<p><span class="bbcode-u">The code</span></p>
<pre><code class="lang-auto">
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Queue;
import java.util.Random;
import java.util.Set;

/**
 * @author hadyn
 */
public class Runner {

  private static final int STATE_COUNT = 5000;
  private static final int MUTATOR_COUNT = 5000;
  private static final int MAXIMUM_DEPS = 8;

  public static void main(String... args) {
    State[] states = new State[STATE_COUNT];
    for (int i = 0; i &lt; STATE_COUNT; i++) {
      states[i] = new State(i);
    }

    Mutator[] mutators = new Mutator[MUTATOR_COUNT];
    for (int i = 0; i &lt; MUTATOR_COUNT; i++) {
      mutators[i] = new Mutator(i);
    }

    // Set up the dependencies.
    Random random = new Random();
    for(int i = 0; i &lt; MUTATOR_COUNT; i++) {
      int count = random.nextInt(MAXIMUM_DEPS - 1) + 1;
      for(int j = 0; j &lt; count; j++) {
        mutators[i].addDependency(states[random.nextInt(STATE_COUNT)]);
      }
    }

    // Start the process of determining which mutators to execute.
    Queue&lt;Mutator&gt; queue = new ArrayDeque&lt;&gt;();
    for(Mutator mutator : mutators) {
      queue.add(mutator);
    }

    System.out.println("Starting...");
    long startTime = System.currentTimeMillis();

    List&lt;ExecutionSet&gt; executionSets = new ArrayList&lt;&gt;();
    int maximumSize = 0;
    while (!queue.isEmpty()) {
      ExecutionSet executionSet = new ExecutionSet();
      executionSets.add(executionSet);

      Mutator start = queue.poll();
      executionSet.addMutator(start.getId());
      queue.add(start);                             // Append it back to the queue as a stopper.

      Set&lt;Mutator&gt; except = new HashSet&lt;&gt;();
      except.addAll(start.getExcept());
      int width = 1;

      Mutator next;
      while(!start.equals(next = queue.poll())) {
        if(except.contains(next)) {
          queue.add(next);
          continue;
        }
        executionSet.addMutator(next.getId());
        except.addAll(next.getExcept());
        width++;
      }
      maximumSize = Math.max(width, maximumSize);
    }

    long elapsed = System.currentTimeMillis() - startTime;
    System.out.println("Elapsed (ms): " + elapsed);
    System.out.println("State count: " + STATE_COUNT);
    System.out.println("Mutator count: " + MUTATOR_COUNT);
    System.out.println("Maximum width: " + maximumSize);
    System.out.println("Maximum dependencies: " + MAXIMUM_DEPS);

    System.out.println();

    System.out.println("Mutators");
    System.out.println("--------");

    for(Mutator mutator : mutators) {
      System.out.println(mutator);
    }

    System.out.println();

    System.out.println("Execution steps");
    System.out.println("---------------");

    int step = 0;
    for(ExecutionSet executionSet : executionSets) {
      System.out.println("Step " + step++ + " | " + executionSet);

    }
  }

  private static class State {
    int id;
    Set&lt;Mutator&gt; mutators = new HashSet&lt;&gt;();

    State(int id) {
      this.id = id;
    }

    public void addRelationship(Mutator mutator) {
      mutators.add(mutator);
    }

    public Set&lt;Mutator&gt; getMutators() {
      return mutators;
    }

    @Override public int hashCode() {
      int hashCode = 1;
      hashCode = hashCode * 31 + id;
      return hashCode;
    }

    @Override public boolean equals(Object obj) {
      if(obj == null) {
        return false;
      }

      if(!(obj instanceof State)) {
        return false;
      }

      State state = (State) obj;
      return id == state.id;
    }

    @Override public String toString() {
      StringBuilder builder = new StringBuilder();
      builder.append("State")
        .append(' ')
        .append(id);
      return builder.toString();
    }

    public int getId() {
      return id;
    }
  }

  private static class Mutator {
    int id;
    Set&lt;State&gt; states = new HashSet&lt;&gt;();
    Set&lt;Mutator&gt; except;

    Mutator(int id) {
      this.id = id;
    }

    public int getId() {
      return id;
    }

    public void addDependency(State state) {
      states.add(state);
      state.addRelationship(this);
    }

    public Set&lt;Mutator&gt; getExcept() {
      if(except != null) {
        return except;
      }
      Set&lt;Mutator&gt; results = new HashSet&lt;&gt;();
      for (State state : states) {
        Set&lt;Mutator&gt; mutators = state.getMutators();
        results.addAll(mutators);
      }
      results.remove(this);
      except = results;
      return results;
    }

    @Override public int hashCode() {
      int hashCode = 1;
      hashCode = hashCode * 31 + id;
      return hashCode;
    }

    @Override public boolean equals(Object obj) {
      if(obj == null) {
        return false;
      }

      if(!(obj instanceof Mutator)) {
        return false;
      }

      Mutator mutator = (Mutator) obj;
      return id == mutator.id;
    }

    @Override public String toString() {
      StringBuilder builder = new StringBuilder();
      builder.append("Mutator ").append(id).append(" | ");

      boolean first = true;
      for (State state : states) {
        if (!first) {
          builder.append(", ");
        }
        builder.append(state.getId());
        first = false;
      }

      return builder.toString();
    }
  }

  private static class ExecutionSet {
    Set&lt;Integer&gt; mutatorIds = new HashSet&lt;&gt;();

    public void addMutator(int id) {
      mutatorIds.add(id);
    }

    @Override public String toString() {
      StringBuilder builder = new StringBuilder();
      builder.append('{');
      boolean first = true;
      for(int mutatorId : mutatorIds) {
        if(!first) {
          builder.append(", ");
        }
        builder.append(mutatorId);
        first = false;
      }
      builder.append('}');
      return builder.toString();
    }
  }
}
</code></pre>
      </div>

      <meta itemprop='headline' content='Parallel Execution of Mutators on Abstract Data Structures'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav' itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <ul>
        <li itemprop="name"><a href='../../index.html' itemprop="url">Home </a></li>
        <li itemprop="name"><a href='../../categories.html' itemprop="url">Categories </a></li>
        <li itemprop="name"><a href='../../guidelines.html' itemprop="url">FAQ/Guidelines </a></li>
        <li itemprop="name"><a href='../../tos.html' itemprop="url">Terms of Service </a></li>
        <li itemprop="name"><a href='../../privacy.html' itemprop="url">Privacy Policy </a></li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
  </body>
  

<!-- Mirrored from forum.moparisthebest.com/t/parallel-execution-of-mutators-on-abstract-data-structures/555452 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:05:13 GMT -->
</html>
