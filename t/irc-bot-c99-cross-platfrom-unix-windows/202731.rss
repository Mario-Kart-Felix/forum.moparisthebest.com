<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
    <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731</link>
    <description>IRC Bot by yakman

Joins one server and one channel
has commands which start with a COMMAND_PREFIX, default is &#39;!&#39;

say [message]  - repeats [message] back to the channel
fact           - parses a website and says a fact
slogan         - parses a website and says an advertising slogan
quote          - parses a website and says a quote
insult [name]  - parses a website and insults [name]

Compiles on unix and windows,
tested with GCC on unix and MinGW on windows

[code]
&lt;yakman&gt; !fact
&lt;slurry_&gt; Nurses and doctors wash their hands between patients less than one-third of the time. 
&lt;yakman&gt; !quote
&lt;slurry_&gt; &quot;People demand freedom of speech to make up for the freedom of thought which they avoid.&quot; - Soren Aabye Kierkegaard (1813-1855) 
&lt;yakman&gt; !say hello world
&lt;slurry_&gt; hello world
&lt;yakman&gt; !slogan
&lt;slurry_&gt; Refreshes the Anxiety Other Beers Cannot Reach
&lt;yakman&gt; !insult Cowie` 
&lt;slurry_&gt; Cowie`: I&#39;d like to see things from your point of view but I can&#39;t seem to get my head that far up my ass.
[/code]


when i was testing this, Rictoo on #mopar succeeded in getting me banned, he sent !say commands to the bot, which was saying them on the channel, once he highlighted everyone, i got the blame
i was annoyed for a bit, but now i have to say well done Rictoo, that was a great piece of exploitation!


i was wondering, is there a way you can list which libraries on windows to link, so you can write
[code]
gcc ircbot.c
[/code]

instead of

[code]
gcc -L&quot;lib\libws2_32.a&quot; ircbot.c
[/code]


heres the bot
[code]
/*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

/*
    IRC Bot by yakman

    Joins one server and one channel
    has commands which start with a COMMAND_PREFIX, default is &#39;!&#39;

    say [message]  - repeats [message] back to the channel
    fact           - parses a website and says a fact
    slogan         - parses a website and says an advertising slogan
    quote          - parses a website and says a quote
    insult [name]  - parses a website and insults [name]

    Compiles on unix and windows,
    tested with GCC on unix and MinGW on windows

    To compile on unix
    gcc -std=c99 -o ircbot ircbot.c

    Compiling on windows varies, one thing you have to do is to link the the ws2_32 library
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//unix specific stuff
#ifdef __unix__

#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;

#else

//windows specific stuff
#ifdef __WIN32__

#include &lt;winsock2.h&gt;

#else
#error &quot;Only compiles on unix and windows&quot;
#endif
#endif


//stuff to change
#define IRC_SERVER &quot;irc.dairc.net&quot;
#define IRC_PORT 6667

#define NICK &quot;slurry_&quot;
#define CHANNEL &quot;#bots&quot;

//which hostname can !quit the bot
#define MASTER_HOST &quot;commandante.che.guevara&quot;

//need the master_host for all commands?
//#define NEED_MASTER 1

#define COMMAND_PREFIX &#39;!&#39;

#define BUFFER_SIZE 64


//thesurrealist.co.uk/slogan.cgi
//www.randomfunfacts.com
//www.quotability.com
//www.randominsults.net

//no IRC stuff below yet, only the website parsing
char* downloadHTTP(char* hostName, char* page) {

	struct hostent* host = gethostbyname(hostName);
	if(host == NULL) {
		#ifdef __unix__ 
		herror(&quot;Error resolving host name&quot;);
		#else
		printf(&quot;Error resolving host name. errorcode: %i\n&quot;, WSAGetLastError());
		#endif
		return NULL;
	}

	struct sockaddr_in address;
	address.sin_family = AF_INET;
	address.sin_port = htons(80);
	address.sin_addr.s_addr = ((struct in_addr*)host-&gt;h_addr)-&gt;s_addr;

	int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sock_fd &lt; 0) {
		perror(&quot;failed to open socket&quot;);
		return NULL;
	}

	if(connect(sock_fd, (struct sockaddr*)&amp;address, sizeof(address)) &lt; 0) {
		perror(&quot;failed to connect&quot;);
		return NULL;
	}

	char* one = &quot;GET /&quot;;
	char* three = &quot; HTTP/1.1\r\nHost: &quot;;
	char* five = &quot;\r\nUser-Agent: Mozilla/5.0 (Linux; X11; UTF-8)\r\nConnection: Close\r\n\r\n&quot;;
	int httplen = strlen(one) + strlen(page) + strlen(three) + strlen(hostName) + strlen(five);
	char* http = (char*)malloc(httplen + 1);
	*http = &#39;\0&#39;;
	strcat(http, one);
	strcat(http, page);
	strcat(http, three);
	strcat(http, hostName);
	strcat(http, five);
	send(sock_fd, http, httplen, 0);
	free(http);

	int pos = 0;
	int len = BUFFER_SIZE;
	char* buffer = (char*)malloc(len);
	while(1) {
		char buf[BUFFER_SIZE];
 		int reclen = recv(sock_fd, buf, BUFFER_SIZE, 0);
		if(reclen &lt;= 0)
			break;
		if(reclen + pos &gt; len-1) {
			len = (len * 3 / 2) + 1;
			buffer = (char*)realloc(buffer, len);
		}
		memcpy(buffer + pos, buf, reclen);
		pos += reclen;
	}
	buffer[pos] = &#39;\0&#39;;
	
	#ifdef __unix__
	close(sock_fd);
	#else
	closesocket(sock_fd);
	#endif
	char* headerEnd = strstr(buffer, &quot;\r\n\r\n&quot;);
	char* payloadEnd = headerEnd + strlen(headerEnd);
	char* result = (char*)malloc(payloadEnd - headerEnd + 1);
	memcpy(result, headerEnd, payloadEnd - headerEnd);
	result[payloadEnd - headerEnd] = &#39;\0&#39;;
	free(buffer);
	buffer = NULL;
	return result;
}

char* getFact(void) {
	char* page = downloadHTTP(&quot;www.randomfunfacts.com&quot;, &quot;&quot;);
	if(page == NULL)
		return NULL;

	char* first = strstr(page, &quot;&lt;i&gt;&quot;);
	if(first == NULL)
		return NULL;
	first += 3;
	char* last = strstr(first, &quot;&lt;/i&gt;&quot;);
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = &#39;\0&#39;;
	free(page);
	return result;
}

char* getSlogan(void) {
	char* page = downloadHTTP(&quot;thesurrealist.co.uk&quot;, &quot;slogan.cgi&quot;);
	if(page == NULL)
		return NULL;
	char* first = strstr(page, &quot;class=\&quot;shirtaw\&quot;&gt;&quot;);
	if(first == NULL)
		return NULL;
	first += 16;
	char* last = strstr(first, &quot;&lt;/a&gt;&quot;);
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = &#39;\0&#39;;
	free(page);
	return result;
}

char* getInsult(void) {
	char* page = downloadHTTP(&quot;www.randominsults.net&quot;, &quot;&quot;);
	if(page == NULL)
		return NULL;
	char* first = strstr(page, &quot;&lt;i&gt;&quot;);
	if(first == NULL)
		return NULL;
	first += 3;
	char* last = strstr(first, &quot;&lt;/i&gt;&quot;);
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = &#39;\0&#39;;
	free(page);
	return result;
}

char* getQuote(void) {
	char* page = downloadHTTP(&quot;www.quotability.com&quot;, &quot;&quot;);
	if(page == NULL)
		return NULL;
	char* first = strstr(page, &quot;&lt;i&gt;&quot;);
	if(first == NULL)
		return NULL;
	first += 3;
	char* last = strstr(first, &quot;&lt;/i&gt;&quot;);
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = &#39;\0&#39;;
	free(page);
	return result;
}

//IRC processing happens below

int connectToIRC(char* server, int port) {

	printf(&quot;Connecting to %s:%i\n&quot;, server, port);
	struct hostent* host = gethostbyname(server);
	if(host == NULL) {
		#ifdef __unix__ 
		herror(&quot;Error resolving host name&quot;);
		#else
		printf(&quot;Error resolving host name. errorcode: %i\n&quot;, WSAGetLastError());
		#endif
		return -1;
	}

	struct sockaddr_in address;
	address.sin_family = AF_INET;
	address.sin_port = htons(port);
	address.sin_addr.s_addr = ((struct in_addr*)host-&gt;h_addr)-&gt;s_addr;

	int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sock_fd &lt; 0) {
		perror(&quot;failed to open socket&quot;);
		return -1;
	}

	if(connect(sock_fd, (struct sockaddr*)&amp;address, sizeof(address)) &lt; 0) {
		perror(&quot;failed to connect&quot;);
		return -1;
	}
	return sock_fd;
}

struct BufferedSocketReader {
	int sock_fd;
	int closed; //is set if the file is closed AND the buffer is empty
	char* buffer; //note buffer isnt null-terminated
	int pos;
	int len;
};

void sendData(struct BufferedSocketReader* reader, char* line) {
	//makes a copy of the line with a linebreak added
	int lbLen = strlen(line) + 2;
	char* lineLB = (char*)malloc(lbLen);
	memcpy(lineLB, line, lbLen - 1);
	lineLB[lbLen - 2] = &#39;\n&#39;;
	lineLB[lbLen - 1] = &#39;\0&#39;;

	printf(&quot;=&gt; %s&quot;, lineLB);
	send(reader-&gt;sock_fd, lineLB, strlen(lineLB), 0); //TODO check return value and resend if not everything is sent
	free(lineLB);
}

void closeSocketReader(struct BufferedSocketReader* reader) {
	#ifdef __unix__
	close(reader-&gt;sock_fd);
	#else
	closesocket(reader-&gt;sock_fd);
	#endif
	reader-&gt;sock_fd = -1;
}

void fillSocketBuffer(struct BufferedSocketReader* reader) {
	if(reader-&gt;sock_fd == -1) {
		reader-&gt;closed = 1;
		return;
	}

	char buf[BUFFER_SIZE];
	int recLen = recv(reader-&gt;sock_fd, buf, BUFFER_SIZE, 0);
	if(recLen &lt; 0) {
		closeSocketReader(reader);
	}
	int newLen = (reader-&gt;len - reader-&gt;pos) + recLen; //new length is the length already in the buffer, and length of just recved
	char* newBuf = (char*)malloc(newLen);
	memset(newBuf, &#39;\0&#39;, newLen);
	memcpy(newBuf, reader-&gt;buffer + reader-&gt;pos, reader-&gt;len - reader-&gt;pos); //copy the old buffer into new
	memcpy(newBuf + reader-&gt;len - reader-&gt;pos, buf, recLen); //copy receved buffer into new buffer
	free(reader-&gt;buffer);
	reader-&gt;buffer = newBuf;
	reader-&gt;len = newLen;
	reader-&gt;pos = 0;
}

char* readNextLine(struct BufferedSocketReader* reader) {
//bug, if we reach the EOF and there is no line break, the data in the buffer will be discarded
//not likely to happen on irc protocol though
	while(!reader-&gt;closed) {
		for(int i = reader-&gt;pos; i &lt; reader-&gt;len-1; i++) { //-1 to allow for the check for double linebreak
			if(reader-&gt;buffer[i] == &#39;\r&#39; || reader-&gt;buffer[i] == &#39;\n&#39;) {
				int len = i - reader-&gt;pos;
				char* result = (char*)malloc(len + 1);
				memcpy(result, reader-&gt;buffer + reader-&gt;pos, len);
				result[len] = &#39;\0&#39;;
				reader-&gt;pos = i + 1; //skip the char you just read
				//sometimes line breaks come in twos
				if(reader-&gt;buffer[reader-&gt;pos] == &#39;\r&#39; || reader-&gt;buffer[reader-&gt;pos] == &#39;\n&#39;)
					reader-&gt;pos++;
				return result;
			}
		}
		//didnt find \r\n, need to read more data into the buffer
		fillSocketBuffer(reader);
	}
	//socket is closed and buffer is empty
	return NULL;
}

void handleCommand(struct BufferedSocketReader* reader, char* nick, char* user, char* host, char* cmd, char* chan, char* text) {

		#ifdef NEED_MASTER
		if(strstr(host, MASTER_HOST) == NULL)
			return;
		#endif
		
		if(strstr(chan, CHANNEL) == NULL) //someone sent private message, ie. not from channel
			return;

		if(strstr(text, &quot;quit&quot;) == text &amp;&amp; strstr(host, MASTER_HOST) != NULL) {
			sendData(reader, &quot;QUIT :leaving&quot;);
			printf(&quot;Quitting\n&quot;);
			closeSocketReader(reader);
		}else
		if(strstr(text, &quot;say&quot;) == text) {
			char* cmd = &quot;PRIVMSG &quot;;
			char* colon = &quot; :&quot;;
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(text + 4) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = &#39;\0&#39;;
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, text + 4);
			sendData(reader, sayline);
			free(sayline);
		}else
		if(strstr(text, &quot;fact&quot;) == text) {
			char* cmd = &quot;PRIVMSG &quot;;
			char* colon = &quot; :&quot;;
			char* fact = getFact();
			if(fact == NULL)
				fact = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(fact) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = &#39;\0&#39;;
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, fact);
			sendData(reader, sayline);
			free(fact);
			free(sayline);
		}else
		if(strstr(text, &quot;slogan&quot;) == text) {
			char* cmd = &quot;PRIVMSG &quot;;
			char* colon = &quot; :&quot;;
			char* slogan = getSlogan();
			if(slogan == NULL)
				slogan = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(slogan) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = &#39;\0&#39;;
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, slogan);
			sendData(reader, sayline);
			free(slogan);
			free(sayline);
		}else
		if(strstr(text, &quot;insult&quot;) == text) {

			char* target = NULL;
			if(strchr(text, &#39; &#39;) != NULL) {
				char* t = strchr(text, &#39; &#39;);
				*t = &#39;\0&#39;;
				target = t + 1;

				//if there is a trailing &#39; &#39; we have to remove
				if(strchr(target, &#39; &#39;) != NULL) {
					char* t = strchr(target, &#39; &#39;);
					*t = &#39;\0&#39;;
				}
			}

			char* cmd = &quot;PRIVMSG &quot;;
			char* colon = &quot; :&quot;;
			char* insult = getInsult();
			if(insult == NULL)
				insult = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) + strlen(colon) +
				(target == NULL ? 0 : strlen(target) + 2) + strlen(insult) + 1;
				//add 2 if there is a target, for the colon and space

			char* sayline = (char*)malloc(len);
			*sayline = &#39;\0&#39;;
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			if(target != NULL) {
				strcat(sayline, target);
				strcat(sayline, &quot;: &quot;);
			}
			strcat(sayline, insult);

			sendData(reader, sayline);
			free(insult);
			free(sayline);
		}else
		if(strstr(text, &quot;quote&quot;) == text) {
			char* cmd = &quot;PRIVMSG &quot;;
			char* colon = &quot; :&quot;;
			char* quote = getQuote();
			if(quote == NULL)
				quote = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(quote) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = &#39;\0&#39;;
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, quote);
			sendData(reader, sayline);
			free(quote);
			free(sayline);
		}
}

void handleLine(struct BufferedSocketReader* reader, char* line) {
	printf(&quot;&lt;= %s\n&quot;, line);

	char* lineTok = (char*)malloc(strlen(line) + 1);
	strcpy(lineTok, line);

	if(strstr(line, &quot;PING&quot;) == line) {
		line[1] = &#39;O&#39;;
		sendData(reader, line);
		printf(&quot;Replied to ping\n&quot;);
		free(lineTok);
		return;
	}

	//has the &quot;:nick!username@host&quot; format
	//also works for other stuff
	if(*lineTok != &#39;:&#39;) {
		free(lineTok);
		return;
	}

	char* nickuserhost = strtok(lineTok + 1, &quot; &quot;);
	char* cmd = strtok(NULL, &quot; &quot;);
	char* chan = strtok(NULL, &quot; &quot;);
	char* text = strtok(NULL, &quot;\0&quot;);

	char* nick = NULL;
	char* user = NULL;
	char* host = NULL;
	//split nick, user and host
	if(nickuserhost != NULL &amp;&amp; strchr(nickuserhost, &#39;!&#39;) != NULL &amp;&amp; strchr(nickuserhost, &#39;@&#39;) != NULL) {
		nick = strtok(nickuserhost, &quot;!&quot;);
		user = strtok(NULL, &quot;@&quot;);
		host = strtok(NULL, &quot;\0&quot;);
	}
	if(text != NULL &amp;&amp; *text == &#39;:&#39;) //remove the first &#39;:&#39; on chat
		text++;
	
	//below is the using of the strings
	if(strcmp(cmd, &quot;PRIVMSG&quot;) == 0 &amp;&amp; *text == COMMAND_PREFIX) { //someone has spoken
		handleCommand(reader, nick, user, host, cmd, chan, text + 1);
	}

	if(strcmp(cmd, &quot;KICK&quot;) == 0 &amp;&amp; strstr(text, NICK) == text) {
		char* header = &quot;JOIN &quot;; //send &quot;JOIN #channel&quot;
		char* chanLine = (char*)malloc(strlen(header) + strlen(CHANNEL) + 1);
		*chanLine = &#39;\0&#39;;
		strcat(chanLine, header);
		strcat(chanLine, CHANNEL);
		sendData(reader, chanLine);
		free(chanLine);
	}

	free(lineTok);
}

int main(int argc, char** argv) {

	#ifdef __WIN32__
	WSADATA wsaData;
	if(WSAStartup(MAKEWORD(1, 1), &amp;wsaData) != 0) {
	printf(&quot;Error starting winsock\n&quot;);
	return EXIT_FAILURE;
	}
	#endif

	struct BufferedSocketReader reader;
	reader.sock_fd = connectToIRC(IRC_SERVER, IRC_PORT);
	reader.closed = 0;
	reader.pos = 0;

	sendData(&amp;reader, &quot;USER user 8 * :real&quot;);

	char* header = &quot;NICK &quot;; //send &quot;NICK mynick&quot;
	char* nickLine = (char*)malloc(strlen(header) + strlen(NICK) + 1);
	*nickLine = &#39;\0&#39;;
	strcat(nickLine, header);
	strcat(nickLine, NICK);
	sendData(&amp;reader, nickLine);
	free(nickLine);

	header = &quot;JOIN &quot;; //send &quot;JOIN #channel&quot;
	char* chanLine = (char*)malloc(strlen(header) + strlen(CHANNEL) + 1);
	*chanLine = &#39;\0&#39;;
	strcat(chanLine, header);
	strcat(chanLine, CHANNEL);
	sendData(&amp;reader, chanLine);
	free(chanLine);

	char buf[BUFFER_SIZE];
	reader.len = recv(reader.sock_fd, buf, BUFFER_SIZE, 0);
	reader.buffer = (char*)malloc(reader.len); //initalise buffer
	memcpy(reader.buffer, buf, reader.len);

	while(!reader.closed) {
		char* line = readNextLine(&amp;reader);
		if(line == NULL)
			continue;
		handleLine(&amp;reader, line);
		free(line);
	}

	printf(&quot;Socket closed or buffer empty\nExiting...\n&quot;);
	#ifdef __WIN32__
	WSACleanup();
	system(&quot;PAUSE&quot;);
	#endif
	return EXIT_SUCCESS;
}
[/code]</description>
    
    <lastBuildDate>Sat, 03 May 2008 23:56:13 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@Unhandled Unhandled]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/unhandled">@Unhandled</a> wrote:</p>
          <blockquote>
              <p>[quote=“frank_, post:10, topic:202731”][quote author=Unhandled link=topic=267421.msg2209981#msg2209981 date=1209843468]</p>
<aside class="quote no-group">
<blockquote>
<p>so i actually read through a little of it, things like the command prefix, server and channel should be read from some sort of configuration file, not hard coded</p>
</blockquote>
</aside>
<p>So add it in yourself, things are open source for a reason.<br>
[/quote]writing a shitty program and releasing it open source, then claiming that is why open source exists… that is the sign of idiocy[/quote]<br>
It all depends on your idea of a shitty program. I suppose you have higher standards than I.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/11</link>
        <pubDate>Sat, 03 May 2008 23:56:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-11</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>[quote=“Unhandled, post:9, topic:202731”][quote author=frank_ link=topic=267421.msg2209312#msg2209312 date=1209804134]<br>
so i actually read through a little of it, things like the command prefix, server and channel should be read from some sort of configuration file, not hard coded<br>
[/quote]<br>
So add it in yourself, things are open source for a reason.[/quote]writing a shitty program and releasing it open source, then claiming that is why open source exists… that is the sign of idiocy</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/10</link>
        <pubDate>Sat, 03 May 2008 22:44:31 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-10</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@Unhandled Unhandled]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/unhandled">@Unhandled</a> wrote:</p>
          <blockquote>
              <p>So add it in yourself, things are open source for a reason.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/9</link>
        <pubDate>Sat, 03 May 2008 19:37:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-9</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>so i actually read through a little of it, things like the command prefix, server and channel should be read from some sort of configuration file, not hard coded</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/8</link>
        <pubDate>Sat, 03 May 2008 08:42:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-8</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@moparisthebest Moparisthebest]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/moparisthebest">@moparisthebest</a> wrote:</p>
          <blockquote>
              <p>This is awesome, after exams I will have to slap my markov chains implementation in there and have a smart learning IRC bot, neat. <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=6" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/7</link>
        <pubDate>Sat, 03 May 2008 08:29:40 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-7</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@eVokki1 Cowie`]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/evokki1">@eVokki1</a> wrote:</p>
          <blockquote>
              <p>Damnit with you and your bot highlighting me on IRC with insults <img src="https://forum.moparisthebest.com/images/emoji/twitter/frowning.png?v=6" title=":frowning:" class="emoji" alt=":frowning:"> Oh woe is me.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/6</link>
        <pubDate>Sat, 03 May 2008 02:39:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-6</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>thats what i get for copying ideas from this guy <a href="http://www.moparisthebest.com/smf/index.php/topic,200592.0.html" data-bbcode="true" rel="nofollow noopener">Tetris [C++/OpenGL/Cross-platform]</a></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/5</link>
        <pubDate>Fri, 02 May 2008 21:58:52 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-5</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>“cross platform[unix][windows]” sry but lol</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/4</link>
        <pubDate>Fri, 02 May 2008 21:34:10 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-4</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>obviously not, its basically my excuse to ask questions about c</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/3</link>
        <pubDate>Fri, 02 May 2008 21:25:52 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-3</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@Uriko Uriko]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/uriko">@Uriko</a> wrote:</p>
          <blockquote>
              <p>Not really an amazing feat or anything…Been done many times, but it’s nice to see that someone did it in c</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/2</link>
        <pubDate>Fri, 02 May 2008 20:52:27 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-2</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
      <item>
        <title>IRC Bot [c99] cross platfrom[unix][windows]</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>IRC Bot by yakman</p>
<p>Joins one server and one channel<br>
has commands which start with a COMMAND_PREFIX, default is ‘!’</p>
<p>say [message]  - repeats [message] back to the channel<br>
fact           - parses a website and says a fact<br>
slogan         - parses a website and says an advertising slogan<br>
quote          - parses a website and says a quote<br>
insult [name]  - parses a website and insults [name]</p>
<p>Compiles on unix and windows,<br>
tested with GCC on unix and MinGW on windows</p>
<pre><code class="lang-auto">&lt;yakman&gt; !fact
&lt;slurry_&gt; Nurses and doctors wash their hands between patients less than one-third of the time. 
&lt;yakman&gt; !quote
&lt;slurry_&gt; "People demand freedom of speech to make up for the freedom of thought which they avoid." - Soren Aabye Kierkegaard (1813-1855) 
&lt;yakman&gt; !say hello world
&lt;slurry_&gt; hello world
&lt;yakman&gt; !slogan
&lt;slurry_&gt; Refreshes the Anxiety Other Beers Cannot Reach
&lt;yakman&gt; !insult Cowie` 
&lt;slurry_&gt; Cowie`: I'd like to see things from your point of view but I can't seem to get my head that far up my ass.</code></pre>
<p>when i was testing this, Rictoo on <span class="hashtag">#mopar</span> succeeded in getting me banned, he sent !say commands to the bot, which was saying them on the channel, once he highlighted everyone, i got the blame<br>
i was annoyed for a bit, but now i have to say well done Rictoo, that was a great piece of exploitation!</p>
<p>i was wondering, is there a way you can list which libraries on windows to link, so you can write</p>
<pre><code class="lang-auto">gcc ircbot.c</code></pre>
<p>instead of</p>
<pre><code class="lang-auto">gcc -L"lib\libws2_32.a" ircbot.c</code></pre>
<p>heres the bot</p>
<pre><code class="lang-auto">/*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

/*
    IRC Bot by yakman

    Joins one server and one channel
    has commands which start with a COMMAND_PREFIX, default is '!'

    say [message]  - repeats [message] back to the channel
    fact           - parses a website and says a fact
    slogan         - parses a website and says an advertising slogan
    quote          - parses a website and says a quote
    insult [name]  - parses a website and insults [name]

    Compiles on unix and windows,
    tested with GCC on unix and MinGW on windows

    To compile on unix
    gcc -std=c99 -o ircbot ircbot.c

    Compiling on windows varies, one thing you have to do is to link the the ws2_32 library
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//unix specific stuff
#ifdef __unix__

#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;

#else

//windows specific stuff
#ifdef __WIN32__

#include &lt;winsock2.h&gt;

#else
#error "Only compiles on unix and windows"
#endif
#endif


//stuff to change
#define IRC_SERVER "irc.dairc.net"
#define IRC_PORT 6667

#define NICK "slurry_"
#define CHANNEL "#bots"

//which hostname can !quit the bot
#define MASTER_HOST "commandante.che.guevara"

//need the master_host for all commands?
//#define NEED_MASTER 1

#define COMMAND_PREFIX '!'

#define BUFFER_SIZE 64


//thesurrealist.co.uk/slogan.cgi
//www.randomfunfacts.com
//www.quotability.com
//www.randominsults.net

//no IRC stuff below yet, only the website parsing
char* downloadHTTP(char* hostName, char* page) {

	struct hostent* host = gethostbyname(hostName);
	if(host == NULL) {
		#ifdef __unix__ 
		herror("Error resolving host name");
		#else
		printf("Error resolving host name. errorcode: %i\n", WSAGetLastError());
		#endif
		return NULL;
	}

	struct sockaddr_in address;
	address.sin_family = AF_INET;
	address.sin_port = htons(80);
	address.sin_addr.s_addr = ((struct in_addr*)host-&gt;h_addr)-&gt;s_addr;

	int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sock_fd &lt; 0) {
		perror("failed to open socket");
		return NULL;
	}

	if(connect(sock_fd, (struct sockaddr*)&amp;address, sizeof(address)) &lt; 0) {
		perror("failed to connect");
		return NULL;
	}

	char* one = "GET /";
	char* three = " HTTP/1.1\r\nHost: ";
	char* five = "\r\nUser-Agent: Mozilla/5.0 (Linux; X11; UTF-8)\r\nConnection: Close\r\n\r\n";
	int httplen = strlen(one) + strlen(page) + strlen(three) + strlen(hostName) + strlen(five);
	char* http = (char*)malloc(httplen + 1);
	*http = '\0';
	strcat(http, one);
	strcat(http, page);
	strcat(http, three);
	strcat(http, hostName);
	strcat(http, five);
	send(sock_fd, http, httplen, 0);
	free(http);

	int pos = 0;
	int len = BUFFER_SIZE;
	char* buffer = (char*)malloc(len);
	while(1) {
		char buf[BUFFER_SIZE];
 		int reclen = recv(sock_fd, buf, BUFFER_SIZE, 0);
		if(reclen &lt;= 0)
			break;
		if(reclen + pos &gt; len-1) {
			len = (len * 3 / 2) + 1;
			buffer = (char*)realloc(buffer, len);
		}
		memcpy(buffer + pos, buf, reclen);
		pos += reclen;
	}
	buffer[pos] = '\0';
	
	#ifdef __unix__
	close(sock_fd);
	#else
	closesocket(sock_fd);
	#endif
	char* headerEnd = strstr(buffer, "\r\n\r\n");
	char* payloadEnd = headerEnd + strlen(headerEnd);
	char* result = (char*)malloc(payloadEnd - headerEnd + 1);
	memcpy(result, headerEnd, payloadEnd - headerEnd);
	result[payloadEnd - headerEnd] = '\0';
	free(buffer);
	buffer = NULL;
	return result;
}

char* getFact(void) {
	char* page = downloadHTTP("www.randomfunfacts.com", "");
	if(page == NULL)
		return NULL;

	char* first = strstr(page, "&lt;i&gt;");
	if(first == NULL)
		return NULL;
	first += 3;
	char* last = strstr(first, "&lt;/i&gt;");
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = '\0';
	free(page);
	return result;
}

char* getSlogan(void) {
	char* page = downloadHTTP("thesurrealist.co.uk", "slogan.cgi");
	if(page == NULL)
		return NULL;
	char* first = strstr(page, "class=\"shirtaw\"&gt;");
	if(first == NULL)
		return NULL;
	first += 16;
	char* last = strstr(first, "&lt;/a&gt;");
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = '\0';
	free(page);
	return result;
}

char* getInsult(void) {
	char* page = downloadHTTP("www.randominsults.net", "");
	if(page == NULL)
		return NULL;
	char* first = strstr(page, "&lt;i&gt;");
	if(first == NULL)
		return NULL;
	first += 3;
	char* last = strstr(first, "&lt;/i&gt;");
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = '\0';
	free(page);
	return result;
}

char* getQuote(void) {
	char* page = downloadHTTP("www.quotability.com", "");
	if(page == NULL)
		return NULL;
	char* first = strstr(page, "&lt;i&gt;");
	if(first == NULL)
		return NULL;
	first += 3;
	char* last = strstr(first, "&lt;/i&gt;");
	if(last == NULL)
		return NULL;
	int len = last - first;
	char* result = (char*)malloc(len + 1);
	memcpy(result, first, len);
	result[len] = '\0';
	free(page);
	return result;
}

//IRC processing happens below

int connectToIRC(char* server, int port) {

	printf("Connecting to %s:%i\n", server, port);
	struct hostent* host = gethostbyname(server);
	if(host == NULL) {
		#ifdef __unix__ 
		herror("Error resolving host name");
		#else
		printf("Error resolving host name. errorcode: %i\n", WSAGetLastError());
		#endif
		return -1;
	}

	struct sockaddr_in address;
	address.sin_family = AF_INET;
	address.sin_port = htons(port);
	address.sin_addr.s_addr = ((struct in_addr*)host-&gt;h_addr)-&gt;s_addr;

	int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sock_fd &lt; 0) {
		perror("failed to open socket");
		return -1;
	}

	if(connect(sock_fd, (struct sockaddr*)&amp;address, sizeof(address)) &lt; 0) {
		perror("failed to connect");
		return -1;
	}
	return sock_fd;
}

struct BufferedSocketReader {
	int sock_fd;
	int closed; //is set if the file is closed AND the buffer is empty
	char* buffer; //note buffer isnt null-terminated
	int pos;
	int len;
};

void sendData(struct BufferedSocketReader* reader, char* line) {
	//makes a copy of the line with a linebreak added
	int lbLen = strlen(line) + 2;
	char* lineLB = (char*)malloc(lbLen);
	memcpy(lineLB, line, lbLen - 1);
	lineLB[lbLen - 2] = '\n';
	lineLB[lbLen - 1] = '\0';

	printf("=&gt; %s", lineLB);
	send(reader-&gt;sock_fd, lineLB, strlen(lineLB), 0); //TODO check return value and resend if not everything is sent
	free(lineLB);
}

void closeSocketReader(struct BufferedSocketReader* reader) {
	#ifdef __unix__
	close(reader-&gt;sock_fd);
	#else
	closesocket(reader-&gt;sock_fd);
	#endif
	reader-&gt;sock_fd = -1;
}

void fillSocketBuffer(struct BufferedSocketReader* reader) {
	if(reader-&gt;sock_fd == -1) {
		reader-&gt;closed = 1;
		return;
	}

	char buf[BUFFER_SIZE];
	int recLen = recv(reader-&gt;sock_fd, buf, BUFFER_SIZE, 0);
	if(recLen &lt; 0) {
		closeSocketReader(reader);
	}
	int newLen = (reader-&gt;len - reader-&gt;pos) + recLen; //new length is the length already in the buffer, and length of just recved
	char* newBuf = (char*)malloc(newLen);
	memset(newBuf, '\0', newLen);
	memcpy(newBuf, reader-&gt;buffer + reader-&gt;pos, reader-&gt;len - reader-&gt;pos); //copy the old buffer into new
	memcpy(newBuf + reader-&gt;len - reader-&gt;pos, buf, recLen); //copy receved buffer into new buffer
	free(reader-&gt;buffer);
	reader-&gt;buffer = newBuf;
	reader-&gt;len = newLen;
	reader-&gt;pos = 0;
}

char* readNextLine(struct BufferedSocketReader* reader) {
//bug, if we reach the EOF and there is no line break, the data in the buffer will be discarded
//not likely to happen on irc protocol though
	while(!reader-&gt;closed) {
		for(int i = reader-&gt;pos; i &lt; reader-&gt;len-1; i++) { //-1 to allow for the check for double linebreak
			if(reader-&gt;buffer[i] == '\r' || reader-&gt;buffer[i] == '\n') {
				int len = i - reader-&gt;pos;
				char* result = (char*)malloc(len + 1);
				memcpy(result, reader-&gt;buffer + reader-&gt;pos, len);
				result[len] = '\0';
				reader-&gt;pos = i + 1; //skip the char you just read
				//sometimes line breaks come in twos
				if(reader-&gt;buffer[reader-&gt;pos] == '\r' || reader-&gt;buffer[reader-&gt;pos] == '\n')
					reader-&gt;pos++;
				return result;
			}
		}
		//didnt find \r\n, need to read more data into the buffer
		fillSocketBuffer(reader);
	}
	//socket is closed and buffer is empty
	return NULL;
}

void handleCommand(struct BufferedSocketReader* reader, char* nick, char* user, char* host, char* cmd, char* chan, char* text) {

		#ifdef NEED_MASTER
		if(strstr(host, MASTER_HOST) == NULL)
			return;
		#endif
		
		if(strstr(chan, CHANNEL) == NULL) //someone sent private message, ie. not from channel
			return;

		if(strstr(text, "quit") == text &amp;&amp; strstr(host, MASTER_HOST) != NULL) {
			sendData(reader, "QUIT :leaving");
			printf("Quitting\n");
			closeSocketReader(reader);
		}else
		if(strstr(text, "say") == text) {
			char* cmd = "PRIVMSG ";
			char* colon = " :";
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(text + 4) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = '\0';
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, text + 4);
			sendData(reader, sayline);
			free(sayline);
		}else
		if(strstr(text, "fact") == text) {
			char* cmd = "PRIVMSG ";
			char* colon = " :";
			char* fact = getFact();
			if(fact == NULL)
				fact = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(fact) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = '\0';
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, fact);
			sendData(reader, sayline);
			free(fact);
			free(sayline);
		}else
		if(strstr(text, "slogan") == text) {
			char* cmd = "PRIVMSG ";
			char* colon = " :";
			char* slogan = getSlogan();
			if(slogan == NULL)
				slogan = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(slogan) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = '\0';
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, slogan);
			sendData(reader, sayline);
			free(slogan);
			free(sayline);
		}else
		if(strstr(text, "insult") == text) {

			char* target = NULL;
			if(strchr(text, ' ') != NULL) {
				char* t = strchr(text, ' ');
				*t = '\0';
				target = t + 1;

				//if there is a trailing ' ' we have to remove
				if(strchr(target, ' ') != NULL) {
					char* t = strchr(target, ' ');
					*t = '\0';
				}
			}

			char* cmd = "PRIVMSG ";
			char* colon = " :";
			char* insult = getInsult();
			if(insult == NULL)
				insult = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) + strlen(colon) +
				(target == NULL ? 0 : strlen(target) + 2) + strlen(insult) + 1;
				//add 2 if there is a target, for the colon and space

			char* sayline = (char*)malloc(len);
			*sayline = '\0';
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			if(target != NULL) {
				strcat(sayline, target);
				strcat(sayline, ": ");
			}
			strcat(sayline, insult);

			sendData(reader, sayline);
			free(insult);
			free(sayline);
		}else
		if(strstr(text, "quote") == text) {
			char* cmd = "PRIVMSG ";
			char* colon = " :";
			char* quote = getQuote();
			if(quote == NULL)
				quote = malloc(1); //to stop free() segfaulting
			int len = strlen(cmd) + strlen(CHANNEL) +  strlen(colon) + strlen(quote) + 1;
			char* sayline = (char*)malloc(len);
			*sayline = '\0';
			strcat(sayline, cmd);
			strcat(sayline, CHANNEL);
			strcat(sayline, colon);
			strcat(sayline, quote);
			sendData(reader, sayline);
			free(quote);
			free(sayline);
		}
}

void handleLine(struct BufferedSocketReader* reader, char* line) {
	printf("&lt;= %s\n", line);

	char* lineTok = (char*)malloc(strlen(line) + 1);
	strcpy(lineTok, line);

	if(strstr(line, "PING") == line) {
		line[1] = 'O';
		sendData(reader, line);
		printf("Replied to ping\n");
		free(lineTok);
		return;
	}

	//has the ":nick!username@host" format
	//also works for other stuff
	if(*lineTok != ':') {
		free(lineTok);
		return;
	}

	char* nickuserhost = strtok(lineTok + 1, " ");
	char* cmd = strtok(NULL, " ");
	char* chan = strtok(NULL, " ");
	char* text = strtok(NULL, "\0");

	char* nick = NULL;
	char* user = NULL;
	char* host = NULL;
	//split nick, user and host
	if(nickuserhost != NULL &amp;&amp; strchr(nickuserhost, '!') != NULL &amp;&amp; strchr(nickuserhost, '@') != NULL) {
		nick = strtok(nickuserhost, "!");
		user = strtok(NULL, "@");
		host = strtok(NULL, "\0");
	}
	if(text != NULL &amp;&amp; *text == ':') //remove the first ':' on chat
		text++;
	
	//below is the using of the strings
	if(strcmp(cmd, "PRIVMSG") == 0 &amp;&amp; *text == COMMAND_PREFIX) { //someone has spoken
		handleCommand(reader, nick, user, host, cmd, chan, text + 1);
	}

	if(strcmp(cmd, "KICK") == 0 &amp;&amp; strstr(text, NICK) == text) {
		char* header = "JOIN "; //send "JOIN #channel"
		char* chanLine = (char*)malloc(strlen(header) + strlen(CHANNEL) + 1);
		*chanLine = '\0';
		strcat(chanLine, header);
		strcat(chanLine, CHANNEL);
		sendData(reader, chanLine);
		free(chanLine);
	}

	free(lineTok);
}

int main(int argc, char** argv) {

	#ifdef __WIN32__
	WSADATA wsaData;
	if(WSAStartup(MAKEWORD(1, 1), &amp;wsaData) != 0) {
	printf("Error starting winsock\n");
	return EXIT_FAILURE;
	}
	#endif

	struct BufferedSocketReader reader;
	reader.sock_fd = connectToIRC(IRC_SERVER, IRC_PORT);
	reader.closed = 0;
	reader.pos = 0;

	sendData(&amp;reader, "USER user 8 * :real");

	char* header = "NICK "; //send "NICK mynick"
	char* nickLine = (char*)malloc(strlen(header) + strlen(NICK) + 1);
	*nickLine = '\0';
	strcat(nickLine, header);
	strcat(nickLine, NICK);
	sendData(&amp;reader, nickLine);
	free(nickLine);

	header = "JOIN "; //send "JOIN #channel"
	char* chanLine = (char*)malloc(strlen(header) + strlen(CHANNEL) + 1);
	*chanLine = '\0';
	strcat(chanLine, header);
	strcat(chanLine, CHANNEL);
	sendData(&amp;reader, chanLine);
	free(chanLine);

	char buf[BUFFER_SIZE];
	reader.len = recv(reader.sock_fd, buf, BUFFER_SIZE, 0);
	reader.buffer = (char*)malloc(reader.len); //initalise buffer
	memcpy(reader.buffer, buf, reader.len);

	while(!reader.closed) {
		char* line = readNextLine(&amp;reader);
		if(line == NULL)
			continue;
		handleLine(&amp;reader, line);
		free(line);
	}

	printf("Socket closed or buffer empty\nExiting...\n");
	#ifdef __WIN32__
	WSACleanup();
	system("PAUSE");
	#endif
	return EXIT_SUCCESS;
}</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731/1</link>
        <pubDate>Fri, 02 May 2008 20:42:59 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-202731-1</guid>
        <source url="https://forum.moparisthebest.com/t/irc-bot-c99-cross-platfrom-unix-windows/202731.rss">IRC Bot [c99] cross platfrom[unix][windows]</source>
      </item>
  </channel>
</rss>
