<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
    <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677</link>
    <description>[center][size=24pt][u][b]Creating a Simple Game With Slick2D[/b][/u][/size]
[size=14pt][i]Part 2: Brick Breaker[/i][/size]
[img]http://slick.cokeandcode.com/themes/slick2d/images/logo.gif[/img][/center]


[size=14pt][u][b]About this tutorial:[/b][/u][/size]
This tutorial will teach you some more features about Slick and how to use them in a game environment. This tutorial will [u][b]not[/b][/u] teach you how to set up Slick or LWJGL (but you can expect something on that soon), and covers only the programming aspect of the game. Like all things that use Slick, the programming language here is Java. It is suggested you learn some basics about Java programming before attempting to follow these tutorials.
Things covered in this tutorial:
[list]
[li]Creating a game skeleton[/li]
[li]Using sprites[/li]
[li]Some brick breaker variables[/li]
[li]Rendering the game[/li][li]

[ul][li]Some basic physics[/li][/ul]


[size=14pt][u][b]Creating the game skeleton:[/b][/u][/size]
Like all Slick games, there is a simple skeleton you must create. It&#39;s just this:
[code=java]import org.newdawn.slick.AppGameContainer;
import org.newdawn.slick.GameContainer;
import org.newdawn.slick.Graphics;
import org.newdawn.slick.BasicGame;

public class BrickBreaker extends BasicGame {

	public static void main(String[] args) {
    		try {
			//Initialize our game container, 450 X 600 is the size, the &#39;false&#39; is saying we don&#39;t want the game full-screen
			AppGameContainer game = new AppGameContainer(new BrickBreaker(), 450, 600, false);

			//Set the target FPS (frames) and UPS (updates) per second. If you don&#39;t set this, sometimes the game will use it&#39;s own based on the computer.
			game.setTargetFrameRate(60);

			//Start the game!
			game.start();
		} catch (SlickException e) {
			e.printStackTrace();
		}
	}

	public BrickBreaker() {
		//Calls the super constructor with the title parameter
		super(&quot;Brick Breaker&quot;);
	}

	@Override
	public void render(GameContainer container, Graphics g) throws SlickException {
		//Called after every update, you draw the game here. If you&#39;ve made a basic game before, you may have done this in &#39;paint(Graphics g)&#39;
	}

	@Override
	public void init(GameContainer arg0) throws SlickException {
		//Called when start the game for the first time. This is where you do things like load settings, sprites, etc and create the basic game layout
	}

	@Override
	public void update(GameContainer container, int time) throws SlickException {
		//This is where you handle all game logic. If anything moves, this is definitely where you&#39;d handle it.
	}

}[/code]There are explanations in the comments if you haven&#39;t read the Pong tutorial.


[size=14pt][u][b]Using sprites:[/b][/u][/size]
Using sprites with Slick is EXTREMELY easy. Loading and keeping track of them in a good way can be tricky though. A simple little way to do it is with a HashMap, like so:

[code=java]	//Using org.newdawn.slick.Image, NOT the default Java class.
	HashMap&lt;String, Image&gt; sprites = new HashMap&lt;String, Image&gt;();

	private void loadSprite(String name, String resource) throws SlickException {
		sprites.put(name, new Image(BrickBreaker.class.getResourceAsStream(resource), resource, false));
	}

	private Image getSprite(String name) {
		return sprites.get(name);
	}[/code]
And now we can use a simple Java Properties file:
[code]ball_sprite=ball.gif
paddle_sprite=paddle.gif
background=background.jpg
brick_sprite=brick.gif[/code]
alongside some loading stuff in our [tt]init()[/tt] method:
[code=java]	@Override
	public void init(GameContainer container) throws SlickException {
		try {
			Properties properties = new Properties();
			properties.load(BrickBreaker.class.getResourceAsStream(&quot;props.ini&quot;));
			loadSprite(&quot;ball&quot;, properties.getProperty(&quot;ball_sprite&quot;));
			loadSprite(&quot;paddle&quot;, properties.getProperty(&quot;paddle_sprite&quot;));
			loadSprite(&quot;background&quot;, properties.getProperty(&quot;background&quot;));
			loadSprite(&quot;brick&quot;, properties.getProperty(&quot;brick_sprite&quot;));
		} catch (IOException e) {
			e.printStackTrace();
		}
		...[/code] to have our sprites all loaded into that Map!
Now drawing those images onto the canvas is even easier. We can simply use 
[tt]getSprite(name).draw(x, y);[/tt] 
It really is that simple!


[size=14pt][u][b]Brick breaker variables:[/b][/u][/size]
In this brick breaker game, we need a few variables to keep the game interesting and (more) realistic. Here they are, with some comments to explain them:
[code=java]	private enum Direction { //We will use this enumeration for directions later in the physics section
		NORTH, SOUTH, EAST, WEST 
	}
	
	private enum Status { //A simple status enumeration for where the user is in the game. You can have many more
		WAITING_TO_LAUNCH, NORMAL
	}

	private int paddleSpeed = 4; //The speed of the paddle, 4 pixels per update
	private int ballDirX = 0, ballDirY = -1; //The direction the ball is headed, I used individual variables instead of Vectors for ease of increment
	private float ballSpeedX = 0, ballSpeedY = 3; //The ball speed (in pixels/update). I have this separate from direction because of some collision physics when the ball hits the paddle. This way, when we set the angle the ball comes off of when it hits the paddle, we wont be changing the speed.
	private int remainingBalls = 2; //Pretty simple, how many lives the person has left.
	private Rectangle[][] board = new Rectangle[10][5]; //The brick board at the top of the screen. [width][height]
	HashMap&lt;String, Image&gt; sprites = new HashMap&lt;String, Image&gt;(); //Our map of sprites, explained above
	private Rectangle paddle; //The paddle rectangle object
	private Circle ball; //The ball circle object
	private Status status = Status.WAITING_TO_LAUNCH; //The current status of the game, from the enumeration above
[/code]
Phew! If you&#39;ve never made a game before, some of that may seem confusing. Don&#39;t worry, hopefully it will all be clear soon!

Now that we have our variables all laid out, we can finish initializing our game. Let&#39;s add these in our [tt]init()[/tt] method, [u]after[/u] the sprite loading:
[code=java]		paddle = new Rectangle((container.getWidth()/2) - (getSprite(&quot;paddle&quot;).getWidth()/2), container.getHeight() -getSprite(&quot;paddle&quot;).getHeight() - 10, getSprite(&quot;paddle&quot;).getWidth(), getSprite(&quot;paddle&quot;).getHeight());
		ball = new Circle(paddle.getCenterX(), paddle.getCenterY()-(paddle.getHeight()/2)-(getSprite(&quot;ball&quot;).getWidth()/2), (getSprite(&quot;ball&quot;).getWidth()/2));
		for(int x = 0; x &lt; board.length; x++) {
			for(int y = 0; y &lt; board[x].length; y++) {
				board[x][y] = new Rectangle(x * getSprite(&quot;brick&quot;).getWidth(), y * getSprite(&quot;brick&quot;).getHeight(), getSprite(&quot;brick&quot;).getWidth(), getSprite(&quot;brick&quot;).getHeight());
			}
		}[/code]That may look pretty confusing! It isn&#39;t, really. All it does is:

[ul][li]Create our paddle rectangle based on the size of the paddle sprite, then position it in the middle of the bottom of the screen[/li]
[li]Create our ball circle based on the size of the ball sprite, then position on in the middle of the paddle[/li]
[li]Fill our brick board with rectangles based on their index and the brick sprite size[/li][/ul]


[size=14pt][u][b]Brick breaker rendering:[/b][/u][/size]
And that&#39;s it for initializing our game! Now let&#39;s draw our game. Here is the render() method, with comments explaining each line.
[code=java]
	@Override
	public void render(GameContainer container, Graphics g) throws SlickException {
		getSprite(&quot;background&quot;).draw(); //Draw the background. (if you have no x and y set, it does 0, 0)
		for(int i = 0; i &lt; remainingBalls; i++) { //Loop through the number of balls we have left
			getSprite(&quot;ball&quot;).draw((ball.getWidth() + 5) * i + 5, container.getHeight() - ball.getHeight() - 5); //Draw each extra ball at the bottom left
		}
		for(int x = 0; x &lt; board.length; x++) {
			for(int y = 0; y &lt; board[x].length; y++) {//Loop through all the bricks
				Rectangle brick = board[x][y]; //Get the brick at this position
				if(brick == null) {
					continue;
				}
				getSprite(&quot;brick&quot;).draw(brick.getX(), brick.getY()); //Draw the brick based on it&#39;s X and Y.
			}
		}
		getSprite(&quot;paddle&quot;).draw(paddle.getX(), paddle.getY()); //Draw the paddle based on it&#39;s X and Y.
		getSprite(&quot;ball&quot;).draw(ball.getX(), ball.getY()); //Draw the ball based on it&#39;s X and Y.
	}
[/code]Again, pretty simple once you get around all the random math in there :)

Now here comes the fun part!

[size=14pt][u][b]Brick breaker physics:[/b][/u][/size]
Now that the game can be drawn and has been initialized, it&#39;s time to add the physics! Like I mentioned earlier, this is all handled in the [tt]update()[/tt] method. This is a relatively large amount of code, so I&#39;ll give it to you all at once with comments to explain each line. Good luck!
[code=java]	@Override
	public void update(GameContainer container, int time) throws SlickException {
		Input input = container.getInput(); //Input class. THIS CLASS IS IMPORTANT! This is the easiest way to get keyboard events for your game
		int dir = 0; //The variable to determine which direction the paddle moves
		if(input.isKeyDown(Input.KEY_LEFT)) {
			dir--; //If holding the left arrow, go left
		}
		if(input.isKeyDown(Input.KEY_RIGHT)) {
			dir++; //If holding both down, you wont move. If only right, you will go right.
		}
		int x = (int) (paddle.getX() + dir*paddleSpeed); //This is the x position the paddle WOULD be at if you did the move.
		if(x &gt;= 0 &amp;&amp; x + paddle.getWidth() &lt;= container.getWidth()) { //If that x position above isn&#39;t off the sides of the game,
			paddle.setX(x);//move the paddle.
		}
		switch(status) { //Switch based on the enum status we have
			case WAITING_TO_LAUNCH: //If we haven&#39;t launched yet
				if(ball.getCenterX() != paddle.getCenterX()) { //If the ball isnt in the middle of the paddle
					ball.setCenterX(paddle.getCenterX()); //Put the ball in the middle!
				}
				if(input.isKeyPressed(Input.KEY_SPACE)) { //If we pushed the space bar since the last update
					status = Status.NORMAL; //Start the game!
				}
				break;
			case NORMAL: //If the game is started
				if(input.isKeyPressed(Input.KEY_SPACE)) { //If pushed space
					container.setPaused(!container.isPaused()); //Pause/unpause the game
					return;
				}
				ball.setX(ball.getX() + ballDirX * ballSpeedX); //Set the ball X based on the ball direction and speed
				ball.setY(ball.getY() + ballDirY * ballSpeedY); //Set the ball Y based on the ball direction and speed
				Direction d = checkBallCollision(); //See below. This method finds if the ball has touched a brick, and if it has, it returns what side it hit on
				if(d != null) { //If it hit...
					switch(d) { //Switch based on the direction
						case NORTH: //Top or bottom
						case SOUTH:
							ballDirY *= -1; //Inverse the Y direction
							return;
						case EAST: //Left or right
						case WEST:
							ballDirX *= -1; //Inverse the X direction
							return;
					}
				}
				if((d = getCollisionDirection(ball, paddle)) != null) { //See below. This method sees if the ball touches the paddle, and if it does, returns which side.
					ballSpeedX += .2; //A basic speed increment to make the game interesting.
					ballSpeedY += .2;
					switch(d) {
						case NORTH: //Touched the top of the paddle (typical) [south would mean the bottom of the paddle, which means GAME OVER!]
							ballDirY *= -1; //Inverse the Y direction
							ballDirX = (int) ((((ball.getX() - paddle.getX())/(paddle.getWidth() - ball.getWidth())) - 0.5) * 5); //Some physics to determine which way the ball should head off the paddle. We do this so that you can change the way the ball moves, instead of it always being the same angle.
							return;
						case EAST:
						case WEST:
							ballDirX *= -1; //if you hit the side of the paddle (you&#39;re screwed), inverse the X direction
							return;
					}
				}
				if(ball.getX() &lt;= 0 || ball.getX() &gt;= container.getWidth() - ball.getWidth()) { //Hit the sides of the game?
					ballDirX *= -1; //Inverse X
				} else if(ball.getY() &lt;= 0) { //Hit the top? 
					ballDirY *= -1; //Inverse Y
				} else if(ball.getY() &gt;= container.getHeight()) { //Below the bottom? Uh oh...
					ball.setCenterY(paddle.getY() - ball.getRadius()); //Reset ball position
					ball.setCenterX(paddle.getCenterX()); //Reset ball position
					ballDirX = 0; //Reset speeds and directions
					ballSpeedX = 0;
					ballDirY = -1;
					ballSpeedY = 3;
					remainingBalls--; //Lose a life!
					status = Status.WAITING_TO_LAUNCH; //Change back to waiting to launch
				}
				break;
		}
	}
	private Direction checkBallCollision() { //For checking if the ball intersects a brick
		for(int x = 0; x &lt; board.length; x++) {
			for(int y = 0; y &lt; board[x].length; y++) { //Loop through all bricks..
				Rectangle brick = board[x][y]; //Get the brick at the position
				if(brick == null) {
					continue;
				}
				Direction dir = getCollisionDirection(ball, brick); //See below
				if(dir != null) { //hit a brick!
					board[x][y] = null; //Remove the brick it hit
					return dir; //Return the direction
				}
			}
		}
		return null;
	}

	//This method is pretty simple if you understand it. It creates a line for each side of the &#39;source&#39; shape, and sees if the other shape intersects that line. If it does, we know which side they intersect. If they don&#39;t, we know they aren&#39;t touching.
	private Direction getCollisionDirection(Shape shape, Shape source) { 
		if(shape.intersects(new Line(source.getX(), source.getY(), source.getX() + source.getWidth(), source.getY()))) {
			return Direction.NORTH;
		}
		if(shape.intersects(new Line(source.getX(), source.getY() + source.getHeight(), source.getX() + source.getWidth(), source.getY() + source.getHeight()))) {
			return Direction.SOUTH;
		}
		if(shape.intersects(new Line(source.getX() + source.getWidth(), source.getY(), source.getX() + source.getWidth(), source.getY() + source.getHeight()))) {
			return Direction.EAST;
		}
		if(shape.intersects(new Line(source.getX(), source.getY(), source.getX(), source.getY() + source.getHeight()))) {
			return Direction.WEST;
		}
		return null;
	}[/code]

Phew, lots of comments to read there! 

If you want to try out this game, here&#39;s a link to the (slightly modified version) executable jar:
[url=http://uppit.com/mvgby09wcq6g/BrickBreaker.jar]Brick Breaker[/url]. 
Inside you&#39;ll find all images and sprites used for this game, as well as the properties file. 

If you need more in-depth explaining of anything here (I kinda rushed), think I did something the wrong way (I probably did), or have suggestions, feel free to post!</description>
    
    <lastBuildDate>Wed, 04 Dec 2013 07:07:49 +0000</lastBuildDate>
    <category>Game Development</category>
    <atom:link href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>[quote=“imthenull, post:7, topic:412677”]Although effective, I can’t help but to point out the design flaw of <span class="bbcode-i">getSprite(String)</span>, it’s really bugging me. Why would you intentionally search the map each time the game renders? Why not reference the sprites to variables? The sprites themselves never change during run time so this would be the most viable option in my opinion.</p>
<p>It seems pointless and naggy of me to point this out, but to me it’s a huge deal. When I program something, I try to make it as fast and efficient as possible.[/quote]</p>
<p>HashMaps are fairly efficient to use. And if he was to go to a completely generic version of the getSprite code, then something like a map or similar data structure would be necessary. Not to mention, with the scale of this game, you’re not talking about a speedup at all.</p>
<p>You should read up on premature optimization and why it’s bad. Program to make it work, then program to make it faster if you need to, and only in the parts that matter.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/10</link>
        <pubDate>Wed, 04 Dec 2013 07:07:49 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-10</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@imthenull imthenull]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/imthenull">@imthenull</a> wrote:</p>
          <blockquote>
              <p>[quote=“Davidi2, post:8, topic:412677”][quote author=imthenull link=topic=514155.msg4387062#msg4387062 date=1386002966]<br>
Although effective, I can’t help but to point out the design flaw of <span class="bbcode-i">getSprite(String)</span>, it’s really bugging me. Why would you intentionally search the map each time the game renders? Why not reference the sprites to variables? The sprites themselves never change during run time so this would be the most viable option in my opinion.</p>
<p>It seems pointless and naggy of me to point this out, but to me it’s a huge deal. When I program something, I try to make it as fast and efficient as possible.<br>
[/quote]When you use a hashmap it doesn’t really affect efficiency, but I agree with you that there is probably a better way. I wrote this 2 or something years ago :D[/quote]lmao, didn’t even look at the posted date.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/9</link>
        <pubDate>Mon, 02 Dec 2013 21:36:02 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-9</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@davidi2 Davidi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/davidi2">@davidi2</a> wrote:</p>
          <blockquote>
              <p>[quote=“imthenull, post:7, topic:412677”]Although effective, I can’t help but to point out the design flaw of <span class="bbcode-i">getSprite(String)</span>, it’s really bugging me. Why would you intentionally search the map each time the game renders? Why not reference the sprites to variables? The sprites themselves never change during run time so this would be the most viable option in my opinion.</p>
<p>It seems pointless and naggy of me to point this out, but to me it’s a huge deal. When I program something, I try to make it as fast and efficient as possible.[/quote]When you use a hashmap it doesn’t really affect efficiency, but I agree with you that there is probably a better way. I wrote this 2 or something years ago <img src="https://forum.moparisthebest.com/images/emoji/twitter/smiley.png?v=5" title=":smiley:" class="emoji" alt=":smiley:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/8</link>
        <pubDate>Mon, 02 Dec 2013 21:02:00 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-8</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@imthenull imthenull]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/imthenull">@imthenull</a> wrote:</p>
          <blockquote>
              <p>Although effective, I can’t help but to point out the design flaw of <span class="bbcode-i">getSprite(String)</span>, it’s really bugging me. Why would you intentionally search the map each time the game renders? Why not reference the sprites to variables? The sprites themselves never change during run time so this would be the most viable option in my opinion.</p>
<p>It seems pointless and naggy of me to point this out, but to me it’s a huge deal. When I program something, I try to make it as fast and efficient as possible.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/7</link>
        <pubDate>Mon, 02 Dec 2013 16:49:26 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-7</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@artem543 artem543]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/artem543">@artem543</a> wrote:</p>
          <blockquote>
              <p>Amazing tutorial. Love it.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/6</link>
        <pubDate>Mon, 02 Dec 2013 05:02:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-6</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@317guy 317guy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/317guy">@317guy</a> wrote:</p>
          <blockquote>
              <p>(</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/5</link>
        <pubDate>Sun, 24 Jun 2012 12:01:57 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-5</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@imsuperman05 imsuperman05]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/imsuperman05">@imsuperman05</a> wrote:</p>
          <blockquote>
              <p>This is amazing.  I hope to learn a lot of this soon.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/4</link>
        <pubDate>Wed, 11 Apr 2012 22:05:32 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-4</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@davidi2 Davidi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/davidi2">@davidi2</a> wrote:</p>
          <blockquote>
              <p>I know, I definitely rushed it. I’ll add more to the tutorial later, I’ve just been having a busy day with my server</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/3</link>
        <pubDate>Tue, 30 Aug 2011 01:55:46 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-3</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@ripzone Triton]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ripzone">@ripzone</a> wrote:</p>
          <blockquote>
              <p>Good work, but I feel like the tutorial is a bit rushed.</p>
<p>You could explain the physics and collision detection a little better. After all that’s probably the most difficult part of the code.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/2</link>
        <pubDate>Tue, 30 Aug 2011 01:35:12 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-2</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
      <item>
        <title>Creating a Simple Game with Slick2D [Brick Breaker]</title>
        <dc:creator><![CDATA[@davidi2 Davidi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/davidi2">@davidi2</a> wrote:</p>
          <blockquote>
              <p>[center][size=24pt]<span class="bbcode-u"><span class="bbcode-b">Creating a Simple Game With Slick2D</span></span>[/size]<br>
[size=14pt]<span class="bbcode-i">Part 2: Brick Breaker</span>[/size]<br>
<img src="http://slick.cokeandcode.com/themes/slick2d/images/logo.gif" alt width="" height="">[/center]</p>
<p>[size=14pt]<span class="bbcode-u"><span class="bbcode-b">About this tutorial:</span></span>[/size]<br>
This tutorial will teach you some more features about Slick and how to use them in a game environment. This tutorial will <span class="bbcode-u"><span class="bbcode-b">not</span></span> teach you how to set up Slick or LWJGL (but you can expect something on that soon), and covers only the programming aspect of the game. Like all things that use Slick, the programming language here is Java. It is suggested you learn some basics about Java programming before attempting to follow these tutorials.<br>
Things covered in this tutorial:<br>
[list]<br>
[li]Creating a game skeleton[/li]<br>
[li]Using sprites[/li]<br>
[li]Some brick breaker variables[/li]<br>
[li]Rendering the game[/li][li]</p>
<p>[ul][li]Some basic physics[/li][/ul]</p>
<p>[size=14pt]<span class="bbcode-u"><span class="bbcode-b">Creating the game skeleton:</span></span>[/size]<br>
Like all Slick games, there is a simple skeleton you must create. It’s just this:</p>
<p>[code=java]import org.newdawn.slick.AppGameContainer;<br>
import org.newdawn.slick.GameContainer;<br>
import org.newdawn.slick.Graphics;<br>
import org.newdawn.slick.BasicGame;</p>
<p>public class BrickBreaker extends BasicGame {</p>
<pre><code>public static void main(String[] args) {
		try {
		//Initialize our game container, 450 X 600 is the size, the 'false' is saying we don't want the game full-screen
		AppGameContainer game = new AppGameContainer(new BrickBreaker(), 450, 600, false);

		//Set the target FPS (frames) and UPS (updates) per second. If you don't set this, sometimes the game will use it's own based on the computer.
		game.setTargetFrameRate(60);

		//Start the game!
		game.start();
	} catch (SlickException e) {
		e.printStackTrace();
	}
}

public BrickBreaker() {
	//Calls the super constructor with the title parameter
	super("Brick Breaker");
}

@Override
public void render(GameContainer container, Graphics g) throws SlickException {
	//Called after every update, you draw the game here. If you've made a basic game before, you may have done this in 'paint(Graphics g)'
}

@Override
public void init(GameContainer arg0) throws SlickException {
	//Called when start the game for the first time. This is where you do things like load settings, sprites, etc and create the basic game layout
}

@Override
public void update(GameContainer container, int time) throws SlickException {
	//This is where you handle all game logic. If anything moves, this is definitely where you'd handle it.
}
</code></pre>
<p>}[/code]There are explanations in the comments if you haven’t read the Pong tutorial.</p>
<p>[size=14pt]<span class="bbcode-u"><span class="bbcode-b">Using sprites:</span></span>[/size]<br>
Using sprites with Slick is EXTREMELY easy. Loading and keeping track of them in a good way can be tricky though. A simple little way to do it is with a HashMap, like so:</p>
<p>[code=java]	//Using org.newdawn.slick.Image, NOT the default Java class.<br>
HashMap&lt;String, Image&gt; sprites = new HashMap&lt;String, Image&gt;();</p>
<pre><code>private void loadSprite(String name, String resource) throws SlickException {
	sprites.put(name, new Image(BrickBreaker.class.getResourceAsStream(resource), resource, false));
}

private Image getSprite(String name) {
	return sprites.get(name);
}[/code]
</code></pre>
<p>And now we can use a simple Java Properties file:</p>
<p><code>ball_sprite=ball.gif
paddle_sprite=paddle.gif
background=background.jpg
brick_sprite=brick.gif</code><br>
alongside some loading stuff in our [tt]init()[/tt] method:</p>
<p><code>	@Override
	public void init(GameContainer container) throws SlickException {
		try {
			Properties properties = new Properties();
			properties.load(BrickBreaker.class.getResourceAsStream("props.ini"));
			loadSprite("ball", properties.getProperty("ball_sprite"));
			loadSprite("paddle", properties.getProperty("paddle_sprite"));
			loadSprite("background", properties.getProperty("background"));
			loadSprite("brick", properties.getProperty("brick_sprite"));
		} catch (IOException e) {
			e.printStackTrace();
		}
		...</code> to have our sprites all loaded into that Map!<br>
Now drawing those images onto the canvas is even easier. We can simply use<br>
[tt]getSprite(name).draw(x, y);[/tt]<br>
It really is that simple!</p>
<p>[size=14pt]<span class="bbcode-u"><span class="bbcode-b">Brick breaker variables:</span></span>[/size]<br>
In this brick breaker game, we need a few variables to keep the game interesting and (more) realistic. Here they are, with some comments to explain them:</p>
<p>[code=java]	private enum Direction { //We will use this enumeration for directions later in the physics section<br>
NORTH, SOUTH, EAST, WEST<br>
}</p>
<pre><code>private enum Status { //A simple status enumeration for where the user is in the game. You can have many more
	WAITING_TO_LAUNCH, NORMAL
}

private int paddleSpeed = 4; //The speed of the paddle, 4 pixels per update
private int ballDirX = 0, ballDirY = -1; //The direction the ball is headed, I used individual variables instead of Vectors for ease of increment
private float ballSpeedX = 0, ballSpeedY = 3; //The ball speed (in pixels/update). I have this separate from direction because of some collision physics when the ball hits the paddle. This way, when we set the angle the ball comes off of when it hits the paddle, we wont be changing the speed.
private int remainingBalls = 2; //Pretty simple, how many lives the person has left.
private Rectangle[][] board = new Rectangle[10][5]; //The brick board at the top of the screen. [width][height]
HashMap&lt;String, Image&gt; sprites = new HashMap&lt;String, Image&gt;(); //Our map of sprites, explained above
private Rectangle paddle; //The paddle rectangle object
private Circle ball; //The ball circle object
private Status status = Status.WAITING_TO_LAUNCH; //The current status of the game, from the enumeration above
</code></pre>
<p>[/code]<br>
Phew! If you’ve never made a game before, some of that may seem confusing. Don’t worry, hopefully it will all be clear soon!</p>
<p>Now that we have our variables all laid out, we can finish initializing our game. Let’s add these in our [tt]init()[/tt] method, <span class="bbcode-u">after</span> the sprite loading:</p>
<p><code>		paddle = new Rectangle((container.getWidth()/2) - (getSprite("paddle").getWidth()/2), container.getHeight() -getSprite("paddle").getHeight() - 10, getSprite("paddle").getWidth(), getSprite("paddle").getHeight());
		ball = new Circle(paddle.getCenterX(), paddle.getCenterY()-(paddle.getHeight()/2)-(getSprite("ball").getWidth()/2), (getSprite("ball").getWidth()/2));
		for(int x = 0; x &lt; board.length; x++) {
			for(int y = 0; y &lt; board[x].length; y++) {
				board[x][y] = new Rectangle(x * getSprite("brick").getWidth(), y * getSprite("brick").getHeight(), getSprite("brick").getWidth(), getSprite("brick").getHeight());
			}
		}</code>That may look pretty confusing! It isn’t, really. All it does is:</p>
<p>[ul][li]Create our paddle rectangle based on the size of the paddle sprite, then position it in the middle of the bottom of the screen[/li]<br>
[li]Create our ball circle based on the size of the ball sprite, then position on in the middle of the paddle[/li]<br>
[li]Fill our brick board with rectangles based on their index and the brick sprite size[/li][/ul]</p>
<p>[size=14pt]<span class="bbcode-u"><span class="bbcode-b">Brick breaker rendering:</span></span>[/size]<br>
And that’s it for initializing our game! Now let’s draw our game. Here is the render() method, with comments explaining each line.</p>
<p><code>
	@Override
	public void render(GameContainer container, Graphics g) throws SlickException {
		getSprite("background").draw(); //Draw the background. (if you have no x and y set, it does 0, 0)
		for(int i = 0; i &lt; remainingBalls; i++) { //Loop through the number of balls we have left
			getSprite("ball").draw((ball.getWidth() + 5) * i + 5, container.getHeight() - ball.getHeight() - 5); //Draw each extra ball at the bottom left
		}
		for(int x = 0; x &lt; board.length; x++) {
			for(int y = 0; y &lt; board[x].length; y++) {//Loop through all the bricks
				Rectangle brick = board[x][y]; //Get the brick at this position
				if(brick == null) {
					continue;
				}
				getSprite("brick").draw(brick.getX(), brick.getY()); //Draw the brick based on it's X and Y.
			}
		}
		getSprite("paddle").draw(paddle.getX(), paddle.getY()); //Draw the paddle based on it's X and Y.
		getSprite("ball").draw(ball.getX(), ball.getY()); //Draw the ball based on it's X and Y.
	}
</code>Again, pretty simple once you get around all the random math in there <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Now here comes the fun part!</p>
<p>[size=14pt]<span class="bbcode-u"><span class="bbcode-b">Brick breaker physics:</span></span>[/size]<br>
Now that the game can be drawn and has been initialized, it’s time to add the physics! Like I mentioned earlier, this is all handled in the [tt]update()[/tt] method. This is a relatively large amount of code, so I’ll give it to you all at once with comments to explain each line. Good luck!</p>
<p>[code=java]	<a class="mention" href="/u/override">@Override</a><br>
public void update(GameContainer container, int time) throws SlickException {<br>
Input input = container.getInput(); //Input class. THIS CLASS IS IMPORTANT! This is the easiest way to get keyboard events for your game<br>
int dir = 0; //The variable to determine which direction the paddle moves<br>
if(input.isKeyDown(Input.KEY_LEFT)) {<br>
dir–; //If holding the left arrow, go left<br>
}<br>
if(input.isKeyDown(Input.KEY_RIGHT)) {<br>
dir++; //If holding both down, you wont move. If only right, you will go right.<br>
}<br>
int x = (int) (paddle.getX() + dir*paddleSpeed); //This is the x position the paddle WOULD be at if you did the move.<br>
if(x &gt;= 0 &amp;&amp; x + paddle.getWidth() &lt;= container.getWidth()) { //If that x position above isn’t off the sides of the game,<br>
paddle.setX(x);//move the paddle.<br>
}<br>
switch(status) { //Switch based on the enum status we have<br>
case WAITING_TO_LAUNCH: //If we haven’t launched yet<br>
if(ball.getCenterX() != paddle.getCenterX()) { //If the ball isnt in the middle of the paddle<br>
ball.setCenterX(paddle.getCenterX()); //Put the ball in the middle!<br>
}<br>
if(input.isKeyPressed(Input.KEY_SPACE)) { //If we pushed the space bar since the last update<br>
status = Status.NORMAL; //Start the game!<br>
}<br>
break;<br>
case NORMAL: //If the game is started<br>
if(input.isKeyPressed(Input.KEY_SPACE)) { //If pushed space<br>
container.setPaused(!container.isPaused()); //Pause/unpause the game<br>
return;<br>
}<br>
ball.setX(ball.getX() + ballDirX * ballSpeedX); //Set the ball X based on the ball direction and speed<br>
ball.setY(ball.getY() + ballDirY * ballSpeedY); //Set the ball Y based on the ball direction and speed<br>
Direction d = checkBallCollision(); //See below. This method finds if the ball has touched a brick, and if it has, it returns what side it hit on<br>
if(d != null) { //If it hit…<br>
switch(d) { //Switch based on the direction<br>
case NORTH: //Top or bottom<br>
case SOUTH:<br>
ballDirY *= -1; //Inverse the Y direction<br>
return;<br>
case EAST: //Left or right<br>
case WEST:<br>
ballDirX *= -1; //Inverse the X direction<br>
return;<br>
}<br>
}<br>
if((d = getCollisionDirection(ball, paddle)) != null) { //See below. This method sees if the ball touches the paddle, and if it does, returns which side.<br>
ballSpeedX += .2; //A basic speed increment to make the game interesting.<br>
ballSpeedY += .2;<br>
switch(d) {<br>
case NORTH: //Touched the top of the paddle (typical) [south would mean the bottom of the paddle, which means GAME OVER!]<br>
ballDirY *= -1; //Inverse the Y direction<br>
ballDirX = (int) ((((ball.getX() - paddle.getX())/(paddle.getWidth() - ball.getWidth())) - 0.5) * 5); //Some physics to determine which way the ball should head off the paddle. We do this so that you can change the way the ball moves, instead of it always being the same angle.<br>
return;<br>
case EAST:<br>
case WEST:<br>
ballDirX *= -1; //if you hit the side of the paddle (you’re screwed), inverse the X direction<br>
return;<br>
}<br>
}<br>
if(ball.getX() &lt;= 0 || ball.getX() &gt;= container.getWidth() - ball.getWidth()) { //Hit the sides of the game?<br>
ballDirX *= -1; //Inverse X<br>
} else if(ball.getY() &lt;= 0) { //Hit the top?<br>
ballDirY *= -1; //Inverse Y<br>
} else if(ball.getY() &gt;= container.getHeight()) { //Below the bottom? Uh oh…<br>
ball.setCenterY(paddle.getY() - ball.getRadius()); //Reset ball position<br>
ball.setCenterX(paddle.getCenterX()); //Reset ball position<br>
ballDirX = 0; //Reset speeds and directions<br>
ballSpeedX = 0;<br>
ballDirY = -1;<br>
ballSpeedY = 3;<br>
remainingBalls–; //Lose a life!<br>
status = Status.WAITING_TO_LAUNCH; //Change back to waiting to launch<br>
}<br>
break;<br>
}<br>
}<br>
private Direction checkBallCollision() { //For checking if the ball intersects a brick<br>
for(int x = 0; x &lt; board.length; x++) {<br>
for(int y = 0; y &lt; board[x].length; y++) { //Loop through all bricks…<br>
Rectangle brick = board[x][y]; //Get the brick at the position<br>
if(brick == null) {<br>
continue;<br>
}<br>
Direction dir = getCollisionDirection(ball, brick); //See below<br>
if(dir != null) { //hit a brick!<br>
board[x][y] = null; //Remove the brick it hit<br>
return dir; //Return the direction<br>
}<br>
}<br>
}<br>
return null;<br>
}</p>
<pre><code>//This method is pretty simple if you understand it. It creates a line for each side of the 'source' shape, and sees if the other shape intersects that line. If it does, we know which side they intersect. If they don't, we know they aren't touching.
private Direction getCollisionDirection(Shape shape, Shape source) { 
	if(shape.intersects(new Line(source.getX(), source.getY(), source.getX() + source.getWidth(), source.getY()))) {
		return Direction.NORTH;
	}
	if(shape.intersects(new Line(source.getX(), source.getY() + source.getHeight(), source.getX() + source.getWidth(), source.getY() + source.getHeight()))) {
		return Direction.SOUTH;
	}
	if(shape.intersects(new Line(source.getX() + source.getWidth(), source.getY(), source.getX() + source.getWidth(), source.getY() + source.getHeight()))) {
		return Direction.EAST;
	}
	if(shape.intersects(new Line(source.getX(), source.getY(), source.getX(), source.getY() + source.getHeight()))) {
		return Direction.WEST;
	}
	return null;
}[/code]
</code></pre>
<p>Phew, lots of comments to read there!</p>
<p>If you want to try out this game, here’s a link to the (slightly modified version) executable jar:<br>
<a href="http://uppit.com/mvgby09wcq6g/BrickBreaker.jar" data-bbcode="true">Brick Breaker</a>.<br>
Inside you’ll find all images and sprites used for this game, as well as the properties file.</p>
<p>If you need more in-depth explaining of anything here (I kinda rushed), think I did something the wrong way (I probably did), or have suggestions, feel free to post!</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677/1</link>
        <pubDate>Tue, 30 Aug 2011 00:37:10 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-412677-1</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-simple-game-with-slick2d-brick-breaker/412677.rss">Creating a Simple Game with Slick2D [Brick Breaker]</source>
      </item>
  </channel>
</rss>
