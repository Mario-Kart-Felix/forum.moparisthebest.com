<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Buffer Overflow when running</title>
    <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631</link>
    <description>Recently I have downloaded the insanityX server and maiestas client and tried to connect them.
But now when I run I get Buffer Overflow error:
[CODE]Exception in thread &quot;Thread-3&quot; java.lang.RuntimeException: buffer overflow!
	at OnDemandFetcher.getNextNode(OnDemandFetcher.java:399)
	at Client.processOnDemandQueue(Client.java:12590)
	at Client.processGameLoop(Client.java:12051)
	at RSApplet.run(RSApplet.java:182)
	at Client.run(Client.java:14353)
	at java.lang.Thread.run(Unknown Source)[/CODE]
This is my OnDemandFetcher.java:
[CODE]// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 

import java.io.*;
import java.net.Socket;
import java.util.zip.CRC32;
import java.util.zip.GZIPInputStream;

public final class OnDemandFetcher extends OnDemandFetcherParent
	implements Runnable
{

    private void readData()  {
		try {
			int j = inputStream.available();
			if(expectedSize == 0 &amp;&amp; j &gt;= 6)
			{
			waiting = true;
			for(int k = 0; k &lt; 6; k += inputStream.read(ioBuffer, k, 6 - k));
			int l = ioBuffer[0] &amp; 0xff;
			int j1 = ((ioBuffer[1] &amp; 0xff) &lt;&lt; 8) + (ioBuffer[2] &amp; 0xff);
			int l1 = ((ioBuffer[3] &amp; 0xff) &lt;&lt; 8) + (ioBuffer[4] &amp; 0xff);
			int i2 = ioBuffer[5] &amp; 0xff;
			current = null;
			for(OnDemandData onDemandData = (OnDemandData) requested.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) requested.reverseGetNext())
			{
				if(onDemandData.dataType == l &amp;&amp; onDemandData.ID == j1)
				current = onDemandData;
				if(current != null)
				onDemandData.loopCycle = 0;
			}

			if(current != null)
			{
				loopCycle = 0;
				if(l1 == 0)
				{
				Signlink.reporterror(&quot;Rej: &quot; + l + &quot;,&quot; + j1);
				current.buffer = null;
				if(current.incomplete)
					synchronized(aClass19_1358)
					{
					aClass19_1358.insertHead(current);
					}
				else
					current.unlink();
				current = null;
				} else
				{
				if(current.buffer == null &amp;&amp; i2 == 0)
					current.buffer = new byte[l1];
				if(current.buffer == null &amp;&amp; i2 != 0)
					throw new IOException(&quot;missing start of file&quot;);
				}
			}
			completedSize = i2 * 500;
			expectedSize = 500;
			if(expectedSize &gt; l1 - i2 * 500)
				expectedSize = l1 - i2 * 500;
			}
			if(expectedSize &gt; 0 &amp;&amp; j &gt;= expectedSize)
			{
			waiting = true;
			byte abyte0[] = ioBuffer;
			int i1 = 0;
			if(current != null)
			{
				abyte0 = current.buffer;
				i1 = completedSize;
			}
			for(int k1 = 0; k1 &lt; expectedSize; k1 += inputStream.read(abyte0, k1 + i1, expectedSize - k1));
			if(expectedSize + completedSize &gt;= abyte0.length &amp;&amp; current != null)
			{
				if(clientInstance.decompressors[0] != null)
				clientInstance.decompressors[current.dataType + 1].method234(abyte0.length, abyte0, current.ID);
				if(!current.incomplete &amp;&amp; current.dataType == 3)
				{
				current.incomplete = true;
				current.dataType = 93;
				}
				if(current.incomplete)
				synchronized(aClass19_1358)
				{
					aClass19_1358.insertHead(current);
				}
				else
				current.unlink();
			}
			expectedSize = 0;
			}
		}
		catch(IOException ioexception) {
			try {
				socket.close();
			} catch(Exception _ex) {
			}
			socket = null;
			inputStream = null;
			outputStream = null;
			expectedSize = 0;
		}
    }

    public int mapAmount = 0;

    public void start(StreamLoader streamLoader, Client client1)
    {
        byte[] abyte2 = streamLoader.getDataForName(&quot;map_index&quot;);
        Stream stream2 = new Stream(abyte2);
        int j1 = abyte2.length / 6;
        mapIndices1 = new int[j1];
        mapIndices2 = new int[j1];
        mapIndices3 = new int[j1];
        for(int i2 = 0; i2 &lt; j1; i2++)
        {
            mapIndices1[i2] = stream2.readUnsignedWord();
            mapIndices2[i2] = stream2.readUnsignedWord();
            mapIndices3[i2] = stream2.readUnsignedWord();
            mapAmount++;
        }
        System.out.println(&quot;Maps Loaded: &quot;+mapAmount+&quot;&quot;);
        abyte2 = streamLoader.getDataForName(&quot;midi_index&quot;);
        stream2 = new Stream(abyte2);
        j1 = abyte2.length;
        anIntArray1348 = new int[j1];
        for(int k2 = 0; k2 &lt; j1; k2++)
            anIntArray1348[k2] = stream2.readUnsignedByte();

        clientInstance = client1;
        running = true;
        clientInstance.startRunnable(this, 2);
    }

    public int getNodeCount()
    {
	synchronized(nodeSubList)
	{
	    return nodeSubList.getNodeCount();
	}
    }

    public void disable()
    {
	running = false;
    }

    public void method554(boolean flag)
    {
	int j = mapIndices1.length;
	for(int k = 0; k &lt; j; k++)
	    if(flag || mapIndices4[k] != 0)
	    {
		method563((byte)2, 3, mapIndices3[k]);
		method563((byte)2, 3, mapIndices2[k]);
	    }

    }

    public int getVersionCount(int j)
    {
	return versions[j].length;
    }

    private void closeRequest(OnDemandData onDemandData)
    {
	try
	{
	    if(socket == null)
	    {
		long l = System.currentTimeMillis();
		if(l - openSocketTime &lt; 4000L)
		    return;
		openSocketTime = l;
		socket = clientInstance.openSocket(43594 + Client.portOff);
		inputStream = socket.getInputStream();
		outputStream = socket.getOutputStream();
		outputStream.write(15);
		for(int j = 0; j &lt; 8; j++)
		    inputStream.read();

		loopCycle = 0;
	    }
	    ioBuffer[0] = (byte)onDemandData.dataType;
	    ioBuffer[1] = (byte)(onDemandData.ID &gt;&gt; 8);
	    ioBuffer[2] = (byte)onDemandData.ID;
	    if(onDemandData.incomplete)
		ioBuffer[3] = 2;
	    else
	    if(!clientInstance.loggedIn)
		ioBuffer[3] = 1;
	    else
		ioBuffer[3] = 0;
	    outputStream.write(ioBuffer, 0, 4);
	    writeLoopCycle = 0;
	    anInt1349 = -10000;
	    return;
	}
	catch(IOException ioexception) { }
	try
	{
	    socket.close();
	}
	catch(Exception _ex) { }
	socket = null;
	inputStream = null;
	outputStream = null;
	expectedSize = 0;
	anInt1349++;
    }

    public int getAnimCount()
    {
	//return anIntArray1360.length;
    return 65535;
    }
    
    public int getModelCount() {
    	return 65535;
    }

    public void method558(int i, int j)
    {
	//if(i &lt; 0 || i &gt; versions.length || j &lt; 0 || j &gt; versions[i].length)
	    //return;
	//if(versions[i][j] == 0)
	    //return;
	synchronized(nodeSubList)
	{
	    for(OnDemandData onDemandData = (OnDemandData) nodeSubList.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) nodeSubList.reverseGetNext())
		if(onDemandData.dataType == i &amp;&amp; onDemandData.ID == j)
		    return;

	    OnDemandData onDemandData_1 = new OnDemandData();
	    onDemandData_1.dataType = i;
	    onDemandData_1.ID = j;
	    onDemandData_1.incomplete = true;
	    synchronized(aClass19_1370)
	    {
		aClass19_1370.insertHead(onDemandData_1);
	    }
	    nodeSubList.insertHead(onDemandData_1);
	}
    }

    public int getModelIndex(int i)
    {
	//return modelIndices[i] &amp; 0xff;
    return 65535;
    }

    public void run()
    {
	try
	{
	    while(running)
	    {
		onDemandCycle++;
		int i = 20;
		if(anInt1332 == 0 &amp;&amp; clientInstance.decompressors[0] != null)
		    i = 50;
		try
		{
		    Thread.sleep(i);
		}
		catch(Exception _ex) { }
		waiting = true;
		for(int j = 0; j &lt; 100; j++)
		{
		    if(!waiting)
			break;
		    waiting = false;
		    checkReceived();
		    //handleFailed();
		    if(uncompletedCount == 0 &amp;&amp; j &gt;= 5)
			break;
		    method568();
		    if(inputStream != null)
			readData();
		}

		boolean flag = false;
		for(OnDemandData onDemandData = (OnDemandData) requested.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) requested.reverseGetNext())
		    if(onDemandData.incomplete)
		    {
			flag = true;
			onDemandData.loopCycle++;
			if(onDemandData.loopCycle &gt; 50)
			{
			    onDemandData.loopCycle = 0;
			    closeRequest(onDemandData);
			}
		    }

		if(!flag)
		{
		    for(OnDemandData onDemandData_1 = (OnDemandData) requested.reverseGetFirst(); onDemandData_1 != null; onDemandData_1 = (OnDemandData) requested.reverseGetNext())
		    {
			flag = true;
			onDemandData_1.loopCycle++;
			if(onDemandData_1.loopCycle &gt; 50)
			{
			    onDemandData_1.loopCycle = 0;
			    closeRequest(onDemandData_1);
			}
		    }

		}
		if(flag)
		{
		    loopCycle++;
		    if(loopCycle &gt; 750)
		    {
			try
			{
			    socket.close();
			}
			catch(Exception _ex) { }
			socket = null;
			inputStream = null;
			outputStream = null;
			expectedSize = 0;
		    }
		} else
		{
		    loopCycle = 0;
		    statusString = &quot;&quot;;
		}
		if(clientInstance.loggedIn &amp;&amp; socket != null &amp;&amp; outputStream != null &amp;&amp; (anInt1332 &gt; 0 || clientInstance.decompressors[0] == null))
		{
		    writeLoopCycle++;
		    if(writeLoopCycle &gt; 500)
		    {
			writeLoopCycle = 0;
			ioBuffer[0] = 0;
			ioBuffer[1] = 0;
			ioBuffer[2] = 0;
			ioBuffer[3] = 10;
			try
			{
			    outputStream.write(ioBuffer, 0, 4);
			}
			catch(IOException _ex)
			{
			    loopCycle = 5000;
			}
		    }
		}
	    }
	}
	catch(Exception exception)
	{
	    Signlink.reporterror(&quot;od_ex &quot; + exception.getMessage());
	}
    }

    public void method560(int i, int j)
    {
	if(clientInstance.decompressors[0] == null)
	    return;
	//if(versions[j][i] == 0)
	    //return;
	//if(fileStatus[j][i] == 0)
	  //  return;
	if(anInt1332 == 0)
	    return;
	OnDemandData onDemandData = new OnDemandData();
	onDemandData.dataType = j;
	onDemandData.ID = i;
	onDemandData.incomplete = false;
	synchronized(aClass19_1344)
	{
	    aClass19_1344.insertHead(onDemandData);
	}
    }

    public OnDemandData getNextNode()
    {
	OnDemandData onDemandData;
	synchronized(aClass19_1358)
	{
	    onDemandData = (OnDemandData)aClass19_1358.popHead();
	}
	if(onDemandData == null)
	    return null;
	synchronized(nodeSubList)
	{
	    onDemandData.unlinkSub();
	}
	if(onDemandData.buffer == null)
	    return onDemandData;
	int i = 0;
	try
	{
	    GZIPInputStream gzipinputstream = new GZIPInputStream(new ByteArrayInputStream(onDemandData.buffer));
	    do
	    {
		if(i == gzipInputBuffer.length)
		    throw new RuntimeException(&quot;buffer overflow!&quot;);
		int k = gzipinputstream.read(gzipInputBuffer, i, gzipInputBuffer.length - i);
		if(k == -1)
		    break;
		i += k;
	    } while(true);
	}
	catch(IOException _ex)
	{
	    throw new RuntimeException(&quot;error unzipping&quot;);
	}
	onDemandData.buffer = new byte[i];
	System.arraycopy(gzipInputBuffer, 0, onDemandData.buffer, 0, i);

	return onDemandData;
    }

    public int method562(int i, int k, int l)
    {
	int i1 = (l &lt;&lt; 8) + k;
	for(int j1 = 0; j1 &lt; mapIndices1.length; j1++)
	    if(mapIndices1[j1] == i1)
		if(i == 0)
		    return mapIndices2[j1];
		else
		    return mapIndices3[j1];
	return -1;
    }

    public void method548(int i)
    {
	method558(0, i);
    }

    public void method563(byte byte0, int i, int j)
    {
	if(clientInstance.decompressors[0] == null)
	    return;
	//if(versions[i][j] == 0)
	    //return;
	clientInstance.decompressors[i + 1].decompress(j);
	//if(crcMatches(versions[i][j], crcs[i][j], abyte0))
	//    return;
	//fileStatus[i][j] = byte0;
	if(byte0 &gt; anInt1332)
	    anInt1332 = byte0;
	totalFiles++;
    }

    public boolean method564(int i)
    {
	for(int k = 0; k &lt; mapIndices1.length; k++)
	    if(mapIndices3[k] == i)
		return true;
	return false;
    }

    @SuppressWarnings(&quot;unused&quot;)
	private void handleFailed()
    {
	uncompletedCount = 0;
	completedCount = 0;
	for(OnDemandData onDemandData = (OnDemandData) requested.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) requested.reverseGetNext())
	    if(onDemandData.incomplete)
		uncompletedCount++;
	    else
		completedCount++;

	while(uncompletedCount &lt; 10)
	{
	    OnDemandData onDemandData_1 = (OnDemandData)aClass19_1368.popHead();
	    if(onDemandData_1 == null)
		break;
	    if(fileStatus[onDemandData_1.dataType][onDemandData_1.ID] != 0)
		filesLoaded++;
	    fileStatus[onDemandData_1.dataType][onDemandData_1.ID] = 0;
	    requested.insertHead(onDemandData_1);
	    uncompletedCount++;
	    closeRequest(onDemandData_1);
	    waiting = true;
	}
    }

    public void method566()
    {
	synchronized(aClass19_1344)
	{
	    aClass19_1344.removeAll();
	}
    }

    private void checkReceived()
    {
	OnDemandData onDemandData;
	synchronized(aClass19_1370)
	{
	    onDemandData = (OnDemandData)aClass19_1370.popHead();
	}
	while(onDemandData != null)
	{
	    waiting = true;
	    byte abyte0[] = null;
	    if(clientInstance.decompressors[0] != null)
		abyte0 = clientInstance.decompressors[onDemandData.dataType + 1].decompress(onDemandData.ID);
	    //if(!crcMatches(versions[onDemandData.dataType][onDemandData.ID], crcs[onDemandData.dataType][onDemandData.ID], abyte0))
	    //    abyte0 = null;
	    synchronized(aClass19_1370)
	    {
		if(abyte0 == null)
		{
		    aClass19_1368.insertHead(onDemandData);
		} else
		{
		    onDemandData.buffer = abyte0;
		    synchronized(aClass19_1358)
		    {
			aClass19_1358.insertHead(onDemandData);
		    }
		}
		onDemandData = (OnDemandData)aClass19_1370.popHead();
	    }
	}
    }

    private void method568()
    {
	while(uncompletedCount == 0 &amp;&amp; completedCount &lt; 10)
	{
	    if(anInt1332 == 0)
		break;
	    OnDemandData onDemandData;
	    synchronized(aClass19_1344)
	    {
		onDemandData = (OnDemandData)aClass19_1344.popHead();
	    }
	    while(onDemandData != null)
	    {
		if(fileStatus[onDemandData.dataType][onDemandData.ID] != 0)
		{
		    fileStatus[onDemandData.dataType][onDemandData.ID] = 0;
		    requested.insertHead(onDemandData);
		    closeRequest(onDemandData);
		    waiting = true;
		    if(filesLoaded &lt; totalFiles)
			filesLoaded++;
		    statusString = &quot;Loading extra files - &quot; + (filesLoaded * 100) / totalFiles + &quot;%&quot;;
		    completedCount++;
		    if(completedCount == 10)
			return;
		}
		synchronized(aClass19_1344)
		{
		    onDemandData = (OnDemandData)aClass19_1344.popHead();
		}
	    }
	    for(int j = 0; j &lt; 4; j++)
	    {
		byte abyte0[] = fileStatus[j];
		int k = abyte0.length;
		for(int l = 0; l &lt; k; l++)
		    if(abyte0[l] == anInt1332)
		    {
			abyte0[l] = 0;
			OnDemandData onDemandData_1 = new OnDemandData();
			onDemandData_1.dataType = j;
			onDemandData_1.ID = l;
			onDemandData_1.incomplete = false;
			requested.insertHead(onDemandData_1);
			closeRequest(onDemandData_1);
			waiting = true;
			if(filesLoaded &lt; totalFiles)
			    filesLoaded++;
			statusString = &quot;Loading extra files - &quot; + (filesLoaded * 100) / totalFiles + &quot;%&quot;;
			completedCount++;
			if(completedCount == 10)
			    return;
		    }

	    }

	    anInt1332--;
	}
    }

    public boolean method569(int i)
    {
	return anIntArray1348[i] == 1;
    }

    public OnDemandFetcher()
    {
	requested = new NodeList();
	statusString = &quot;&quot;;
	new CRC32();
	ioBuffer = new byte[500];
	fileStatus = new byte[4][];
	aClass19_1344 = new NodeList();
	running = true;
	waiting = false;
	aClass19_1358 = new NodeList();
	gzipInputBuffer = new byte[999999];
	nodeSubList = new NodeSubList();
	versions = new int[4][];
	aClass19_1368 = new NodeList();
	aClass19_1370 = new NodeList();
    }

    private int totalFiles;
    private final NodeList requested;
    private int anInt1332;
    public String statusString;
    private int writeLoopCycle;
    private long openSocketTime;
    private int[] mapIndices3;
    private final byte[] ioBuffer;
    public int onDemandCycle;
    private final byte[][] fileStatus;
    private Client clientInstance;
    private final NodeList aClass19_1344;
    private int completedSize;
    private int expectedSize;
    private int[] anIntArray1348;
    public int anInt1349;
    private int[] mapIndices2;
    private int filesLoaded;
    private boolean running;
    private OutputStream outputStream;
    private int[] mapIndices4;
    private boolean waiting;
    private final NodeList aClass19_1358;
    private final byte[] gzipInputBuffer;
    private final NodeSubList nodeSubList;
    private InputStream inputStream;
    private Socket socket;
    private final int[][] versions;
    private int uncompletedCount;
    private int completedCount;
    private final NodeList aClass19_1368;
    private OnDemandData current;
    private final NodeList aClass19_1370;
    private int[] mapIndices1;
    private int loopCycle;
}
[/CODE]</description>
    
    <lastBuildDate>Sat, 25 Jul 2015 22:01:47 +0000</lastBuildDate>
    <category>Game Development</category>
    <atom:link href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Buffer Overflow when running</title>
        <dc:creator><![CDATA[@xX4m4zingXx xX4m4zingXx]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xx4m4zingxx">@xX4m4zingXx</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="6" data-topic="552631">
<div class="title">
<div class="quote-controls"></div>
 Justin Bieber:</div>
<blockquote>
<p>pretty sure the contents of that onDemandData buffer are not gzipped, or even data from some other unrelated packets. it expects a -1 at the end of the buffer and gets to the end before reading it. i’m not sure if that’s just shit decompiled code though… in java you know the length of an array so can just stop looping before you get to the end.</p>
</blockquote>
</aside>
<p>I have fixed the run animation, I just used another one and that worked.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/7</link>
        <pubDate>Sat, 25 Jul 2015 22:01:47 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-552631-7</guid>
        <source url="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss">Buffer Overflow when running</source>
      </item>
      <item>
        <title>Buffer Overflow when running</title>
        <dc:creator><![CDATA[@xx_matty_xx Justin Bieber]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xx_matty_xx">@xx_matty_xx</a> wrote:</p>
          <blockquote>
              <p>pretty sure the contents of that onDemandData buffer are not gzipped, or even data from some other unrelated packets. it expects a -1 at the end of the buffer and gets to the end before reading it. i’m not sure if that’s just shit decompiled code though… in java you know the length of an array so can just stop looping before you get to the end.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/6</link>
        <pubDate>Sat, 25 Jul 2015 21:59:12 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-552631-6</guid>
        <source url="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss">Buffer Overflow when running</source>
      </item>
      <item>
        <title>Buffer Overflow when running</title>
        <dc:creator><![CDATA[@xX4m4zingXx xX4m4zingXx]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xx4m4zingxx">@xX4m4zingXx</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="4" data-topic="552631">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/my-swagger/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> my-swagger:</div>
<blockquote>
<p>You’re not sending the correct data then.</p>
</blockquote>
</aside>
<p>I have found out that other animations aren’t working too, so I think I’m going to load older animations.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/5</link>
        <pubDate>Sat, 25 Jul 2015 19:18:12 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-552631-5</guid>
        <source url="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss">Buffer Overflow when running</source>
      </item>
      <item>
        <title>Buffer Overflow when running</title>
        <dc:creator><![CDATA[@my-swagger my-swagger]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/my-swagger">@my-swagger</a> wrote:</p>
          <blockquote>
              <p>You’re not sending the correct data then.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/4</link>
        <pubDate>Sat, 25 Jul 2015 19:16:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-552631-4</guid>
        <source url="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss">Buffer Overflow when running</source>
      </item>
      <item>
        <title>Buffer Overflow when running</title>
        <dc:creator><![CDATA[@xX4m4zingXx xX4m4zingXx]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xx4m4zingxx">@xX4m4zingXx</a> wrote:</p>
          <blockquote>
              <p>Well almost everything else is working and I am not sure why this is only happening with the run animation</p>
<p>[EDIT]The error comes when I run with a scimitar.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/3</link>
        <pubDate>Sat, 25 Jul 2015 16:07:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-552631-3</guid>
        <source url="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss">Buffer Overflow when running</source>
      </item>
      <item>
        <title>Buffer Overflow when running</title>
        <dc:creator><![CDATA[@my-swagger my-swagger]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/my-swagger">@my-swagger</a> wrote:</p>
          <blockquote>
              <p>Probably not sending/receiving packets in the correct order. Is the client you using compatible with your source?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/2</link>
        <pubDate>Sat, 25 Jul 2015 15:25:26 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-552631-2</guid>
        <source url="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss">Buffer Overflow when running</source>
      </item>
      <item>
        <title>Buffer Overflow when running</title>
        <dc:creator><![CDATA[@xX4m4zingXx xX4m4zingXx]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xx4m4zingxx">@xX4m4zingXx</a> wrote:</p>
          <blockquote>
              <p>Recently I have downloaded the insanityX server and maiestas client and tried to connect them.<br>
But now when I run I get Buffer Overflow error:</p>
<p><code>Exception in thread "Thread-3" java.lang.RuntimeException: buffer overflow!
	at OnDemandFetcher.getNextNode(OnDemandFetcher.java:399)
	at Client.processOnDemandQueue(Client.java:12590)
	at Client.processGameLoop(Client.java:12051)
	at RSApplet.run(RSApplet.java:182)
	at Client.run(Client.java:14353)
	at java.lang.Thread.run(Unknown Source)</code><br>
This is my OnDemandFetcher.java:</p>
<p>[CODE]// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.<br>
// Jad home page: <a href="http://www.kpdus.com/jad.html" rel="nofollow noopener">http://www.kpdus.com/jad.html</a><br>
// Decompiler options: packimports(3)</p>
<p>import <a href="http://java.io" rel="nofollow noopener">java.io</a>.*;<br>
import java.net.Socket;<br>
import java.util.zip.CRC32;<br>
import java.util.zip.GZIPInputStream;</p>
<p>public final class OnDemandFetcher extends OnDemandFetcherParent<br>
implements Runnable<br>
{</p>
<pre><code>private void readData()  {
	try {
		int j = inputStream.available();
		if(expectedSize == 0 &amp;&amp; j &gt;= 6)
		{
		waiting = true;
		for(int k = 0; k &lt; 6; k += inputStream.read(ioBuffer, k, 6 - k));
		int l = ioBuffer[0] &amp; 0xff;
		int j1 = ((ioBuffer[1] &amp; 0xff) &lt;&lt; 8) + (ioBuffer[2] &amp; 0xff);
		int l1 = ((ioBuffer[3] &amp; 0xff) &lt;&lt; 8) + (ioBuffer[4] &amp; 0xff);
		int i2 = ioBuffer[5] &amp; 0xff;
		current = null;
		for(OnDemandData onDemandData = (OnDemandData) requested.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) requested.reverseGetNext())
		{
			if(onDemandData.dataType == l &amp;&amp; onDemandData.ID == j1)
			current = onDemandData;
			if(current != null)
			onDemandData.loopCycle = 0;
		}

		if(current != null)
		{
			loopCycle = 0;
			if(l1 == 0)
			{
			Signlink.reporterror("Rej: " + l + "," + j1);
			current.buffer = null;
			if(current.incomplete)
				synchronized(aClass19_1358)
				{
				aClass19_1358.insertHead(current);
				}
			else
				current.unlink();
			current = null;
			} else
			{
			if(current.buffer == null &amp;&amp; i2 == 0)
				current.buffer = new byte[l1];
			if(current.buffer == null &amp;&amp; i2 != 0)
				throw new IOException("missing start of file");
			}
		}
		completedSize = i2 * 500;
		expectedSize = 500;
		if(expectedSize &gt; l1 - i2 * 500)
			expectedSize = l1 - i2 * 500;
		}
		if(expectedSize &gt; 0 &amp;&amp; j &gt;= expectedSize)
		{
		waiting = true;
		byte abyte0[] = ioBuffer;
		int i1 = 0;
		if(current != null)
		{
			abyte0 = current.buffer;
			i1 = completedSize;
		}
		for(int k1 = 0; k1 &lt; expectedSize; k1 += inputStream.read(abyte0, k1 + i1, expectedSize - k1));
		if(expectedSize + completedSize &gt;= abyte0.length &amp;&amp; current != null)
		{
			if(clientInstance.decompressors[0] != null)
			clientInstance.decompressors[current.dataType + 1].method234(abyte0.length, abyte0, current.ID);
			if(!current.incomplete &amp;&amp; current.dataType == 3)
			{
			current.incomplete = true;
			current.dataType = 93;
			}
			if(current.incomplete)
			synchronized(aClass19_1358)
			{
				aClass19_1358.insertHead(current);
			}
			else
			current.unlink();
		}
		expectedSize = 0;
		}
	}
	catch(IOException ioexception) {
		try {
			socket.close();
		} catch(Exception _ex) {
		}
		socket = null;
		inputStream = null;
		outputStream = null;
		expectedSize = 0;
	}
}

public int mapAmount = 0;

public void start(StreamLoader streamLoader, Client client1)
{
    byte[] abyte2 = streamLoader.getDataForName("map_index");
    Stream stream2 = new Stream(abyte2);
    int j1 = abyte2.length / 6;
    mapIndices1 = new int[j1];
    mapIndices2 = new int[j1];
    mapIndices3 = new int[j1];
    for(int i2 = 0; i2 &lt; j1; i2++)
    {
        mapIndices1[i2] = stream2.readUnsignedWord();
        mapIndices2[i2] = stream2.readUnsignedWord();
        mapIndices3[i2] = stream2.readUnsignedWord();
        mapAmount++;
    }
    System.out.println("Maps Loaded: "+mapAmount+"");
    abyte2 = streamLoader.getDataForName("midi_index");
    stream2 = new Stream(abyte2);
    j1 = abyte2.length;
    anIntArray1348 = new int[j1];
    for(int k2 = 0; k2 &lt; j1; k2++)
        anIntArray1348[k2] = stream2.readUnsignedByte();

    clientInstance = client1;
    running = true;
    clientInstance.startRunnable(this, 2);
}

public int getNodeCount()
{
synchronized(nodeSubList)
{
    return nodeSubList.getNodeCount();
}
}

public void disable()
{
running = false;
}

public void method554(boolean flag)
{
int j = mapIndices1.length;
for(int k = 0; k &lt; j; k++)
    if(flag || mapIndices4[k] != 0)
    {
	method563((byte)2, 3, mapIndices3[k]);
	method563((byte)2, 3, mapIndices2[k]);
    }

}

public int getVersionCount(int j)
{
return versions[j].length;
}

private void closeRequest(OnDemandData onDemandData)
{
try
{
    if(socket == null)
    {
	long l = System.currentTimeMillis();
	if(l - openSocketTime &lt; 4000L)
	    return;
	openSocketTime = l;
	socket = clientInstance.openSocket(43594 + Client.portOff);
	inputStream = socket.getInputStream();
	outputStream = socket.getOutputStream();
	outputStream.write(15);
	for(int j = 0; j &lt; 8; j++)
	    inputStream.read();

	loopCycle = 0;
    }
    ioBuffer[0] = (byte)onDemandData.dataType;
    ioBuffer[1] = (byte)(onDemandData.ID &gt;&gt; 8);
    ioBuffer[2] = (byte)onDemandData.ID;
    if(onDemandData.incomplete)
	ioBuffer[3] = 2;
    else
    if(!clientInstance.loggedIn)
	ioBuffer[3] = 1;
    else
	ioBuffer[3] = 0;
    outputStream.write(ioBuffer, 0, 4);
    writeLoopCycle = 0;
    anInt1349 = -10000;
    return;
}
catch(IOException ioexception) { }
try
{
    socket.close();
}
catch(Exception _ex) { }
socket = null;
inputStream = null;
outputStream = null;
expectedSize = 0;
anInt1349++;
}

public int getAnimCount()
{
//return anIntArray1360.length;
return 65535;
}

public int getModelCount() {
	return 65535;
}

public void method558(int i, int j)
{
//if(i &lt; 0 || i &gt; versions.length || j &lt; 0 || j &gt; versions[i].length)
    //return;
//if(versions[i][j] == 0)
    //return;
synchronized(nodeSubList)
{
    for(OnDemandData onDemandData = (OnDemandData) nodeSubList.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) nodeSubList.reverseGetNext())
	if(onDemandData.dataType == i &amp;&amp; onDemandData.ID == j)
	    return;

    OnDemandData onDemandData_1 = new OnDemandData();
    onDemandData_1.dataType = i;
    onDemandData_1.ID = j;
    onDemandData_1.incomplete = true;
    synchronized(aClass19_1370)
    {
	aClass19_1370.insertHead(onDemandData_1);
    }
    nodeSubList.insertHead(onDemandData_1);
}
}

public int getModelIndex(int i)
{
//return modelIndices[i] &amp; 0xff;
return 65535;
}

public void run()
{
try
{
    while(running)
    {
	onDemandCycle++;
	int i = 20;
	if(anInt1332 == 0 &amp;&amp; clientInstance.decompressors[0] != null)
	    i = 50;
	try
	{
	    Thread.sleep(i);
	}
	catch(Exception _ex) { }
	waiting = true;
	for(int j = 0; j &lt; 100; j++)
	{
	    if(!waiting)
		break;
	    waiting = false;
	    checkReceived();
	    //handleFailed();
	    if(uncompletedCount == 0 &amp;&amp; j &gt;= 5)
		break;
	    method568();
	    if(inputStream != null)
		readData();
	}

	boolean flag = false;
	for(OnDemandData onDemandData = (OnDemandData) requested.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) requested.reverseGetNext())
	    if(onDemandData.incomplete)
	    {
		flag = true;
		onDemandData.loopCycle++;
		if(onDemandData.loopCycle &gt; 50)
		{
		    onDemandData.loopCycle = 0;
		    closeRequest(onDemandData);
		}
	    }

	if(!flag)
	{
	    for(OnDemandData onDemandData_1 = (OnDemandData) requested.reverseGetFirst(); onDemandData_1 != null; onDemandData_1 = (OnDemandData) requested.reverseGetNext())
	    {
		flag = true;
		onDemandData_1.loopCycle++;
		if(onDemandData_1.loopCycle &gt; 50)
		{
		    onDemandData_1.loopCycle = 0;
		    closeRequest(onDemandData_1);
		}
	    }

	}
	if(flag)
	{
	    loopCycle++;
	    if(loopCycle &gt; 750)
	    {
		try
		{
		    socket.close();
		}
		catch(Exception _ex) { }
		socket = null;
		inputStream = null;
		outputStream = null;
		expectedSize = 0;
	    }
	} else
	{
	    loopCycle = 0;
	    statusString = "";
	}
	if(clientInstance.loggedIn &amp;&amp; socket != null &amp;&amp; outputStream != null &amp;&amp; (anInt1332 &gt; 0 || clientInstance.decompressors[0] == null))
	{
	    writeLoopCycle++;
	    if(writeLoopCycle &gt; 500)
	    {
		writeLoopCycle = 0;
		ioBuffer[0] = 0;
		ioBuffer[1] = 0;
		ioBuffer[2] = 0;
		ioBuffer[3] = 10;
		try
		{
		    outputStream.write(ioBuffer, 0, 4);
		}
		catch(IOException _ex)
		{
		    loopCycle = 5000;
		}
	    }
	}
    }
}
catch(Exception exception)
{
    Signlink.reporterror("od_ex " + exception.getMessage());
}
}

public void method560(int i, int j)
{
if(clientInstance.decompressors[0] == null)
    return;
//if(versions[j][i] == 0)
    //return;
//if(fileStatus[j][i] == 0)
  //  return;
if(anInt1332 == 0)
    return;
OnDemandData onDemandData = new OnDemandData();
onDemandData.dataType = j;
onDemandData.ID = i;
onDemandData.incomplete = false;
synchronized(aClass19_1344)
{
    aClass19_1344.insertHead(onDemandData);
}
}

public OnDemandData getNextNode()
{
OnDemandData onDemandData;
synchronized(aClass19_1358)
{
    onDemandData = (OnDemandData)aClass19_1358.popHead();
}
if(onDemandData == null)
    return null;
synchronized(nodeSubList)
{
    onDemandData.unlinkSub();
}
if(onDemandData.buffer == null)
    return onDemandData;
int i = 0;
try
{
    GZIPInputStream gzipinputstream = new GZIPInputStream(new ByteArrayInputStream(onDemandData.buffer));
    do
    {
	if(i == gzipInputBuffer.length)
	    throw new RuntimeException("buffer overflow!");
	int k = gzipinputstream.read(gzipInputBuffer, i, gzipInputBuffer.length - i);
	if(k == -1)
	    break;
	i += k;
    } while(true);
}
catch(IOException _ex)
{
    throw new RuntimeException("error unzipping");
}
onDemandData.buffer = new byte[i];
System.arraycopy(gzipInputBuffer, 0, onDemandData.buffer, 0, i);

return onDemandData;
}

public int method562(int i, int k, int l)
{
int i1 = (l &lt;&lt; 8) + k;
for(int j1 = 0; j1 &lt; mapIndices1.length; j1++)
    if(mapIndices1[j1] == i1)
	if(i == 0)
	    return mapIndices2[j1];
	else
	    return mapIndices3[j1];
return -1;
}

public void method548(int i)
{
method558(0, i);
}

public void method563(byte byte0, int i, int j)
{
if(clientInstance.decompressors[0] == null)
    return;
//if(versions[i][j] == 0)
    //return;
clientInstance.decompressors[i + 1].decompress(j);
//if(crcMatches(versions[i][j], crcs[i][j], abyte0))
//    return;
//fileStatus[i][j] = byte0;
if(byte0 &gt; anInt1332)
    anInt1332 = byte0;
totalFiles++;
}

public boolean method564(int i)
{
for(int k = 0; k &lt; mapIndices1.length; k++)
    if(mapIndices3[k] == i)
	return true;
return false;
}

@SuppressWarnings("unused")
private void handleFailed()
{
uncompletedCount = 0;
completedCount = 0;
for(OnDemandData onDemandData = (OnDemandData) requested.reverseGetFirst(); onDemandData != null; onDemandData = (OnDemandData) requested.reverseGetNext())
    if(onDemandData.incomplete)
	uncompletedCount++;
    else
	completedCount++;

while(uncompletedCount &lt; 10)
{
    OnDemandData onDemandData_1 = (OnDemandData)aClass19_1368.popHead();
    if(onDemandData_1 == null)
	break;
    if(fileStatus[onDemandData_1.dataType][onDemandData_1.ID] != 0)
	filesLoaded++;
    fileStatus[onDemandData_1.dataType][onDemandData_1.ID] = 0;
    requested.insertHead(onDemandData_1);
    uncompletedCount++;
    closeRequest(onDemandData_1);
    waiting = true;
}
}

public void method566()
{
synchronized(aClass19_1344)
{
    aClass19_1344.removeAll();
}
}

private void checkReceived()
{
OnDemandData onDemandData;
synchronized(aClass19_1370)
{
    onDemandData = (OnDemandData)aClass19_1370.popHead();
}
while(onDemandData != null)
{
    waiting = true;
    byte abyte0[] = null;
    if(clientInstance.decompressors[0] != null)
	abyte0 = clientInstance.decompressors[onDemandData.dataType + 1].decompress(onDemandData.ID);
    //if(!crcMatches(versions[onDemandData.dataType][onDemandData.ID], crcs[onDemandData.dataType][onDemandData.ID], abyte0))
    //    abyte0 = null;
    synchronized(aClass19_1370)
    {
	if(abyte0 == null)
	{
	    aClass19_1368.insertHead(onDemandData);
	} else
	{
	    onDemandData.buffer = abyte0;
	    synchronized(aClass19_1358)
	    {
		aClass19_1358.insertHead(onDemandData);
	    }
	}
	onDemandData = (OnDemandData)aClass19_1370.popHead();
    }
}
}

private void method568()
{
while(uncompletedCount == 0 &amp;&amp; completedCount &lt; 10)
{
    if(anInt1332 == 0)
	break;
    OnDemandData onDemandData;
    synchronized(aClass19_1344)
    {
	onDemandData = (OnDemandData)aClass19_1344.popHead();
    }
    while(onDemandData != null)
    {
	if(fileStatus[onDemandData.dataType][onDemandData.ID] != 0)
	{
	    fileStatus[onDemandData.dataType][onDemandData.ID] = 0;
	    requested.insertHead(onDemandData);
	    closeRequest(onDemandData);
	    waiting = true;
	    if(filesLoaded &lt; totalFiles)
		filesLoaded++;
	    statusString = "Loading extra files - " + (filesLoaded * 100) / totalFiles + "%";
	    completedCount++;
	    if(completedCount == 10)
		return;
	}
	synchronized(aClass19_1344)
	{
	    onDemandData = (OnDemandData)aClass19_1344.popHead();
	}
    }
    for(int j = 0; j &lt; 4; j++)
    {
	byte abyte0[] = fileStatus[j];
	int k = abyte0.length;
	for(int l = 0; l &lt; k; l++)
	    if(abyte0[l] == anInt1332)
	    {
		abyte0[l] = 0;
		OnDemandData onDemandData_1 = new OnDemandData();
		onDemandData_1.dataType = j;
		onDemandData_1.ID = l;
		onDemandData_1.incomplete = false;
		requested.insertHead(onDemandData_1);
		closeRequest(onDemandData_1);
		waiting = true;
		if(filesLoaded &lt; totalFiles)
		    filesLoaded++;
		statusString = "Loading extra files - " + (filesLoaded * 100) / totalFiles + "%";
		completedCount++;
		if(completedCount == 10)
		    return;
	    }

    }

    anInt1332--;
}
}

public boolean method569(int i)
{
return anIntArray1348[i] == 1;
}

public OnDemandFetcher()
{
requested = new NodeList();
statusString = "";
new CRC32();
ioBuffer = new byte[500];
fileStatus = new byte[4][];
aClass19_1344 = new NodeList();
running = true;
waiting = false;
aClass19_1358 = new NodeList();
gzipInputBuffer = new byte[999999];
nodeSubList = new NodeSubList();
versions = new int[4][];
aClass19_1368 = new NodeList();
aClass19_1370 = new NodeList();
}

private int totalFiles;
private final NodeList requested;
private int anInt1332;
public String statusString;
private int writeLoopCycle;
private long openSocketTime;
private int[] mapIndices3;
private final byte[] ioBuffer;
public int onDemandCycle;
private final byte[][] fileStatus;
private Client clientInstance;
private final NodeList aClass19_1344;
private int completedSize;
private int expectedSize;
private int[] anIntArray1348;
public int anInt1349;
private int[] mapIndices2;
private int filesLoaded;
private boolean running;
private OutputStream outputStream;
private int[] mapIndices4;
private boolean waiting;
private final NodeList aClass19_1358;
private final byte[] gzipInputBuffer;
private final NodeSubList nodeSubList;
private InputStream inputStream;
private Socket socket;
private final int[][] versions;
private int uncompletedCount;
private int completedCount;
private final NodeList aClass19_1368;
private OnDemandData current;
private final NodeList aClass19_1370;
private int[] mapIndices1;
private int loopCycle;
</code></pre>
<p>}<br>
[/CODE]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631/1</link>
        <pubDate>Sat, 25 Jul 2015 12:15:27 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-552631-1</guid>
        <source url="https://forum.moparisthebest.com/t/buffer-overflow-when-running/552631.rss">Buffer Overflow when running</source>
      </item>
  </channel>
</rss>
