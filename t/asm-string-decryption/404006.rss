<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>ASM String Decryption</title>
    <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006</link>
    <description>I started screwing around with RS hacking again, and I noticed that Jagex added string encryption.  So, here&#39;s my way of decrypting it in ASM. 
http://paste.strictfp.com/7429

To use it, just loop through ClassNodes calling doDecryption on each one.

Oh, and the InstructionSearcher class is pretty easy to remake, but if anyone wants it.
http://paste.strictfp.com/7430

I had quite a bit of help from Evil[b]_[/b] and Tekk (understanding how the encryption was done) and Speed (helped me fix some things with finding the keys).  I also used one of super_&#39;s posts as a reference for part of this.</description>
    
    <lastBuildDate>Sun, 15 Jan 2012 19:43:41 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@SpeedIsMeh SpeedIsMeh]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedismeh">@SpeedIsMeh</a> wrote:</p>
          <blockquote>
              <p>[quote=“sinisoul, post:30, topic:404006”][quote author=<code>Discardedx2</code> link=topic=501062.msg3888417#msg3888417 date=1326655542]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>[code]package com.hijackrs.deober.opt.impl;</p>
<p>import java.util.Iterator;<br>
import java.util.List;<br>
import java.util.logging.Logger;</p>
<p>import org.objectweb.asm.Opcodes;<br>
import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.LdcInsnNode;<br>
import org.objectweb.asm.tree.MethodInsnNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>import com.hijackrs.deober.arch.impl.ClassArchive;<br>
import com.hijackrs.deober.opt.Optimizer;<br>
import com.hijackrs.deober.util.InsnMatcher;<br>
import com.hijackrs.deober.util.InsnNodeUtils;<br>
import com.hijackrs.deober.util.InstructionSearcher;<br>
import com.hijackrs.deober.util.StringUtils;</p>
<p>/**</p>
<ul>
<li>
<p>This fixes the “super_” string obfuscation technique</p>
</li>
<li>
<p>added by Jacmob. Heres a little interesting fact</p>
</li>
<li>
<p>for those of you that actually read my documentation!</p>
</li>
<li>
<p>super_ is a reference to the user “super_”, an active member</p>
</li>
<li>
<p>of many programming communities!</p>
</li>
<li>
</li>
<li>
<p>This applies three steps, in order for the standard string decryption to work.</p>
</li>
<li>
<p>First, the program decrypts part of the string with the “super_” key</p>
</li>
<li>
<p>next it removes the INVOKESTATIC instruction that references</p>
</li>
<li>
<p>the decryptSuper method, and finally the decryptSuper method itself</p>
</li>
<li>
<p>is removed from the class.</p>
</li>
<li>
<p><span class="mention">@author</span> `Discardedx2<br>
*/<br>
public class SuperStringOptimizer implements Optimizer {</p>
<p>/**</p>
<ul>
<li>The amount of inlined local variables.<br>
<em>/<br>
private int inlinedVars;<br>
/</em>*</li>
<li>The amount of inlined strings.<br>
<em>/<br>
private int inlinedStrings;<br>
/</em>*</li>
<li>The logger.<br>
<em>/<br>
private final Logger logger = Logger.getLogger(this.getClass().getName());<br>
/</em>*</li>
<li>The pattern used to find a stored encrypted string.<br>
<em>/<br>
private static final String SUPER_INVOKE_PATTERN = “AbstractInsnNode INVOKESTATIC INVOKESTATIC INVOKESTATIC AASTORE”;<br>
/</em>*</li>
<li>The local variable pattern.<br>
*/<br>
private static final int[] LOCAL_VAR_PATTERN = new int[] { Opcodes.LDC, Opcodes.SWAP, Opcodes.DUP_X1, Opcodes.POP, Opcodes.POP };</li>
</ul>
<p>@SuppressWarnings(“unchecked”)<br>
@Override<br>
public void optimize(ClassArchive archive) throws Exception {<br>
logger.info(“Removing ‘super’ string encryption…’”);<br>
outer: for (ClassNode cn : archive) {<br>
MethodNode clinit = null;<br>
LdcInsnNode superLdc = null;<br>
for (MethodNode mn : (List) cn.methods) {<br>
if (superLdc == null) {<br>
if (mn.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")) {<br>
for (Iterator itr = InsnNodeUtils.collect(mn, Opcodes.LDC); itr.hasNext()<img src="https://forum.moparisthebest.com/images/emoji/twitter/wink.png?v=5" title=":wink:" class="emoji" alt=":wink:"> {<br>
LdcInsnNode ldc = (LdcInsnNode) itr.next();<br>
superLdc = ldc;<br>
break;<br>
}<br>
}<br>
}<br>
if (mn.name.equals("")) { // check for the static block, if there is none there is no point<br>
// in attempting to decrypt this class…<br>
clinit = mn;<br>
}<br>
}</p>
<pre><code> 	if (clinit == null || superLdc == null) {
 		continue;
 	}

 	MethodNode[] decMethods = StringUtils.getDecryptionMethods(cn);

 	for (MethodNode dec : decMethods) {
 		if (dec == null) {// We are missing a decryption method.... thats very odd.
 			continue outer;
 		}
 	}

 	InstructionSearcher searcher = new InstructionSearcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = searcher.match(LOCAL_VAR_PATTERN); itr.hasNext();) { // This is probably only needed for RuneScape clients...
 		AbstractInsnNode[] match = itr.next();

 		for (int i = 0; i &lt; match.length; i++) {
 			clinit.instructions.remove(match[i]);
 		}
 		
 		inlinedVars++;
 	}

 	int[] keys = StringUtils.findKeys(decMethods);


 	InsnMatcher matcher = new InsnMatcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = matcher.match(SUPER_INVOKE_PATTERN); itr.hasNext();) {
 		AbstractInsnNode[] match = itr.next();
 		
 		MethodInsnNode superDec = (MethodInsnNode) match[1];
 		
 		AbstractInsnNode insn = match[0];
 		
 		LdcInsnNode ldc;
 		if (insn.getOpcode() == Opcodes.LDC) {
 			ldc = (LdcInsnNode) insn;
 		} else {
 			ldc = (LdcInsnNode) insn.getPrevious();
 		}
 		
 		cn.methods.remove(InsnNodeUtils.resolveMethodInsn(cn, superDec));
 		
 		clinit.instructions.set(ldc, new LdcInsnNode(decryptSuper(StringUtils.decryptStandard(keys, (String) ldc.cst), (String) superLdc.cst)));
 		clinit.instructions.remove(superDec);
 		
 		inlinedStrings++;
 	}
 }
</code></pre>
<p>}</p>
<p>@Override<br>
public void onCompletion() {<br>
logger.info(“Inlined “+inlinedStrings+” strings and “+inlinedVars+” local variables.”);<br>
}</p>
<p>/**</p>
<ul>
<li>Used to decipher the “super_ method” keys.</li>
<li>@param encrypted The encrypted string.</li>
<li>@param key The standard decrypted key.</li>
<li>@return<br>
*/<br>
private String decryptSuper(String encrypted, String key) {<br>
char[] ch = new char[encrypted.length() - 1];<br>
for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] = (char)(encrypted.charAt(pos) ^ (key.charAt(pos % key.length()) &amp; 0x3F));<br>
}<br>
return new String(ch);<br>
}</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>[code]package com.hijackrs.deober.util;</p>
<p>import java.util.Iterator;<br>
import java.util.List;</p>
<p>import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>/**</p>
<ul>
<li>
<p>A class filled with utilities used in the StringOptimizer classes.</p>
</li>
<li>
<p>@author `Discardedx2</p>
</li>
<li>
<p>@author Graham Edgecombe<br>
*/<br>
public class StringUtils {</p>
<p>/**</p>
<ul>
<li>The first decryption pattern used to find the first key.<br>
<em>/<br>
public static final String STR_TO_CHARS_PATTERN = “CALOAD (BIPUSH | SIPUSH | ICONST) IXOR I2C CASTORE”;<br>
/</em>*</li>
<li>The second decryption pattern used to find the second keys.<br>
<em>/<br>
public static final String CHARS_TO_STR_PATTERN = "CALOAD ILOAD ICONST IREM (TABLESWITCH | LOOKUPSWITCH) ((BIPUSH | SIPUSH | ICONST) GOTO?)</em> IXOR I2C CASTORE";</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Decrypts a string.</p>
</li>
<li>
<p>@param keys The keys.</p>
</li>
<li>
<p>@param str The encrypted string.</p>
</li>
<li>
<p>@return The decrypted string.<br>
*/<br>
public static String decryptStandard(int[] keys, String str) {<br>
char[] ch = str.toCharArray();<br>
if (ch.length &lt; 2)<br>
ch[0] ^= keys[0];</p>
<p>for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] ^= keys[pos % 5 + 1];<br>
}</p>
<p>return new String(ch).intern();<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Finds the key set.</p>
</li>
<li>
<p>@param m1 The string to characters method.</p>
</li>
<li>
<p>@param m2 The characters to string method.</p>
</li>
<li>
<p>@return The keys, or {@code null} if they could not be found.<br>
*/<br>
public static int[] findKeys(MethodNode[] decMethods) {<br>
int[] keys = new int[6];</p>
<p>InsnMatcher matcher = new InsnMatcher(decMethods[0].instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; it = matcher.match(STR_TO_CHARS_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>AbstractInsnNode[] match = it.next();<br>
keys[0] = (int) InsnNodeUtils.getNumericPushValue(match[1]);</p>
<p>matcher = new InsnMatcher(decMethods[1].instructions);<br>
it = matcher.match(CHARS_TO_STR_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>match = it.next();<br>
for (int i = 0; i &lt; 5; i++) {<br>
keys[i + 1] = (int) InsnNodeUtils.getNumericPushValue(match[5 + i * 2]);<br>
}</p>
<p>return keys;<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Gets the decryption methods.</p>
</li>
<li>
<p>@return The decryption methods.<br>
*/<br>
@SuppressWarnings(“unchecked”)<br>
public static MethodNode[] getDecryptionMethods(ClassNode cn) {<br>
MethodNode[] min = new MethodNode[2];</p>
<p>for (MethodNode mn : (List) cn.methods) {<br>
InsnMatcher matcher = new InsnMatcher(mn.instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; strings = matcher.match(STR_TO_CHARS_PATTERN);<br>
Iterator&lt;AbstractInsnNode[]&gt; chars = matcher.match(CHARS_TO_STR_PATTERN);</p>
<pre><code> if (strings.hasNext()) {
 	min[0] = mn;
 } else if (chars.hasNext()) {
 	min[1] = mn;
 }
</code></pre>
<p>}<br>
return min;<br>
}</p>
</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>That fixes the string encryption enough so that the old string decryption will still work. You guys can probably work out what some of the missing methods do by looking at other string decryption classes, I don’t have full permission to post the InsnNodeUtils class.</p>
</blockquote>
</aside>
<p>I’m sure this new encryption is just the same as the old one with the addition of:</p>
<pre><code class="lang-auto">	private static String decrypt_a(String string, String key) {
		char[] cs = new char[string.length()];
		for (int i = cs.length - 1; i &gt;= 0; i--) {
			int xor = key.charAt(i % key.length()) &amp; 0x3f;
			cs[i] = (char) (string.charAt(i) ^ xor);
		}
		return new String(cs);

	}</code></pre>
<p>so it’s not much different from the other one at all <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
</blockquote>
</aside>
<p>There is not much of a difference at all, no. By the way Dx2 we already have examples of code that already work so why are you posting new ones…?</p>
</blockquote>
</aside>
<p>because your code sucked<br>
[/quote]</p>
<aside class="quote">
<blockquote>
<p><a href="http://pastie.org/3186587" rel="nofollow noopener">http://pastie.org/3186587</a></p>
<p>There’s my shitty hard coded one, if anyone just needed a reference.</p>
</blockquote>
</aside>
<p>no shit[/quote]<br>
then why the fuck question him when he posts a better one?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/31">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/31</link>
        <pubDate>Sun, 15 Jan 2012 19:43:41 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-31</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p>[quote="<code>Discardedx2</code>, post:28, topic:404006"][quote author=sinisoul link=topic=501062.msg3888407#msg3888407 date=1326654797]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>[code]package com.hijackrs.deober.opt.impl;</p>
<p>import java.util.Iterator;<br>
import java.util.List;<br>
import java.util.logging.Logger;</p>
<p>import org.objectweb.asm.Opcodes;<br>
import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.LdcInsnNode;<br>
import org.objectweb.asm.tree.MethodInsnNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>import com.hijackrs.deober.arch.impl.ClassArchive;<br>
import com.hijackrs.deober.opt.Optimizer;<br>
import com.hijackrs.deober.util.InsnMatcher;<br>
import com.hijackrs.deober.util.InsnNodeUtils;<br>
import com.hijackrs.deober.util.InstructionSearcher;<br>
import com.hijackrs.deober.util.StringUtils;</p>
<p>/**</p>
<ul>
<li>
<p>This fixes the “super_” string obfuscation technique</p>
</li>
<li>
<p>added by Jacmob. Heres a little interesting fact</p>
</li>
<li>
<p>for those of you that actually read my documentation!</p>
</li>
<li>
<p>super_ is a reference to the user “super_”, an active member</p>
</li>
<li>
<p>of many programming communities!</p>
</li>
<li>
</li>
<li>
<p>This applies three steps, in order for the standard string decryption to work.</p>
</li>
<li>
<p>First, the program decrypts part of the string with the “super_” key</p>
</li>
<li>
<p>next it removes the INVOKESTATIC instruction that references</p>
</li>
<li>
<p>the decryptSuper method, and finally the decryptSuper method itself</p>
</li>
<li>
<p>is removed from the class.</p>
</li>
<li>
<p><span class="mention">@author</span> `Discardedx2<br>
*/<br>
public class SuperStringOptimizer implements Optimizer {</p>
<p>/**</p>
<ul>
<li>The amount of inlined local variables.<br>
<em>/<br>
private int inlinedVars;<br>
/</em>*</li>
<li>The amount of inlined strings.<br>
<em>/<br>
private int inlinedStrings;<br>
/</em>*</li>
<li>The logger.<br>
<em>/<br>
private final Logger logger = Logger.getLogger(this.getClass().getName());<br>
/</em>*</li>
<li>The pattern used to find a stored encrypted string.<br>
<em>/<br>
private static final String SUPER_INVOKE_PATTERN = “AbstractInsnNode INVOKESTATIC INVOKESTATIC INVOKESTATIC AASTORE”;<br>
/</em>*</li>
<li>The local variable pattern.<br>
*/<br>
private static final int[] LOCAL_VAR_PATTERN = new int[] { Opcodes.LDC, Opcodes.SWAP, Opcodes.DUP_X1, Opcodes.POP, Opcodes.POP };</li>
</ul>
<p>@SuppressWarnings(“unchecked”)<br>
@Override<br>
public void optimize(ClassArchive archive) throws Exception {<br>
logger.info(“Removing ‘super’ string encryption…’”);<br>
outer: for (ClassNode cn : archive) {<br>
MethodNode clinit = null;<br>
LdcInsnNode superLdc = null;<br>
for (MethodNode mn : (List) cn.methods) {<br>
if (superLdc == null) {<br>
if (mn.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")) {<br>
for (Iterator itr = InsnNodeUtils.collect(mn, Opcodes.LDC); itr.hasNext()<img src="https://forum.moparisthebest.com/images/emoji/twitter/wink.png?v=5" title=":wink:" class="emoji" alt=":wink:"> {<br>
LdcInsnNode ldc = (LdcInsnNode) itr.next();<br>
superLdc = ldc;<br>
break;<br>
}<br>
}<br>
}<br>
if (mn.name.equals("")) { // check for the static block, if there is none there is no point<br>
// in attempting to decrypt this class…<br>
clinit = mn;<br>
}<br>
}</p>
<pre><code> 	if (clinit == null || superLdc == null) {
 		continue;
 	}

 	MethodNode[] decMethods = StringUtils.getDecryptionMethods(cn);

 	for (MethodNode dec : decMethods) {
 		if (dec == null) {// We are missing a decryption method.... thats very odd.
 			continue outer;
 		}
 	}

 	InstructionSearcher searcher = new InstructionSearcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = searcher.match(LOCAL_VAR_PATTERN); itr.hasNext();) { // This is probably only needed for RuneScape clients...
 		AbstractInsnNode[] match = itr.next();

 		for (int i = 0; i &lt; match.length; i++) {
 			clinit.instructions.remove(match[i]);
 		}
 		
 		inlinedVars++;
 	}

 	int[] keys = StringUtils.findKeys(decMethods);


 	InsnMatcher matcher = new InsnMatcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = matcher.match(SUPER_INVOKE_PATTERN); itr.hasNext();) {
 		AbstractInsnNode[] match = itr.next();
 		
 		MethodInsnNode superDec = (MethodInsnNode) match[1];
 		
 		AbstractInsnNode insn = match[0];
 		
 		LdcInsnNode ldc;
 		if (insn.getOpcode() == Opcodes.LDC) {
 			ldc = (LdcInsnNode) insn;
 		} else {
 			ldc = (LdcInsnNode) insn.getPrevious();
 		}
 		
 		cn.methods.remove(InsnNodeUtils.resolveMethodInsn(cn, superDec));
 		
 		clinit.instructions.set(ldc, new LdcInsnNode(decryptSuper(StringUtils.decryptStandard(keys, (String) ldc.cst), (String) superLdc.cst)));
 		clinit.instructions.remove(superDec);
 		
 		inlinedStrings++;
 	}
 }
</code></pre>
<p>}</p>
<p>@Override<br>
public void onCompletion() {<br>
logger.info(“Inlined “+inlinedStrings+” strings and “+inlinedVars+” local variables.”);<br>
}</p>
<p>/**</p>
<ul>
<li>Used to decipher the “super_ method” keys.</li>
<li>@param encrypted The encrypted string.</li>
<li>@param key The standard decrypted key.</li>
<li>@return<br>
*/<br>
private String decryptSuper(String encrypted, String key) {<br>
char[] ch = new char[encrypted.length() - 1];<br>
for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] = (char)(encrypted.charAt(pos) ^ (key.charAt(pos % key.length()) &amp; 0x3F));<br>
}<br>
return new String(ch);<br>
}</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>[code]package com.hijackrs.deober.util;</p>
<p>import java.util.Iterator;<br>
import java.util.List;</p>
<p>import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>/**</p>
<ul>
<li>
<p>A class filled with utilities used in the StringOptimizer classes.</p>
</li>
<li>
<p>@author `Discardedx2</p>
</li>
<li>
<p>@author Graham Edgecombe<br>
*/<br>
public class StringUtils {</p>
<p>/**</p>
<ul>
<li>The first decryption pattern used to find the first key.<br>
<em>/<br>
public static final String STR_TO_CHARS_PATTERN = “CALOAD (BIPUSH | SIPUSH | ICONST) IXOR I2C CASTORE”;<br>
/</em>*</li>
<li>The second decryption pattern used to find the second keys.<br>
<em>/<br>
public static final String CHARS_TO_STR_PATTERN = "CALOAD ILOAD ICONST IREM (TABLESWITCH | LOOKUPSWITCH) ((BIPUSH | SIPUSH | ICONST) GOTO?)</em> IXOR I2C CASTORE";</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Decrypts a string.</p>
</li>
<li>
<p>@param keys The keys.</p>
</li>
<li>
<p>@param str The encrypted string.</p>
</li>
<li>
<p>@return The decrypted string.<br>
*/<br>
public static String decryptStandard(int[] keys, String str) {<br>
char[] ch = str.toCharArray();<br>
if (ch.length &lt; 2)<br>
ch[0] ^= keys[0];</p>
<p>for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] ^= keys[pos % 5 + 1];<br>
}</p>
<p>return new String(ch).intern();<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Finds the key set.</p>
</li>
<li>
<p>@param m1 The string to characters method.</p>
</li>
<li>
<p>@param m2 The characters to string method.</p>
</li>
<li>
<p>@return The keys, or {@code null} if they could not be found.<br>
*/<br>
public static int[] findKeys(MethodNode[] decMethods) {<br>
int[] keys = new int[6];</p>
<p>InsnMatcher matcher = new InsnMatcher(decMethods[0].instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; it = matcher.match(STR_TO_CHARS_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>AbstractInsnNode[] match = it.next();<br>
keys[0] = (int) InsnNodeUtils.getNumericPushValue(match[1]);</p>
<p>matcher = new InsnMatcher(decMethods[1].instructions);<br>
it = matcher.match(CHARS_TO_STR_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>match = it.next();<br>
for (int i = 0; i &lt; 5; i++) {<br>
keys[i + 1] = (int) InsnNodeUtils.getNumericPushValue(match[5 + i * 2]);<br>
}</p>
<p>return keys;<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Gets the decryption methods.</p>
</li>
<li>
<p>@return The decryption methods.<br>
*/<br>
@SuppressWarnings(“unchecked”)<br>
public static MethodNode[] getDecryptionMethods(ClassNode cn) {<br>
MethodNode[] min = new MethodNode[2];</p>
<p>for (MethodNode mn : (List) cn.methods) {<br>
InsnMatcher matcher = new InsnMatcher(mn.instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; strings = matcher.match(STR_TO_CHARS_PATTERN);<br>
Iterator&lt;AbstractInsnNode[]&gt; chars = matcher.match(CHARS_TO_STR_PATTERN);</p>
<pre><code> if (strings.hasNext()) {
 	min[0] = mn;
 } else if (chars.hasNext()) {
 	min[1] = mn;
 }
</code></pre>
<p>}<br>
return min;<br>
}</p>
</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>That fixes the string encryption enough so that the old string decryption will still work. You guys can probably work out what some of the missing methods do by looking at other string decryption classes, I don’t have full permission to post the InsnNodeUtils class.</p>
</blockquote>
</aside>
<p>I’m sure this new encryption is just the same as the old one with the addition of:</p>
<pre><code class="lang-auto">	private static String decrypt_a(String string, String key) {
		char[] cs = new char[string.length()];
		for (int i = cs.length - 1; i &gt;= 0; i--) {
			int xor = key.charAt(i % key.length()) &amp; 0x3f;
			cs[i] = (char) (string.charAt(i) ^ xor);
		}
		return new String(cs);

	}</code></pre>
<p>so it’s not much different from the other one at all <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
</blockquote>
</aside>
<p>There is not much of a difference at all, no. By the way Dx2 we already have examples of code that already work so why are you posting new ones…?<br>
[/quote]</p>
<p>because your code sucked[/quote]</p>
<blockquote>http://pastie.org/3186587
<p>There’s my shitty hard coded one, if anyone just needed a reference.</p>
</blockquote>
<p>no shit</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/30">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/30</link>
        <pubDate>Sun, 15 Jan 2012 19:39:05 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-30</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@SpeedIsMeh SpeedIsMeh]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedismeh">@SpeedIsMeh</a> wrote:</p>
          <blockquote>
              <p><a href="http://pastie.org/private/kiothawpjyhi5o0o9tb3a" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/private/kiothawpjyhi5o0o9tb3a</a></p>
<p>Standalone version of my decrypter, just remove the superclassing and change the super(cg) to this.cg = cg; and add a cg field, then it should work standalone.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/29">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/29</link>
        <pubDate>Sun, 15 Jan 2012 19:31:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-29</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@_Discardedx21 `Discardedx2`]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_discardedx21">@_Discardedx21</a> wrote:</p>
          <blockquote>
              <p>[quote=“sinisoul, post:27, topic:404006”][quote author=SpeedIsMeh link=topic=501062.msg3888232#msg3888232 date=1326645648]</p>
<aside class="quote">
<blockquote>
<p>[code]package com.hijackrs.deober.opt.impl;</p>
<p>import java.util.Iterator;<br>
import java.util.List;<br>
import java.util.logging.Logger;</p>
<p>import org.objectweb.asm.Opcodes;<br>
import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.LdcInsnNode;<br>
import org.objectweb.asm.tree.MethodInsnNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>import com.hijackrs.deober.arch.impl.ClassArchive;<br>
import com.hijackrs.deober.opt.Optimizer;<br>
import com.hijackrs.deober.util.InsnMatcher;<br>
import com.hijackrs.deober.util.InsnNodeUtils;<br>
import com.hijackrs.deober.util.InstructionSearcher;<br>
import com.hijackrs.deober.util.StringUtils;</p>
<p>/**</p>
<ul>
<li>
<p>This fixes the “super_” string obfuscation technique</p>
</li>
<li>
<p>added by Jacmob. Heres a little interesting fact</p>
</li>
<li>
<p>for those of you that actually read my documentation!</p>
</li>
<li>
<p>super_ is a reference to the user “super_”, an active member</p>
</li>
<li>
<p>of many programming communities!</p>
</li>
<li>
</li>
<li>
<p>This applies three steps, in order for the standard string decryption to work.</p>
</li>
<li>
<p>First, the program decrypts part of the string with the “super_” key</p>
</li>
<li>
<p>next it removes the INVOKESTATIC instruction that references</p>
</li>
<li>
<p>the decryptSuper method, and finally the decryptSuper method itself</p>
</li>
<li>
<p>is removed from the class.</p>
</li>
<li>
<p><span class="mention">@author</span> `Discardedx2<br>
*/<br>
public class SuperStringOptimizer implements Optimizer {</p>
<p>/**</p>
<ul>
<li>The amount of inlined local variables.<br>
<em>/<br>
private int inlinedVars;<br>
/</em>*</li>
<li>The amount of inlined strings.<br>
<em>/<br>
private int inlinedStrings;<br>
/</em>*</li>
<li>The logger.<br>
<em>/<br>
private final Logger logger = Logger.getLogger(this.getClass().getName());<br>
/</em>*</li>
<li>The pattern used to find a stored encrypted string.<br>
<em>/<br>
private static final String SUPER_INVOKE_PATTERN = “AbstractInsnNode INVOKESTATIC INVOKESTATIC INVOKESTATIC AASTORE”;<br>
/</em>*</li>
<li>The local variable pattern.<br>
*/<br>
private static final int[] LOCAL_VAR_PATTERN = new int[] { Opcodes.LDC, Opcodes.SWAP, Opcodes.DUP_X1, Opcodes.POP, Opcodes.POP };</li>
</ul>
<p>@SuppressWarnings(“unchecked”)<br>
@Override<br>
public void optimize(ClassArchive archive) throws Exception {<br>
logger.info(“Removing ‘super’ string encryption…’”);<br>
outer: for (ClassNode cn : archive) {<br>
MethodNode clinit = null;<br>
LdcInsnNode superLdc = null;<br>
for (MethodNode mn : (List) cn.methods) {<br>
if (superLdc == null) {<br>
if (mn.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")) {<br>
for (Iterator itr = InsnNodeUtils.collect(mn, Opcodes.LDC); itr.hasNext()<img src="https://forum.moparisthebest.com/images/emoji/twitter/wink.png?v=5" title=":wink:" class="emoji" alt=":wink:"> {<br>
LdcInsnNode ldc = (LdcInsnNode) itr.next();<br>
superLdc = ldc;<br>
break;<br>
}<br>
}<br>
}<br>
if (mn.name.equals("")) { // check for the static block, if there is none there is no point<br>
// in attempting to decrypt this class…<br>
clinit = mn;<br>
}<br>
}</p>
<pre><code> 	if (clinit == null || superLdc == null) {
 		continue;
 	}

 	MethodNode[] decMethods = StringUtils.getDecryptionMethods(cn);

 	for (MethodNode dec : decMethods) {
 		if (dec == null) {// We are missing a decryption method.... thats very odd.
 			continue outer;
 		}
 	}

 	InstructionSearcher searcher = new InstructionSearcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = searcher.match(LOCAL_VAR_PATTERN); itr.hasNext();) { // This is probably only needed for RuneScape clients...
 		AbstractInsnNode[] match = itr.next();

 		for (int i = 0; i &lt; match.length; i++) {
 			clinit.instructions.remove(match[i]);
 		}
 		
 		inlinedVars++;
 	}

 	int[] keys = StringUtils.findKeys(decMethods);


 	InsnMatcher matcher = new InsnMatcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = matcher.match(SUPER_INVOKE_PATTERN); itr.hasNext();) {
 		AbstractInsnNode[] match = itr.next();
 		
 		MethodInsnNode superDec = (MethodInsnNode) match[1];
 		
 		AbstractInsnNode insn = match[0];
 		
 		LdcInsnNode ldc;
 		if (insn.getOpcode() == Opcodes.LDC) {
 			ldc = (LdcInsnNode) insn;
 		} else {
 			ldc = (LdcInsnNode) insn.getPrevious();
 		}
 		
 		cn.methods.remove(InsnNodeUtils.resolveMethodInsn(cn, superDec));
 		
 		clinit.instructions.set(ldc, new LdcInsnNode(decryptSuper(StringUtils.decryptStandard(keys, (String) ldc.cst), (String) superLdc.cst)));
 		clinit.instructions.remove(superDec);
 		
 		inlinedStrings++;
 	}
 }
</code></pre>
<p>}</p>
<p>@Override<br>
public void onCompletion() {<br>
logger.info(“Inlined “+inlinedStrings+” strings and “+inlinedVars+” local variables.”);<br>
}</p>
<p>/**</p>
<ul>
<li>Used to decipher the “super_ method” keys.</li>
<li>@param encrypted The encrypted string.</li>
<li>@param key The standard decrypted key.</li>
<li>@return<br>
*/<br>
private String decryptSuper(String encrypted, String key) {<br>
char[] ch = new char[encrypted.length() - 1];<br>
for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] = (char)(encrypted.charAt(pos) ^ (key.charAt(pos % key.length()) &amp; 0x3F));<br>
}<br>
return new String(ch);<br>
}</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>[code]package com.hijackrs.deober.util;</p>
<p>import java.util.Iterator;<br>
import java.util.List;</p>
<p>import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>/**</p>
<ul>
<li>
<p>A class filled with utilities used in the StringOptimizer classes.</p>
</li>
<li>
<p>@author `Discardedx2</p>
</li>
<li>
<p>@author Graham Edgecombe<br>
*/<br>
public class StringUtils {</p>
<p>/**</p>
<ul>
<li>The first decryption pattern used to find the first key.<br>
<em>/<br>
public static final String STR_TO_CHARS_PATTERN = “CALOAD (BIPUSH | SIPUSH | ICONST) IXOR I2C CASTORE”;<br>
/</em>*</li>
<li>The second decryption pattern used to find the second keys.<br>
<em>/<br>
public static final String CHARS_TO_STR_PATTERN = "CALOAD ILOAD ICONST IREM (TABLESWITCH | LOOKUPSWITCH) ((BIPUSH | SIPUSH | ICONST) GOTO?)</em> IXOR I2C CASTORE";</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Decrypts a string.</p>
</li>
<li>
<p>@param keys The keys.</p>
</li>
<li>
<p>@param str The encrypted string.</p>
</li>
<li>
<p>@return The decrypted string.<br>
*/<br>
public static String decryptStandard(int[] keys, String str) {<br>
char[] ch = str.toCharArray();<br>
if (ch.length &lt; 2)<br>
ch[0] ^= keys[0];</p>
<p>for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] ^= keys[pos % 5 + 1];<br>
}</p>
<p>return new String(ch).intern();<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Finds the key set.</p>
</li>
<li>
<p>@param m1 The string to characters method.</p>
</li>
<li>
<p>@param m2 The characters to string method.</p>
</li>
<li>
<p>@return The keys, or {@code null} if they could not be found.<br>
*/<br>
public static int[] findKeys(MethodNode[] decMethods) {<br>
int[] keys = new int[6];</p>
<p>InsnMatcher matcher = new InsnMatcher(decMethods[0].instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; it = matcher.match(STR_TO_CHARS_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>AbstractInsnNode[] match = it.next();<br>
keys[0] = (int) InsnNodeUtils.getNumericPushValue(match[1]);</p>
<p>matcher = new InsnMatcher(decMethods[1].instructions);<br>
it = matcher.match(CHARS_TO_STR_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>match = it.next();<br>
for (int i = 0; i &lt; 5; i++) {<br>
keys[i + 1] = (int) InsnNodeUtils.getNumericPushValue(match[5 + i * 2]);<br>
}</p>
<p>return keys;<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Gets the decryption methods.</p>
</li>
<li>
<p>@return The decryption methods.<br>
*/<br>
@SuppressWarnings(“unchecked”)<br>
public static MethodNode[] getDecryptionMethods(ClassNode cn) {<br>
MethodNode[] min = new MethodNode[2];</p>
<p>for (MethodNode mn : (List) cn.methods) {<br>
InsnMatcher matcher = new InsnMatcher(mn.instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; strings = matcher.match(STR_TO_CHARS_PATTERN);<br>
Iterator&lt;AbstractInsnNode[]&gt; chars = matcher.match(CHARS_TO_STR_PATTERN);</p>
<pre><code> if (strings.hasNext()) {
 	min[0] = mn;
 } else if (chars.hasNext()) {
 	min[1] = mn;
 }
</code></pre>
<p>}<br>
return min;<br>
}</p>
</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>That fixes the string encryption enough so that the old string decryption will still work. You guys can probably work out what some of the missing methods do by looking at other string decryption classes, I don’t have full permission to post the InsnNodeUtils class.</p>
</blockquote>
</aside>
<p>I’m sure this new encryption is just the same as the old one with the addition of:</p>
<pre><code class="lang-auto">	private static String decrypt_a(String string, String key) {
		char[] cs = new char[string.length()];
		for (int i = cs.length - 1; i &gt;= 0; i--) {
			int xor = key.charAt(i % key.length()) &amp; 0x3f;
			cs[i] = (char) (string.charAt(i) ^ xor);
		}
		return new String(cs);

	}</code></pre>
<p>so it’s not much different from the other one at all <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"><br>
[/quote]</p>
<p>There is not much of a difference at all, no. By the way Dx2 we already have examples of code that already work so why are you posting new ones…?[/quote]</p>
<p>because your code sucked</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/28">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/28</link>
        <pubDate>Sun, 15 Jan 2012 19:25:42 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-28</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p>[quote=“SpeedIsMeh, post:26, topic:404006”][quote author=<code>Discardedx2</code> link=topic=501062.msg3887786#msg3887786 date=1326595816]</p>
<p>[code]package com.hijackrs.deober.opt.impl;</p>
<p>import java.util.Iterator;<br>
import java.util.List;<br>
import java.util.logging.Logger;</p>
<p>import org.objectweb.asm.Opcodes;<br>
import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.LdcInsnNode;<br>
import org.objectweb.asm.tree.MethodInsnNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>import com.hijackrs.deober.arch.impl.ClassArchive;<br>
import com.hijackrs.deober.opt.Optimizer;<br>
import com.hijackrs.deober.util.InsnMatcher;<br>
import com.hijackrs.deober.util.InsnNodeUtils;<br>
import com.hijackrs.deober.util.InstructionSearcher;<br>
import com.hijackrs.deober.util.StringUtils;</p>
<p>/**</p>
<ul>
<li>
<p>This fixes the “super_” string obfuscation technique</p>
</li>
<li>
<p>added by Jacmob. Heres a little interesting fact</p>
</li>
<li>
<p>for those of you that actually read my documentation!</p>
</li>
<li>
<p>super_ is a reference to the user “super_”, an active member</p>
</li>
<li>
<p>of many programming communities!</p>
</li>
<li>
</li>
<li>
<p>This applies three steps, in order for the standard string decryption to work.</p>
</li>
<li>
<p>First, the program decrypts part of the string with the “super_” key</p>
</li>
<li>
<p>next it removes the INVOKESTATIC instruction that references</p>
</li>
<li>
<p>the decryptSuper method, and finally the decryptSuper method itself</p>
</li>
<li>
<p>is removed from the class.</p>
</li>
<li>
<p><span class="mention">@author</span> `Discardedx2<br>
*/<br>
public class SuperStringOptimizer implements Optimizer {</p>
<p>/**</p>
<ul>
<li>The amount of inlined local variables.<br>
<em>/<br>
private int inlinedVars;<br>
/</em>*</li>
<li>The amount of inlined strings.<br>
<em>/<br>
private int inlinedStrings;<br>
/</em>*</li>
<li>The logger.<br>
<em>/<br>
private final Logger logger = Logger.getLogger(this.getClass().getName());<br>
/</em>*</li>
<li>The pattern used to find a stored encrypted string.<br>
<em>/<br>
private static final String SUPER_INVOKE_PATTERN = “AbstractInsnNode INVOKESTATIC INVOKESTATIC INVOKESTATIC AASTORE”;<br>
/</em>*</li>
<li>The local variable pattern.<br>
*/<br>
private static final int[] LOCAL_VAR_PATTERN = new int[] { Opcodes.LDC, Opcodes.SWAP, Opcodes.DUP_X1, Opcodes.POP, Opcodes.POP };</li>
</ul>
<p>@SuppressWarnings(“unchecked”)<br>
@Override<br>
public void optimize(ClassArchive archive) throws Exception {<br>
logger.info(“Removing ‘super’ string encryption…’”);<br>
outer: for (ClassNode cn : archive) {<br>
MethodNode clinit = null;<br>
LdcInsnNode superLdc = null;<br>
for (MethodNode mn : (List) cn.methods) {<br>
if (superLdc == null) {<br>
if (mn.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")) {<br>
for (Iterator itr = InsnNodeUtils.collect(mn, Opcodes.LDC); itr.hasNext()<img src="https://forum.moparisthebest.com/images/emoji/twitter/wink.png?v=5" title=":wink:" class="emoji" alt=":wink:"> {<br>
LdcInsnNode ldc = (LdcInsnNode) itr.next();<br>
superLdc = ldc;<br>
break;<br>
}<br>
}<br>
}<br>
if (mn.name.equals("")) { // check for the static block, if there is none there is no point<br>
// in attempting to decrypt this class…<br>
clinit = mn;<br>
}<br>
}</p>
<pre><code> 	if (clinit == null || superLdc == null) {
 		continue;
 	}

 	MethodNode[] decMethods = StringUtils.getDecryptionMethods(cn);

 	for (MethodNode dec : decMethods) {
 		if (dec == null) {// We are missing a decryption method.... thats very odd.
 			continue outer;
 		}
 	}

 	InstructionSearcher searcher = new InstructionSearcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = searcher.match(LOCAL_VAR_PATTERN); itr.hasNext();) { // This is probably only needed for RuneScape clients...
 		AbstractInsnNode[] match = itr.next();

 		for (int i = 0; i &lt; match.length; i++) {
 			clinit.instructions.remove(match[i]);
 		}
 		
 		inlinedVars++;
 	}

 	int[] keys = StringUtils.findKeys(decMethods);


 	InsnMatcher matcher = new InsnMatcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = matcher.match(SUPER_INVOKE_PATTERN); itr.hasNext();) {
 		AbstractInsnNode[] match = itr.next();
 		
 		MethodInsnNode superDec = (MethodInsnNode) match[1];
 		
 		AbstractInsnNode insn = match[0];
 		
 		LdcInsnNode ldc;
 		if (insn.getOpcode() == Opcodes.LDC) {
 			ldc = (LdcInsnNode) insn;
 		} else {
 			ldc = (LdcInsnNode) insn.getPrevious();
 		}
 		
 		cn.methods.remove(InsnNodeUtils.resolveMethodInsn(cn, superDec));
 		
 		clinit.instructions.set(ldc, new LdcInsnNode(decryptSuper(StringUtils.decryptStandard(keys, (String) ldc.cst), (String) superLdc.cst)));
 		clinit.instructions.remove(superDec);
 		
 		inlinedStrings++;
 	}
 }
</code></pre>
<p>}</p>
<p>@Override<br>
public void onCompletion() {<br>
logger.info(“Inlined “+inlinedStrings+” strings and “+inlinedVars+” local variables.”);<br>
}</p>
<p>/**</p>
<ul>
<li>Used to decipher the “super_ method” keys.</li>
<li>@param encrypted The encrypted string.</li>
<li>@param key The standard decrypted key.</li>
<li>@return<br>
*/<br>
private String decryptSuper(String encrypted, String key) {<br>
char[] ch = new char[encrypted.length() - 1];<br>
for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] = (char)(encrypted.charAt(pos) ^ (key.charAt(pos % key.length()) &amp; 0x3F));<br>
}<br>
return new String(ch);<br>
}</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>[code]package com.hijackrs.deober.util;</p>
<p>import java.util.Iterator;<br>
import java.util.List;</p>
<p>import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>/**</p>
<ul>
<li>
<p>A class filled with utilities used in the StringOptimizer classes.</p>
</li>
<li>
<p>@author `Discardedx2</p>
</li>
<li>
<p>@author Graham Edgecombe<br>
*/<br>
public class StringUtils {</p>
<p>/**</p>
<ul>
<li>The first decryption pattern used to find the first key.<br>
<em>/<br>
public static final String STR_TO_CHARS_PATTERN = “CALOAD (BIPUSH | SIPUSH | ICONST) IXOR I2C CASTORE”;<br>
/</em>*</li>
<li>The second decryption pattern used to find the second keys.<br>
<em>/<br>
public static final String CHARS_TO_STR_PATTERN = "CALOAD ILOAD ICONST IREM (TABLESWITCH | LOOKUPSWITCH) ((BIPUSH | SIPUSH | ICONST) GOTO?)</em> IXOR I2C CASTORE";</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Decrypts a string.</p>
</li>
<li>
<p>@param keys The keys.</p>
</li>
<li>
<p>@param str The encrypted string.</p>
</li>
<li>
<p>@return The decrypted string.<br>
*/<br>
public static String decryptStandard(int[] keys, String str) {<br>
char[] ch = str.toCharArray();<br>
if (ch.length &lt; 2)<br>
ch[0] ^= keys[0];</p>
<p>for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] ^= keys[pos % 5 + 1];<br>
}</p>
<p>return new String(ch).intern();<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Finds the key set.</p>
</li>
<li>
<p>@param m1 The string to characters method.</p>
</li>
<li>
<p>@param m2 The characters to string method.</p>
</li>
<li>
<p>@return The keys, or {@code null} if they could not be found.<br>
*/<br>
public static int[] findKeys(MethodNode[] decMethods) {<br>
int[] keys = new int[6];</p>
<p>InsnMatcher matcher = new InsnMatcher(decMethods[0].instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; it = matcher.match(STR_TO_CHARS_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>AbstractInsnNode[] match = it.next();<br>
keys[0] = (int) InsnNodeUtils.getNumericPushValue(match[1]);</p>
<p>matcher = new InsnMatcher(decMethods[1].instructions);<br>
it = matcher.match(CHARS_TO_STR_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>match = it.next();<br>
for (int i = 0; i &lt; 5; i++) {<br>
keys[i + 1] = (int) InsnNodeUtils.getNumericPushValue(match[5 + i * 2]);<br>
}</p>
<p>return keys;<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Gets the decryption methods.</p>
</li>
<li>
<p>@return The decryption methods.<br>
*/<br>
@SuppressWarnings(“unchecked”)<br>
public static MethodNode[] getDecryptionMethods(ClassNode cn) {<br>
MethodNode[] min = new MethodNode[2];</p>
<p>for (MethodNode mn : (List) cn.methods) {<br>
InsnMatcher matcher = new InsnMatcher(mn.instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; strings = matcher.match(STR_TO_CHARS_PATTERN);<br>
Iterator&lt;AbstractInsnNode[]&gt; chars = matcher.match(CHARS_TO_STR_PATTERN);</p>
<pre><code> if (strings.hasNext()) {
 	min[0] = mn;
 } else if (chars.hasNext()) {
 	min[1] = mn;
 }
</code></pre>
<p>}<br>
return min;<br>
}</p>
</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>That fixes the string encryption enough so that the old string decryption will still work. You guys can probably work out what some of the missing methods do by looking at other string decryption classes, I don’t have full permission to post the InsnNodeUtils class.<br>
[/quote]</p>
<p>I’m sure this new encryption is just the same as the old one with the addition of:</p>
<pre><code class="lang-auto">	private static String decrypt_a(String string, String key) {
		char[] cs = new char[string.length()];
		for (int i = cs.length - 1; i &gt;= 0; i--) {
			int xor = key.charAt(i % key.length()) &amp; 0x3f;
			cs[i] = (char) (string.charAt(i) ^ xor);
		}
		return new String(cs);

	}</code></pre>
<p>so it’s not much different from the other one at all :P[/quote]</p>
<p>There is not much of a difference at all, no. By the way Dx2 we already have examples of code that already work so why are you posting new ones…?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/27">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/27</link>
        <pubDate>Sun, 15 Jan 2012 19:13:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-27</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@SpeedIsMeh SpeedIsMeh]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedismeh">@SpeedIsMeh</a> wrote:</p>
          <blockquote>
              <p>[quote="<code>Discardedx2</code>, post:25, topic:404006"][code]package com.hijackrs.deober.opt.impl;</p>
<p>import java.util.Iterator;<br>
import java.util.List;<br>
import java.util.logging.Logger;</p>
<p>import org.objectweb.asm.Opcodes;<br>
import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.LdcInsnNode;<br>
import org.objectweb.asm.tree.MethodInsnNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>import com.hijackrs.deober.arch.impl.ClassArchive;<br>
import com.hijackrs.deober.opt.Optimizer;<br>
import com.hijackrs.deober.util.InsnMatcher;<br>
import com.hijackrs.deober.util.InsnNodeUtils;<br>
import com.hijackrs.deober.util.InstructionSearcher;<br>
import com.hijackrs.deober.util.StringUtils;</p>
<p>/**</p>
<ul>
<li>
<p>This fixes the “super_” string obfuscation technique</p>
</li>
<li>
<p>added by Jacmob. Heres a little interesting fact</p>
</li>
<li>
<p>for those of you that actually read my documentation!</p>
</li>
<li>
<p>super_ is a reference to the user “super_”, an active member</p>
</li>
<li>
<p>of many programming communities!</p>
</li>
<li>
</li>
<li>
<p>This applies three steps, in order for the standard string decryption to work.</p>
</li>
<li>
<p>First, the program decrypts part of the string with the “super_” key</p>
</li>
<li>
<p>next it removes the INVOKESTATIC instruction that references</p>
</li>
<li>
<p>the decryptSuper method, and finally the decryptSuper method itself</p>
</li>
<li>
<p>is removed from the class.</p>
</li>
<li>
<p><span class="mention">@author</span> `Discardedx2<br>
*/<br>
public class SuperStringOptimizer implements Optimizer {</p>
<p>/**</p>
<ul>
<li>The amount of inlined local variables.<br>
<em>/<br>
private int inlinedVars;<br>
/</em>*</li>
<li>The amount of inlined strings.<br>
<em>/<br>
private int inlinedStrings;<br>
/</em>*</li>
<li>The logger.<br>
<em>/<br>
private final Logger logger = Logger.getLogger(this.getClass().getName());<br>
/</em>*</li>
<li>The pattern used to find a stored encrypted string.<br>
<em>/<br>
private static final String SUPER_INVOKE_PATTERN = “AbstractInsnNode INVOKESTATIC INVOKESTATIC INVOKESTATIC AASTORE”;<br>
/</em>*</li>
<li>The local variable pattern.<br>
*/<br>
private static final int[] LOCAL_VAR_PATTERN = new int[] { Opcodes.LDC, Opcodes.SWAP, Opcodes.DUP_X1, Opcodes.POP, Opcodes.POP };</li>
</ul>
<p>@SuppressWarnings(“unchecked”)<br>
@Override<br>
public void optimize(ClassArchive archive) throws Exception {<br>
logger.info(“Removing ‘super’ string encryption…’”);<br>
outer: for (ClassNode cn : archive) {<br>
MethodNode clinit = null;<br>
LdcInsnNode superLdc = null;<br>
for (MethodNode mn : (List) cn.methods) {<br>
if (superLdc == null) {<br>
if (mn.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")) {<br>
for (Iterator itr = InsnNodeUtils.collect(mn, Opcodes.LDC); itr.hasNext()<img src="https://forum.moparisthebest.com/images/emoji/twitter/wink.png?v=5" title=":wink:" class="emoji" alt=":wink:"> {<br>
LdcInsnNode ldc = (LdcInsnNode) itr.next();<br>
superLdc = ldc;<br>
break;<br>
}<br>
}<br>
}<br>
if (mn.name.equals("")) { // check for the static block, if there is none there is no point<br>
// in attempting to decrypt this class…<br>
clinit = mn;<br>
}<br>
}</p>
<pre><code> 	if (clinit == null || superLdc == null) {
 		continue;
 	}

 	MethodNode[] decMethods = StringUtils.getDecryptionMethods(cn);

 	for (MethodNode dec : decMethods) {
 		if (dec == null) {// We are missing a decryption method.... thats very odd.
 			continue outer;
 		}
 	}

 	InstructionSearcher searcher = new InstructionSearcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = searcher.match(LOCAL_VAR_PATTERN); itr.hasNext();) { // This is probably only needed for RuneScape clients...
 		AbstractInsnNode[] match = itr.next();

 		for (int i = 0; i &lt; match.length; i++) {
 			clinit.instructions.remove(match[i]);
 		}
 		
 		inlinedVars++;
 	}

 	int[] keys = StringUtils.findKeys(decMethods);


 	InsnMatcher matcher = new InsnMatcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = matcher.match(SUPER_INVOKE_PATTERN); itr.hasNext();) {
 		AbstractInsnNode[] match = itr.next();
 		
 		MethodInsnNode superDec = (MethodInsnNode) match[1];
 		
 		AbstractInsnNode insn = match[0];
 		
 		LdcInsnNode ldc;
 		if (insn.getOpcode() == Opcodes.LDC) {
 			ldc = (LdcInsnNode) insn;
 		} else {
 			ldc = (LdcInsnNode) insn.getPrevious();
 		}
 		
 		cn.methods.remove(InsnNodeUtils.resolveMethodInsn(cn, superDec));
 		
 		clinit.instructions.set(ldc, new LdcInsnNode(decryptSuper(StringUtils.decryptStandard(keys, (String) ldc.cst), (String) superLdc.cst)));
 		clinit.instructions.remove(superDec);
 		
 		inlinedStrings++;
 	}
 }
</code></pre>
<p>}</p>
<p>@Override<br>
public void onCompletion() {<br>
logger.info(“Inlined “+inlinedStrings+” strings and “+inlinedVars+” local variables.”);<br>
}</p>
<p>/**</p>
<ul>
<li>Used to decipher the “super_ method” keys.</li>
<li>@param encrypted The encrypted string.</li>
<li>@param key The standard decrypted key.</li>
<li>@return<br>
*/<br>
private String decryptSuper(String encrypted, String key) {<br>
char[] ch = new char[encrypted.length() - 1];<br>
for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] = (char)(encrypted.charAt(pos) ^ (key.charAt(pos % key.length()) &amp; 0x3F));<br>
}<br>
return new String(ch);<br>
}</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>[code]package com.hijackrs.deober.util;</p>
<p>import java.util.Iterator;<br>
import java.util.List;</p>
<p>import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>/**</p>
<ul>
<li>
<p>A class filled with utilities used in the StringOptimizer classes.</p>
</li>
<li>
<p>@author `Discardedx2</p>
</li>
<li>
<p>@author Graham Edgecombe<br>
*/<br>
public class StringUtils {</p>
<p>/**</p>
<ul>
<li>The first decryption pattern used to find the first key.<br>
<em>/<br>
public static final String STR_TO_CHARS_PATTERN = “CALOAD (BIPUSH | SIPUSH | ICONST) IXOR I2C CASTORE”;<br>
/</em>*</li>
<li>The second decryption pattern used to find the second keys.<br>
<em>/<br>
public static final String CHARS_TO_STR_PATTERN = "CALOAD ILOAD ICONST IREM (TABLESWITCH | LOOKUPSWITCH) ((BIPUSH | SIPUSH | ICONST) GOTO?)</em> IXOR I2C CASTORE";</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Decrypts a string.</p>
</li>
<li>
<p>@param keys The keys.</p>
</li>
<li>
<p>@param str The encrypted string.</p>
</li>
<li>
<p>@return The decrypted string.<br>
*/<br>
public static String decryptStandard(int[] keys, String str) {<br>
char[] ch = str.toCharArray();<br>
if (ch.length &lt; 2)<br>
ch[0] ^= keys[0];</p>
<p>for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] ^= keys[pos % 5 + 1];<br>
}</p>
<p>return new String(ch).intern();<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Finds the key set.</p>
</li>
<li>
<p>@param m1 The string to characters method.</p>
</li>
<li>
<p>@param m2 The characters to string method.</p>
</li>
<li>
<p>@return The keys, or {@code null} if they could not be found.<br>
*/<br>
public static int[] findKeys(MethodNode[] decMethods) {<br>
int[] keys = new int[6];</p>
<p>InsnMatcher matcher = new InsnMatcher(decMethods[0].instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; it = matcher.match(STR_TO_CHARS_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>AbstractInsnNode[] match = it.next();<br>
keys[0] = (int) InsnNodeUtils.getNumericPushValue(match[1]);</p>
<p>matcher = new InsnMatcher(decMethods[1].instructions);<br>
it = matcher.match(CHARS_TO_STR_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>match = it.next();<br>
for (int i = 0; i &lt; 5; i++) {<br>
keys[i + 1] = (int) InsnNodeUtils.getNumericPushValue(match[5 + i * 2]);<br>
}</p>
<p>return keys;<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Gets the decryption methods.</p>
</li>
<li>
<p>@return The decryption methods.<br>
*/<br>
@SuppressWarnings(“unchecked”)<br>
public static MethodNode[] getDecryptionMethods(ClassNode cn) {<br>
MethodNode[] min = new MethodNode[2];</p>
<p>for (MethodNode mn : (List) cn.methods) {<br>
InsnMatcher matcher = new InsnMatcher(mn.instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; strings = matcher.match(STR_TO_CHARS_PATTERN);<br>
Iterator&lt;AbstractInsnNode[]&gt; chars = matcher.match(CHARS_TO_STR_PATTERN);</p>
<pre><code> if (strings.hasNext()) {
 	min[0] = mn;
 } else if (chars.hasNext()) {
 	min[1] = mn;
 }
</code></pre>
<p>}<br>
return min;<br>
}</p>
</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>That fixes the string encryption enough so that the old string decryption will still work. You guys can probably work out what some of the missing methods do by looking at other string decryption classes, I don’t have full permission to post the InsnNodeUtils class.[/quote]</p>
<p>I’m sure this new encryption is just the same as the old one with the addition of:</p>
<pre><code class="lang-auto">	private static String decrypt_a(String string, String key) {
		char[] cs = new char[string.length()];
		for (int i = cs.length - 1; i &gt;= 0; i--) {
			int xor = key.charAt(i % key.length()) &amp; 0x3f;
			cs[i] = (char) (string.charAt(i) ^ xor);
		}
		return new String(cs);

	}</code></pre>
<p>so it’s not much different from the other one at all <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/26">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/26</link>
        <pubDate>Sun, 15 Jan 2012 16:40:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-26</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@_Discardedx21 `Discardedx2`]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_discardedx21">@_Discardedx21</a> wrote:</p>
          <blockquote>
              <p>[code]package com.hijackrs.deober.opt.impl;</p>
<p>import java.util.Iterator;<br>
import java.util.List;<br>
import java.util.logging.Logger;</p>
<p>import org.objectweb.asm.Opcodes;<br>
import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.LdcInsnNode;<br>
import org.objectweb.asm.tree.MethodInsnNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>import com.hijackrs.deober.arch.impl.ClassArchive;<br>
import com.hijackrs.deober.opt.Optimizer;<br>
import com.hijackrs.deober.util.InsnMatcher;<br>
import com.hijackrs.deober.util.InsnNodeUtils;<br>
import com.hijackrs.deober.util.InstructionSearcher;<br>
import com.hijackrs.deober.util.StringUtils;</p>
<p>/**</p>
<ul>
<li>
<p>This fixes the “super_” string obfuscation technique</p>
</li>
<li>
<p>added by Jacmob. Heres a little interesting fact</p>
</li>
<li>
<p>for those of you that actually read my documentation!</p>
</li>
<li>
<p>super_ is a reference to the user “super_”, an active member</p>
</li>
<li>
<p>of many programming communities!</p>
</li>
<li>
</li>
<li>
<p>This applies three steps, in order for the standard string decryption to work.</p>
</li>
<li>
<p>First, the program decrypts part of the string with the “super_” key</p>
</li>
<li>
<p>next it removes the INVOKESTATIC instruction that references</p>
</li>
<li>
<p>the decryptSuper method, and finally the decryptSuper method itself</p>
</li>
<li>
<p>is removed from the class.</p>
</li>
<li>
<p><span class="mention">@author</span> `Discardedx2<br>
*/<br>
public class SuperStringOptimizer implements Optimizer {</p>
<p>/**</p>
<ul>
<li>The amount of inlined local variables.<br>
<em>/<br>
private int inlinedVars;<br>
/</em>*</li>
<li>The amount of inlined strings.<br>
<em>/<br>
private int inlinedStrings;<br>
/</em>*</li>
<li>The logger.<br>
<em>/<br>
private final Logger logger = Logger.getLogger(this.getClass().getName());<br>
/</em>*</li>
<li>The pattern used to find a stored encrypted string.<br>
<em>/<br>
private static final String SUPER_INVOKE_PATTERN = “AbstractInsnNode INVOKESTATIC INVOKESTATIC INVOKESTATIC AASTORE”;<br>
/</em>*</li>
<li>The local variable pattern.<br>
*/<br>
private static final int[] LOCAL_VAR_PATTERN = new int[] { Opcodes.LDC, Opcodes.SWAP, Opcodes.DUP_X1, Opcodes.POP, Opcodes.POP };</li>
</ul>
<p>@SuppressWarnings(“unchecked”)<br>
@Override<br>
public void optimize(ClassArchive archive) throws Exception {<br>
logger.info(“Removing ‘super’ string encryption…’”);<br>
outer: for (ClassNode cn : archive) {<br>
MethodNode clinit = null;<br>
LdcInsnNode superLdc = null;<br>
for (MethodNode mn : (List) cn.methods) {<br>
if (superLdc == null) {<br>
if (mn.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")) {<br>
for (Iterator itr = InsnNodeUtils.collect(mn, Opcodes.LDC); itr.hasNext()<img src="https://forum.moparisthebest.com/images/emoji/twitter/wink.png?v=5" title=":wink:" class="emoji" alt=":wink:"> {<br>
LdcInsnNode ldc = (LdcInsnNode) itr.next();<br>
superLdc = ldc;<br>
break;<br>
}<br>
}<br>
}<br>
if (mn.name.equals("")) { // check for the static block, if there is none there is no point<br>
// in attempting to decrypt this class…<br>
clinit = mn;<br>
}<br>
}</p>
<pre><code> 	if (clinit == null || superLdc == null) {
 		continue;
 	}

 	MethodNode[] decMethods = StringUtils.getDecryptionMethods(cn);

 	for (MethodNode dec : decMethods) {
 		if (dec == null) {// We are missing a decryption method.... thats very odd.
 			continue outer;
 		}
 	}

 	InstructionSearcher searcher = new InstructionSearcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = searcher.match(LOCAL_VAR_PATTERN); itr.hasNext();) { // This is probably only needed for RuneScape clients...
 		AbstractInsnNode[] match = itr.next();

 		for (int i = 0; i &lt; match.length; i++) {
 			clinit.instructions.remove(match[i]);
 		}
 		
 		inlinedVars++;
 	}

 	int[] keys = StringUtils.findKeys(decMethods);


 	InsnMatcher matcher = new InsnMatcher(clinit.instructions);
 	for (Iterator&lt;AbstractInsnNode[]&gt; itr = matcher.match(SUPER_INVOKE_PATTERN); itr.hasNext();) {
 		AbstractInsnNode[] match = itr.next();
 		
 		MethodInsnNode superDec = (MethodInsnNode) match[1];
 		
 		AbstractInsnNode insn = match[0];
 		
 		LdcInsnNode ldc;
 		if (insn.getOpcode() == Opcodes.LDC) {
 			ldc = (LdcInsnNode) insn;
 		} else {
 			ldc = (LdcInsnNode) insn.getPrevious();
 		}
 		
 		cn.methods.remove(InsnNodeUtils.resolveMethodInsn(cn, superDec));
 		
 		clinit.instructions.set(ldc, new LdcInsnNode(decryptSuper(StringUtils.decryptStandard(keys, (String) ldc.cst), (String) superLdc.cst)));
 		clinit.instructions.remove(superDec);
 		
 		inlinedStrings++;
 	}
 }
</code></pre>
<p>}</p>
<p>@Override<br>
public void onCompletion() {<br>
logger.info(“Inlined “+inlinedStrings+” strings and “+inlinedVars+” local variables.”);<br>
}</p>
<p>/**</p>
<ul>
<li>Used to decipher the “super_ method” keys.</li>
<li>@param encrypted The encrypted string.</li>
<li>@param key The standard decrypted key.</li>
<li>@return<br>
*/<br>
private String decryptSuper(String encrypted, String key) {<br>
char[] ch = new char[encrypted.length() - 1];<br>
for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] = (char)(encrypted.charAt(pos) ^ (key.charAt(pos % key.length()) &amp; 0x3F));<br>
}<br>
return new String(ch);<br>
}</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>[code]package com.hijackrs.deober.util;</p>
<p>import java.util.Iterator;<br>
import java.util.List;</p>
<p>import org.objectweb.asm.tree.AbstractInsnNode;<br>
import org.objectweb.asm.tree.ClassNode;<br>
import org.objectweb.asm.tree.MethodNode;</p>
<p>/**</p>
<ul>
<li>
<p>A class filled with utilities used in the StringOptimizer classes.</p>
</li>
<li>
<p>@author `Discardedx2</p>
</li>
<li>
<p>@author Graham Edgecombe<br>
*/<br>
public class StringUtils {</p>
<p>/**</p>
<ul>
<li>The first decryption pattern used to find the first key.<br>
<em>/<br>
public static final String STR_TO_CHARS_PATTERN = “CALOAD (BIPUSH | SIPUSH | ICONST) IXOR I2C CASTORE”;<br>
/</em>*</li>
<li>The second decryption pattern used to find the second keys.<br>
<em>/<br>
public static final String CHARS_TO_STR_PATTERN = "CALOAD ILOAD ICONST IREM (TABLESWITCH | LOOKUPSWITCH) ((BIPUSH | SIPUSH | ICONST) GOTO?)</em> IXOR I2C CASTORE";</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Decrypts a string.</p>
</li>
<li>
<p>@param keys The keys.</p>
</li>
<li>
<p>@param str The encrypted string.</p>
</li>
<li>
<p>@return The decrypted string.<br>
*/<br>
public static String decryptStandard(int[] keys, String str) {<br>
char[] ch = str.toCharArray();<br>
if (ch.length &lt; 2)<br>
ch[0] ^= keys[0];</p>
<p>for (int pos = 0; pos &lt; ch.length; pos++) {<br>
ch[pos] ^= keys[pos % 5 + 1];<br>
}</p>
<p>return new String(ch).intern();<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Finds the key set.</p>
</li>
<li>
<p>@param m1 The string to characters method.</p>
</li>
<li>
<p>@param m2 The characters to string method.</p>
</li>
<li>
<p>@return The keys, or {@code null} if they could not be found.<br>
*/<br>
public static int[] findKeys(MethodNode[] decMethods) {<br>
int[] keys = new int[6];</p>
<p>InsnMatcher matcher = new InsnMatcher(decMethods[0].instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; it = matcher.match(STR_TO_CHARS_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>AbstractInsnNode[] match = it.next();<br>
keys[0] = (int) InsnNodeUtils.getNumericPushValue(match[1]);</p>
<p>matcher = new InsnMatcher(decMethods[1].instructions);<br>
it = matcher.match(CHARS_TO_STR_PATTERN);<br>
if (!it.hasNext())<br>
return null;</p>
<p>match = it.next();<br>
for (int i = 0; i &lt; 5; i++) {<br>
keys[i + 1] = (int) InsnNodeUtils.getNumericPushValue(match[5 + i * 2]);<br>
}</p>
<p>return keys;<br>
}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>
<p>Gets the decryption methods.</p>
</li>
<li>
<p>@return The decryption methods.<br>
*/<br>
@SuppressWarnings(“unchecked”)<br>
public static MethodNode[] getDecryptionMethods(ClassNode cn) {<br>
MethodNode[] min = new MethodNode[2];</p>
<p>for (MethodNode mn : (List) cn.methods) {<br>
InsnMatcher matcher = new InsnMatcher(mn.instructions);<br>
Iterator&lt;AbstractInsnNode[]&gt; strings = matcher.match(STR_TO_CHARS_PATTERN);<br>
Iterator&lt;AbstractInsnNode[]&gt; chars = matcher.match(CHARS_TO_STR_PATTERN);</p>
<pre><code> if (strings.hasNext()) {
 	min[0] = mn;
 } else if (chars.hasNext()) {
 	min[1] = mn;
 }
</code></pre>
<p>}<br>
return min;<br>
}</p>
</li>
</ul>
</li>
</ul>
<p>}[/code]</p>
<p>That fixes the string encryption enough so that the old string decryption will still work. You guys can probably work out what some of the missing methods do by looking at other string decryption classes, I don’t have full permission to post the InsnNodeUtils class.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/25">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/25</link>
        <pubDate>Sun, 15 Jan 2012 02:50:16 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-25</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p><a href="http://pastie.org/3186587" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/3186587</a></p>
<p>There’s my shitty hard coded one, if anyone just needed a reference.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/24">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/24</link>
        <pubDate>Sat, 14 Jan 2012 23:41:05 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-24</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@SpeedIsMeh SpeedIsMeh]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedismeh">@SpeedIsMeh</a> wrote:</p>
          <blockquote>
              <p>[quote=“sinisoul, post:22, topic:404006”]Has changed.</p>
<pre><code class="lang-auto">z(z(a(tmp112_107)));</code></pre>
<p><code>
  static String a(String paramString)
  {
    String str = "super_ method 7203";
    char[] arrayOfChar;
    for (int j = (arrayOfChar = new char[paramString.length()]).length - 1; j &gt;= 0; j--)
    {
      String tmp20_19 = str;
      int k = tmp20_19.charAt(j % tmp20_19.length()) &amp; 0x3F;
      int tmp37_36 = j;
      arrayOfChar[tmp37_36] = (char)(paramString.charAt(tmp37_36) ^ k);
    }
    return new String(arrayOfChar);
  }
</code>[/quote]<br>
old news but ill write one quickly now and post</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/23">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/23</link>
        <pubDate>Sat, 14 Jan 2012 22:39:52 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-23</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p>Has changed.</p>
<pre><code class="lang-auto">z(z(a(tmp112_107)));</code></pre>
<pre><code class="lang-auto">  static String a(String paramString)
  {
    String str = "super_ method 7203";
    char[] arrayOfChar;
    for (int j = (arrayOfChar = new char[paramString.length()]).length - 1; j &gt;= 0; j--)
    {
      String tmp20_19 = str;
      int k = tmp20_19.charAt(j % tmp20_19.length()) &amp; 0x3F;
      int tmp37_36 = j;
      arrayOfChar[tmp37_36] = (char)(paramString.charAt(tmp37_36) ^ k);
    }
    return new String(arrayOfChar);
  }</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/22">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/22</link>
        <pubDate>Sat, 14 Jan 2012 21:44:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-22</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@SpeedIsMeh SpeedIsMeh]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/speedismeh">@SpeedIsMeh</a> wrote:</p>
          <blockquote>
              <pre><code class="lang-auto">
package com.speedbot.updater.tools;

import java.util.Iterator;

import org.apache.bcel.classfile.Constant;
import org.apache.bcel.classfile.ConstantClass;
import org.apache.bcel.classfile.ConstantUtf8;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.ANEWARRAY;
import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ConstantPushInstruction;
import org.apache.bcel.generic.GETSTATIC;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.InstructionTargeter;
import org.apache.bcel.generic.LDC;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.PUTSTATIC;
import org.apache.bcel.generic.TABLESWITCH;
import org.apache.bcel.generic.TargetLostException;
import org.apache.bcel.generic.Type;
import org.apache.bcel.util.InstructionFinder;

import com.speedbot.updater.gen.RSClass;
import com.sun.org.apache.bcel.internal.Constants;

/**
 * Decrypts strings in the runescape client
 * 
 * @author Speed
 * 
 */
public class StringDecryptor implements DeobfuscatorTransform {
    private final RSClass cg;
    private static final String ARRAY_PATTERN = "constantpushinstruction anewarray (dup constantpushinstruction ldc invokestatic invokestatic aastore)+ putstatic";

    public StringDecryptor(final RSClass cg) {
	this.cg = cg;
    }

    public void run() {
	int arrayCount = countArrays(cg);
	ConstantPoolGen cpg = cg.getConstantPool();

	int[] keys = null;
	int key = -1;
	for (Method m : cg.getMethods()) {
	    if (m.isPrivate() &amp;&amp; m.isStatic()
		    &amp;&amp; m.getReturnType().equals(Type.STRING)
		    &amp;&amp; m.getArgumentTypes()[0].getSignature().equals("[C")) {
		keys = getKeys(m);
		cg.removeMethod(m);
	    } else if (m.isPrivate() &amp;&amp; m.isStatic()
		    &amp;&amp; m.getReturnType().getSignature().equals("[C")
		    &amp;&amp; m.getArgumentTypes()[0].equals(Type.STRING)) {
		key = getKey(m);
		cg.removeMethod(m);
	    }
	}
	if (keys != null &amp;&amp; key != -1) {
	    for (Method m : cg.getMethods()) {
		if (m.getName().equals("&lt;clinit&gt;") &amp;&amp; !m.isAbstract()
			&amp;&amp; !m.isNative()) {
		    MethodGen mg = new MethodGen(m, cg.getClassName(),
			    cg.getConstantPool());
		    InstructionList insList = mg.getInstructionList();
		    InstructionFinder finder = new InstructionFinder(insList);
		    Iterator&lt;InstructionHandle[]&gt; it = finder
			    .search(ARRAY_PATTERN);
		    while (it.hasNext()) {
			InstructionHandle[] handles = it.next();
			int size = ((ConstantPushInstruction) handles[0]
				.getInstruction()).getValue().intValue();
			String[] strings = new String[size];

			for (int i = 2; i &lt; handles.length - 1; i++) {
			    InstructionHandle handle = handles[i];
			    if (handle.getInstruction() instanceof LDC) {
				int index = ((ConstantPushInstruction) handles[i - 1]
					.getInstruction()).getValue()
					.intValue();
				String encrypted = ((LDC) handle
					.getInstruction()).getValue(cpg)
					.toString();
				String decrypted = decrypt(
					decrypt(encrypted, key), keys);
				strings[index] = decrypted;
			    }

			}
			InstructionHandle last = handles[handles.length - 1];
			InstructionHandle next = last.getNext();
			PUTSTATIC putstatic = (PUTSTATIC) last.getInstruction();
			for (InstructionHandle handle : handles) {
			    if (handle.hasTargeters()) {
				for (InstructionTargeter target : handle
					.getTargeters()) {
				    target.updateTarget(handle, next);
				}
			    }
			    try {
				insList.delete(handle);
			    } catch (TargetLostException e) {
				e.printStackTrace();
			    }
			}
			String class_name = putstatic.getClassName(cpg);
			String field_name = putstatic.getFieldName(cpg);
			inline(strings, field_name, class_name);
		    }
		    finder = new InstructionFinder(insList);

		    it = finder.search("ldc invokestatic invokestatic");
		    while (it.hasNext()) {
			InstructionHandle[] handles = it.next();
			LDC ldc = (LDC) handles[0].getInstruction();
			String enc = ldc.getValue(cpg).toString();
			String dec = decrypt(decrypt(enc, key), keys);
			int cp_index = cpg.addString(dec);
			LDC replacement = new LDC(cp_index);
			InstructionHandle hand = null;
			if (handles[2].getNext().getInstruction() instanceof PUTSTATIC
				&amp;&amp; arrayCount == 0) {
			    // inline single strings
			    String fieldName = ((PUTSTATIC) handles[2]
				    .getNext().getInstruction())
				    .getFieldName(cpg);
			    try {
				insList.delete(handles[2].getNext());
			    } catch (TargetLostException e1) {
				e1.printStackTrace();
			    }
			    for (Method method : cg.getMethods()) {
				if (method.isNative() || method.isAbstract())
				    continue;
				MethodGen methodg = new MethodGen(method,
					cg.getClassName(), cpg);
				InstructionList list = methodg
					.getInstructionList();
				InstructionSearcher search = new InstructionSearcher(
					method, cg);
				GETSTATIC get;
				while ((get = search.next(GETSTATIC.class)) != null) {
				    if (get.getClassName(cpg).equals(
					    cg.getClassName())
					    &amp;&amp; get.getFieldName(cpg).equals(
						    fieldName)) {
					if (list.contains(get)) {
					    hand = list
						    .insert(get, replacement);
					    InstructionHandle handle = search.handles[search.index];
					    if (handle.hasTargeters()) {
						for (InstructionTargeter target : handle
							.getTargeters()) {
						    target.updateTarget(handle,
							    hand);
						}
					    }
					    try {
						list.delete(get);
					    } catch (TargetLostException e) {
						e.printStackTrace();
					    }
					}
				    }
				}
				methodg.setMaxLocals();
				methodg.setMaxStack();
				cg.replaceMethod(method, methodg.getMethod());
			    }
			} else {
			    hand = insList.insert(handles[0], replacement);
			}
			Deobfuscator.fixed++;
			for (InstructionHandle handle : handles) {
			    if (handle.hasTargeters()) {
				for (InstructionTargeter target : handle
					.getTargeters()) {
				    target.updateTarget(handle, hand);
				}
			    }
			    try {
				insList.delete(handle);
			    } catch (TargetLostException e) {
				e.printStackTrace();
			    }
			}

		    }
		    mg.setInstructionList(insList);
		    mg.setMaxLocals();
		    mg.setMaxStack();
		    cg.replaceMethod(m, mg.getMethod());
		}
	    }

	}
    }

    private void inline(String[] strings, String field_name, String class_name) {
	ConstantPoolGen cpg = cg.getConstantPool();
	for (Method m : cg.getMethods()) {
	    if (m.isNative() || m.isAbstract())
		continue;
	    MethodGen methodgen = new MethodGen(m, cg.getClassName(), cpg);
	    InstructionList list = methodgen.getInstructionList();
	    InstructionFinder find = new InstructionFinder(list);
	    Iterator&lt;InstructionHandle[]&gt; iterator = find
		    .search("getstatic constantpushinstruction aaload");
	    while (iterator.hasNext()) {
		InstructionHandle[] h = iterator.next();
		GETSTATIC get = (GETSTATIC) h[0].getInstruction();
		if (get.getClassName(cpg).equals(class_name)
			&amp;&amp; get.getFieldName(cpg).equals(field_name)) {
		    int index = ((ConstantPushInstruction) h[1]
			    .getInstruction()).getValue().intValue();
		    String s = strings[index];
		    if (s == null)
			continue;

		    int cp_index = cpg.lookupString(s);
		    if (cp_index &lt; 0) {
			cp_index = cpg.addString(s);
		    }
		    Deobfuscator.fixed++;
		    LDC ldc = new LDC(cp_index);
		    InstructionHandle temp = list.insert(h[0], ldc);
		    for (int i = 0; i &lt; h.length; i++) {
			if (h[i].hasTargeters()) {
			    for (InstructionTargeter target : h[i]
				    .getTargeters()) {
				target.updateTarget(h[i], temp);
			    }
			}
			try {
			    list.delete(h[i]);
			} catch (TargetLostException e) {
			    e.printStackTrace();
			}
		    }

		}
	    }
	    methodgen.setMaxLocals();
	    methodgen.setMaxStack();
	    methodgen.setInstructionList(list);
	    cg.replaceMethod(m, methodgen.getMethod());
	}
	cg.setConstantPool(cpg);
    }

    private int countArrays(RSClass cg) {
	int count = 0;
	for (Method m : cg.getMethods()) {
	    if (m.getName().equals("&lt;clinit&gt;")) {
		InstructionSearcher searcher = new InstructionSearcher(m, cg);
		ANEWARRAY newArrayIns;
		while ((newArrayIns = searcher.next(ANEWARRAY.class)) != null) {
		    if (cg.getConstantPool()
			    .getConstant(newArrayIns.getIndex()).getTag() == Constants.CONSTANT_Class) {
			ConstantClass clz = (ConstantClass) cg
				.getConstantPool().getConstant(
					newArrayIns.getIndex());
			Constant c = cg.getConstantPool().getConstant(
				clz.getNameIndex());
			if (c instanceof ConstantUtf8) {
			    if (((ConstantUtf8) c).getBytes().equals(
				    "java/lang/String")) {
				count++;
			    }
			}
		    }
		}
	    }
	}
	return count;
    }

    private static int[] getKeys(final Method m) {
	String pattern = "tableswitch ConstantPushInstruction goto ConstantPushInstruction goto ConstantPushInstruction goto ConstantPushInstruction goto ConstantPushInstruction ixor";
	InstructionFinder find = new InstructionFinder(new InstructionList(m
		.getCode().getCode()));
	int[] keys = new int[5];
	Iterator&lt;InstructionHandle[]&gt; it = find.search(pattern);
	int i = 0;
	while (it.hasNext()) {
	    InstructionHandle[] handles = it.next();
	    TABLESWITCH tblswitch = (TABLESWITCH) handles[0].getInstruction();
	    for (InstructionHandle handle : tblswitch.getTargets()) {
		Instruction ins = handle.getInstruction();
		if (ins instanceof ConstantPushInstruction) {
		    keys[i++] = ((ConstantPushInstruction) ins).getValue()
			    .intValue();
		}
	    }
	    Instruction o = tblswitch.getTarget().getInstruction();
	    if (o instanceof ConstantPushInstruction) {
		keys[i++] = ((ConstantPushInstruction) o).getValue().intValue();
	    }

	}
	return keys;
    }

    private static char[] decrypt(final String string, final int key) {
	char[] cs = string.toCharArray();
	if (cs.length &lt; 2 &amp;&amp; cs.length &gt; 0)
	    cs[0] ^= (char) key;
	return cs;
    }

    private static String decrypt(char[] input, final int[] keys) {
	int index = 0;
	for (;;) {
	    if (input.length &lt;= index)
		break;
	    char c = input[index];
	    char xor = (char) keys[index % 5];
	    input[index] = (char) (c ^ xor);
	    index++;
	}
	String string = new String(input);
	return string.intern();
    }

    private static final int getKey(Method m) {
	String pattern = "caload ConstantPushInstruction ixor i2c";
	InstructionFinder finder = new InstructionFinder(new InstructionList(m
		.getCode().getCode()));
	Iterator&lt;InstructionHandle[]&gt; it = finder.search(pattern);
	while (it.hasNext()) {
	    InstructionHandle handle = it.next()[1];
	    Instruction i = handle.getInstruction();
	    if (i instanceof ConstantPushInstruction) {
		return ((ConstantPushInstruction) i).getValue().intValue();
	    }
	}
	return -1;
    }

    static class InstructionSearcher {
	InstructionList list;
	Method m;
	ClassGen cg;
	InstructionFinder finder;
	int index;
	InstructionHandle[] handles;

	InstructionSearcher(Method m, ClassGen cg) {
	    this.cg = cg;
	    this.m = m;
	    this.list = new InstructionList(m.getCode().getCode());
	    this.finder = new InstructionFinder(list);
	    handles = list.getInstructionHandles();
	}

	public &lt;T&gt; T next(Class&lt;T&gt; type) {
	    for (int i = index + 1; i &lt; handles.length; i++) {
		index++;
		if (handles[i].getInstruction() == null)
		    continue;
		if (type.isAssignableFrom(handles[i].getInstruction()
			.getClass())) {
		    return type.cast(handles[i].getInstruction());
		}
	    }
	    return null;
	}

	public InstructionHandle next() {
	    if (index + 1 &gt;= handles.length) {
		return null;
	    }
	    return handles[++index];
	}
    }
}</code></pre>
<p>This is my BCEL version, it’s pretty old since I haven’t touched the client for many months now but it should still work.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/21">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/21</link>
        <pubDate>Mon, 24 Oct 2011 17:35:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-21</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p><a href="http://www.mediafire.com/?tw7cztff0hhe63x" class="onebox" target="_blank" rel="nofollow noopener">http://www.mediafire.com/?tw7cztff0hhe63x</a></p>
<p>code is bad, idea is good</p>
<p>use this idea in the future thanks</p>
<p>ps: fix attachments</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/20">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/20</link>
        <pubDate>Thu, 13 Oct 2011 18:27:26 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-20</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@03data 03data]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/03data">@03data</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="14" data-topic="404006">
<div class="title">
<div class="quote-controls"></div>
 super_:</div>
<blockquote>
<p>i’m just glad zkm doesn’t use inline subroutines (jsr, ret) to implement the cipher anymore</p>
</blockquote>
</aside>
<p>They still use it themselves, on their obfuscator for example.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/19">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/19</link>
        <pubDate>Sun, 24 Jul 2011 15:44:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-19</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>your decompiler inlined the subroutines</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/18">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/18</link>
        <pubDate>Tue, 19 Jul 2011 07:07:03 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-18</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@moparisthebest Moparisthebest]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/moparisthebest">@moparisthebest</a> wrote:</p>
          <blockquote>
              <p>All the decryption is done in the static initializer before anything else happens, I wouldn’t call it inline.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/17">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/17</link>
        <pubDate>Tue, 19 Jul 2011 06:12:20 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-17</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@Jython super_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jython">@Jython</a> wrote:</p>
          <blockquote>
              <p>the static block is zkm with inlined decryption subroutines</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/16</link>
        <pubDate>Tue, 19 Jul 2011 05:02:41 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-16</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@moparisthebest Moparisthebest]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/moparisthebest">@moparisthebest</a> wrote:</p>
          <blockquote>
              <p>Speaking of String encryption, has anyone seen any like this before?</p>
<p><a href="http://pastebin.com/V7YxUDfK" class="onebox" target="_blank">http://pastebin.com/V7YxUDfK</a></p>
<p>Know what obfuscator produces it, or any ideas on removing it?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/15</link>
        <pubDate>Tue, 19 Jul 2011 04:49:58 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-15</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@Jython super_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jython">@Jython</a> wrote:</p>
          <blockquote>
              <p>the algorithm isn’t that hard to reproduce<br>
the bytecode is pretty straight forward</p>
<pre><code class="lang-auto">char[] cs = str.toCharArray();
int n = cs.length;
int i = 0;
while (i &lt; n) {
    char c = cs[i];
    switch (i % n) {
        case 0:
            c = c ^ KEY0;
        case 1:
            c = c ^ KEY1;
        case 2:
            c = c ^ KEY2;
        case 3:
            c = c ^ KEY3;
        default:
            c = c ^ KEY4;
    }
    c[i] = c;
    ++i;
}</code></pre>
<p>i’m just glad zkm doesn’t use inline subroutines (jsr, ret) to implement the cipher anymore</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/14</link>
        <pubDate>Mon, 18 Jul 2011 01:38:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-14</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@sspoke sspoke]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sspoke">@sspoke</a> wrote:</p>
          <blockquote>
              <p>haha I’ve done the same in C#</p>
<p>keys = TABLESWITCH values.</p>
<pre><code class="lang-auto">	    public static string decryptXOrString(String encrypted, int[] keys) {
		    char[] chars = encrypted.ToCharArray();
		    for(int index = 0; index &lt; chars.Length; index++)
			    chars[index] = (char) (chars[index] ^ keys[index % keys.Length]);
		    return new string(chars);
	    }</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/13</link>
        <pubDate>Sun, 17 Jul 2011 23:57:58 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-13</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@davidi2 Davidi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/davidi2">@davidi2</a> wrote:</p>
          <blockquote>
              <p>[quote=“Evil_, post:11, topic:404006”]Or it could’ve been me lol, I think I gave mine to a few people[/quote]Yea that’s what I’m thinking <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/12</link>
        <pubDate>Fri, 15 Jul 2011 04:46:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-12</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@Evil1 Evil_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/evil1">@Evil1</a> wrote:</p>
          <blockquote>
              <p>Or it could’ve been me lol, I think I gave mine to a few people</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/11</link>
        <pubDate>Fri, 15 Jul 2011 04:26:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-11</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@m.dog311 m.dog311]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/m.dog311">@m.dog311</a> wrote:</p>
          <blockquote>
              <p>I know I was talking to a couple guys about in on StrictFP, so ya, probably.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/10</link>
        <pubDate>Fri, 15 Jul 2011 02:47:44 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-10</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@davidi2 Davidi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/davidi2">@davidi2</a> wrote:</p>
          <blockquote>
              <p>I could have sworn I saw someone post (something similiar?) to this on SFP IRC a while back (was definitely for string decryption though), was it you?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/9</link>
        <pubDate>Fri, 15 Jul 2011 02:44:52 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-9</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@m.dog311 m.dog311]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/m.dog311">@m.dog311</a> wrote:</p>
          <blockquote>
              <p>You mean the guy who ripped Taharok’s perfect compiler and posted it has is own!</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/8</link>
        <pubDate>Fri, 15 Jul 2011 02:19:18 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-8</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
      <item>
        <title>ASM String Decryption</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>The day the guy who made a ‘perfect compiler’ creates a ZKM string decryption utility and possibly gets CM.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/asm-string-decryption/404006/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/asm-string-decryption/404006/7</link>
        <pubDate>Fri, 15 Jul 2011 02:17:05 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-404006-7</guid>
        <source url="https://forum.moparisthebest.com/t/asm-string-decryption/404006.rss">ASM String Decryption</source>
      </item>
  </channel>
</rss>
