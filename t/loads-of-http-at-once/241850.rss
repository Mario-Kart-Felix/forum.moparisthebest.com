<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Loads of http at once</title>
    <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850</link>
    <description>was messing around with nonblocking sockets and select()
made this,

downloads loads of pages at once with http and saves to a file.
doesn&#39;t parse it or anything, so the file has http headers.


trail run
[code]
 |    connecting to www.utas.edu.au...
 |    connecting to www.moparisthebest.com...
 |    connecting to rafb.net...
 |    connecting to www.google.co.uk...
 |    connecting to en.wikipedia.org...
 |    connecting to www.imageshack.us...
 |    connecting to www.richarddawkins.net...
 |    connecting to www.hevanet.com...
 |    connecting to beej.us...
 |    connecting to graphics.stanford.edu...
 ||   connected to www.moparisthebest.com in 1 secs, 4294282325 usecs
 ||   connected to rafb.net in 1 secs, 4294262155 usecs
 ||   connected to www.google.co.uk in 1 secs, 4294242404 usecs
 ||   connected to en.wikipedia.org in 1 secs, 4294219091 usecs
 |||  sent all data to www.moparisthebest.com in 0 secs, 37 usecs
 |||  sent all data to rafb.net in 0 secs, 151 usecs
 |||  sent all data to www.google.co.uk in 0 secs, 182 usecs
 |||  sent all data to en.wikipedia.org in 0 secs, 214 usecs
 ||   connected to www.utas.edu.au in 1 secs, 4294327242 usecs
 |||  sent all data to www.utas.edu.au in 0 secs, 24 usecs
 ||   connected to www.richarddawkins.net in 0 secs, 114947 usecs
 |||  sent all data to www.richarddawkins.net in 0 secs, 19 usecs
 |||| recv&#39;d all data from www.google.co.uk in 0 secs, 84416 usecs
 ||   connected to www.imageshack.us in 0 secs, 189829 usecs
 |||  sent all data to www.imageshack.us in 0 secs, 20 usecs
 ||   connected to beej.us in 0 secs, 177506 usecs
 |||  sent all data to beej.us in 0 secs, 21 usecs
 ||   connected to www.hevanet.com in 0 secs, 198819 usecs
 |||  sent all data to www.hevanet.com in 0 secs, 30 usecs
 ||   connected to graphics.stanford.edu in 0 secs, 181828 usecs
 |||| recv&#39;d all data from en.wikipedia.org in 0 secs, 181548 usecs
 |||  sent all data to graphics.stanford.edu in 0 secs, 141 usecs
 |||| recv&#39;d all data from rafb.net in 0 secs, 212302 usecs
 |||| recv&#39;d all data from beej.us in 0 secs, 374370 usecs
 |||| recv&#39;d all data from www.hevanet.com in 0 secs, 400847 usecs
 |||| recv&#39;d all data from www.richarddawkins.net in 0 secs, 620682 usecs
 |||| recv&#39;d all data from www.moparisthebest.com in 0 secs, 780372 usecs
 |||| recv&#39;d all data from www.imageshack.us in 0 secs, 720049 usecs
 |||| recv&#39;d all data from graphics.stanford.edu in 1 secs, 4294934726 usecs
 |||| recv&#39;d all data from www.utas.edu.au in 2 secs, 4294824835 usecs
** finished all jobs
[/code]


the code

[code]

/*
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

/*
 downloads loads of things at once with http
 yakman
*/

#include &lt;sys/time.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;netdb.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;


//stuff below parses a url
#define MAX_URL_LENGTH 256

typedef struct URL {
	char host[128];
	char file[128];
	int port;
} URL;

int
parseURL(URL* url, const char* string, char* error_msg, int error_size) {

	if(strlen(string) &gt; MAX_URL_LENGTH) {
		snprintf(error_msg, error_size, &quot;string too long, max length is %d&quot;, MAX_URL_LENGTH);
		return 1;
	}

	if(strncmp(string, &quot;http://&quot;, 7) != 0) {
		snprintf(error_msg, error_size, &quot;wrong protocol, has to be \&quot;http\&quot;&quot;);
		return 1;
	}
	string += 7;

	char* end_of_host = strpbrk(string, &quot;/:&quot;);
	if(end_of_host == NULL) {
		url-&gt;file[0] = &#39;/&#39;;
		url-&gt;file[1] = &#39;\0&#39;;
		url-&gt;port = 80;
		strcpy(url-&gt;host, string);
		return 0;
	}

	memcpy(url-&gt;host, string, (end_of_host - string));
	url-&gt;host[(end_of_host - string)] = &#39;\0&#39;;
	char buf[8];

	switch(*end_of_host) {
		case &#39;/&#39;: {
			url-&gt;port = 80;
			strcpy(url-&gt;file, end_of_host);
		} break;
		case &#39;:&#39;: {
			end_of_host++;
			char* end_of_port = strchr(end_of_host, &#39;/&#39;);
			url-&gt;file[0] = &#39;/&#39;;
			url-&gt;file[1] = &#39;\0&#39;;
			if(end_of_port != NULL) {
				strcpy(url-&gt;file + 1, end_of_port + 1);
				memset(buf, 0, sizeof(buf));
				memcpy(buf, end_of_host, (end_of_port - end_of_host));
				end_of_host = buf;
			}

			url-&gt;port = atoi(end_of_host);
		} break;
		default: {
			snprintf(error_msg, error_size, &quot;[BUG] logic error line:%d *eoh = &#39;%c&#39; = 0x%x&quot;, __LINE__, *end_of_host, *end_of_host);
			return 1;
		}
	}

	return 0;
}

char*
make_file_name(URL* url) {
	static char buf[MAX_URL_LENGTH];

	int hl = strlen(url-&gt;host);
	int fl = strlen(url-&gt;file);

	memcpy(buf, url-&gt;host, hl);
	memcpy(buf + hl, url-&gt;file, fl + 1); //+1 to get the terminator

	char* t;
	while(t = strchr(buf, &#39;/&#39;))
		*t = &#39;.&#39;;
	return buf;
}

typedef struct client {
	int status; //0= need to connect() 1= need to send data 2= need to read data
	int fd; //socket fd

	int pos; //buffer position
	int len; //buffer len
	char buf[512]; //send buffer

	FILE* output; //output file
	struct timeval tv;
	URL url; //url

	struct client* next; //linked list
} client;

client*
parse_command_line(int argc, char** argv) {
	client* head = NULL;
	client* prev;
	for(int f = 1; f &lt; argc; f++) {

		client* node = malloc(sizeof(client));
		memset(node, 0, sizeof(client));
		if(!head)
			head = prev = node;

		char err[512];
		if(0 != parseURL(&amp;node-&gt;url, argv[f], err, sizeof(err))) {
			fprintf(stderr, &quot;parseURL(): &lt;%s&gt; %s\n&quot;, argv[f], err);
			return NULL;
		}

		prev-&gt;next = node;
		prev = node;
		if(f == argc-1)
			node-&gt;next = NULL;
	}
	return head;
}

char format[] = &quot;GET %s HTTP/1.1\r\n&quot;
		&quot;Accept: */*\r\n&quot;
		&quot;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; InfoPath.2)\r\n&quot;
		&quot;Host: %s\r\n&quot;
		&quot;Connection: Close\r\n\r\n&quot;;

int
main(int argc, char** argv) {
	if(argc == 1)
		return fprintf(stderr, &quot;%s [url..]\n&quot;, argv[0]);
	client* head = parse_command_line(argc, argv);
	if(!head)
		return EXIT_FAILURE;

	client *c = head;
	do { //loop through clients opening files and sending syns
		c-&gt;fd = socket(AF_INET, SOCK_STREAM, 0);
		if(c-&gt;fd &lt; 0)
			return fprintf(stderr, &quot;socket(): %s\n&quot;, strerror(errno));

		c-&gt;len = sprintf(c-&gt;buf, format, c-&gt;url.file, c-&gt;url.host);

		//lookup host
		struct hostent* he = gethostbyname(c-&gt;url.host);
		if(he == NULL)
			return fprintf(stderr, &quot;gethostbyname(): &lt;%s&gt; %s\n&quot;, c-&gt;url.host, strerror(errno));

		//set nonblocking
		int arg = fcntl(c-&gt;fd, F_GETFL, NULL); 
		arg |= O_NONBLOCK; 
		fcntl(c-&gt;fd, F_SETFL, arg);

		struct sockaddr_in address;
		address.sin_family = AF_INET;
		address.sin_port = htons(c-&gt;url.port);
		address.sin_addr.s_addr = ((struct in_addr*)he-&gt;h_addr)-&gt;s_addr;

		//start the connect sequence
		errno = 0;
		if(connect(c-&gt;fd, (struct sockaddr*)&amp;address, sizeof(struct sockaddr)) &gt; 0)
			return fprintf(stderr, &quot;connect returned unexpected\n&quot;);
		gettimeofday(&amp;c-&gt;tv, NULL);
		printf(&quot; |    connecting to %s...\n&quot;, c-&gt;url.host);

		if(errno != EINPROGRESS)
			return fprintf(stderr, &quot;unexpected: %s\n&quot;, strerror(errno));

		c = c-&gt;next;
	} while(c);


	while(head) {

		int maxfd = 0;
		#define update_fd(x) maxfd = (maxfd &gt; x ? maxfd : x)

		fd_set rset, wset;
		FD_ZERO(&amp;rset);
		FD_ZERO(&amp;wset);

		//fill up fd sets
		client* s = head;
		do {

			switch(s-&gt;status) {
				case 0: { //need to connect
					FD_SET(s-&gt;fd, &amp;wset);
					update_fd(s-&gt;fd);
				} break;
				case 1: { //need to send data
					FD_SET(s-&gt;fd, &amp;wset);
					update_fd(s-&gt;fd);
				} break;
				case 2: { //need to recv data
					FD_SET(s-&gt;fd, &amp;rset);
					update_fd(s-&gt;fd);
				} break;
				default:
					return fprintf(stderr, &quot;unexpected status l:%d &lt;%d&gt;\n&quot;, __LINE__, s-&gt;status);
			}

			s = s-&gt;next;
		} while(s);


		if(select(maxfd + 1, &amp;rset, &amp;wset, NULL, NULL) &lt; 0)
			return fprintf(stderr, &quot;select(): %s\n&quot;, strerror(errno));


		//process fds
		client* h = head;
		client* t = NULL;
		client* prev = NULL;
		do {

			switch(h-&gt;status) {
				case 0: { //need to connect
					if(!FD_ISSET(h-&gt;fd, &amp;wset)) //connected
						break;
					struct timeval tv;
					gettimeofday(&amp;tv, NULL);
					printf(&quot; ||   connected to %s in %d secs, %u usecs\n&quot;,
						h-&gt;url.host, tv.tv_sec - h-&gt;tv.tv_sec, tv.tv_usec - h-&gt;tv.tv_usec);
					gettimeofday(&amp;h-&gt;tv, NULL);
					h-&gt;status++;

				} break;
				case 1: { //need to send

					if(!FD_ISSET(h-&gt;fd, &amp;wset))
						break;
					int r = send(h-&gt;fd, h-&gt;buf + h-&gt;pos, h-&gt;len - h-&gt;pos, 0);
					if(r &lt; 1)
						return fprintf(stderr, &quot;send(): %s\n&quot;, strerror(errno));
					h-&gt;pos += r;

					if(h-&gt;pos == h-&gt;len) {//sent all the data
						struct timeval tv;
						gettimeofday(&amp;tv, NULL);
						printf(&quot; |||  sent all data to %s in %d secs, %u usecs\n&quot;,
							h-&gt;url.host, tv.tv_sec - h-&gt;tv.tv_sec, tv.tv_usec - h-&gt;tv.tv_usec);
						gettimeofday(&amp;h-&gt;tv, NULL);

						h-&gt;status++;
						h-&gt;output = fopen(make_file_name(&amp;h-&gt;url), &quot;wb&quot;);
						if(!h-&gt;output)
							return fprintf(stderr, &quot;fopen(): %s\n&quot;, strerror(errno));
					}
				} break;
				case 2: { //need to recv
					if(!FD_ISSET(h-&gt;fd, &amp;rset))
						break;
					char buffer[1024];
					errno = 0;
					int r = recv(h-&gt;fd, buffer, sizeof(buffer), 0);
					if(r &lt; 1) { //eof or error
						if(errno) 
							return fprintf(stderr, &quot;recv(): %s\n&quot;, strerror(errno));

						struct timeval tv;
						gettimeofday(&amp;tv, NULL);
						printf(&quot; |||| recv&#39;d all data from %s in %d secs, %u usecs\n&quot;,
							h-&gt;url.host, tv.tv_sec - h-&gt;tv.tv_sec, tv.tv_usec - h-&gt;tv.tv_usec);
						fclose(h-&gt;output);
						close(h-&gt;fd);

						if(prev)
							prev-&gt;next = h-&gt;next; //not the head
						else
						if(h-&gt;next)
							head = h-&gt;next; //the head, but not the last element
						else
							head = NULL;//the head, also the last element
						t = h-&gt;next;
						free(h);
						h = NULL;
						break;
					}

					fwrite(buffer, 1, r, h-&gt;output);
				} break;
				default:
					return fprintf(stderr, &quot;unexpected status l:%d &lt;%d&gt;\n&quot;, __LINE__, s-&gt;status);
			}

			if(h) {
				prev = h; //if this element was freed
				h = h-&gt;next;
			} else {
				h = t;
			}
		} while(h);
	}

	printf(&quot;** finished all jobs\n&quot;);
	return EXIT_SUCCESS;
}

[/code]

post criticism</description>
    
    <lastBuildDate>Fri, 14 Nov 2008 03:09:29 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>[quote=“seand, post:14, topic:241850”]what the fuck? there’s nothing wrong with that code, except for the fact that i made the length variable a reference. the fact that i use the buffer’s length and assume it’s null-terminated isn’t a problem; it’s not like i’m exposing the function. if you’re going to cry over the fact that you need to null-terminate it, then go ahead and waste your time and make a new version of strstr(). and then maybe when you get a brain you can understand how it works and why it was written that way. it does exactly what it’s supposed to do, and it’s cool and all if you don’t get it, but quit arguing that it’s wrong. because it’s not.[/quote]yakman is an ignorant, opinionated communist; hes right you are wrong!!!</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/15</link>
        <pubDate>Fri, 14 Nov 2008 03:09:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-15</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>what the fuck? there’s nothing wrong with that code, except for the fact that i made the length variable a reference. the fact that i use the buffer’s length and assume it’s null-terminated isn’t a problem; it’s not like i’m exposing the function. if you’re going to cry over the fact that you need to null-terminate it, then go ahead and waste your time and make a new version of strstr(). and then maybe when you get a brain you can understand how it works and why it was written that way. it does exactly what it’s supposed to do, and it’s cool and all if you don’t get it, but quit arguing that it’s wrong. because it’s not.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/14</link>
        <pubDate>Fri, 14 Nov 2008 02:09:12 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-14</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>you function does not do what you want it to do. It doesnt solve the problem i pointed out before.</p>
<aside class="quote no-group quote-modified" data-post="12" data-topic="241850">
<div class="title">
<div class="quote-controls"></div>
 seand:</div>
<blockquote>
<p>the function asks for the length because you obviously already know it in the calling function. i don’t see any reason to waste CPU cycles calling strlen() to find the length again. it’s not like size_t imposes a huge burden on the program anyway.</p>
</blockquote>
</aside>
<p>its looks completely fugly,<br>
in that case you should make your own version of strstr() which uses a length variable instead of looking for null. And which doesnt force the user of the function to null terminate.</p>
<p>if using c++ makes me write code like yours, ill use c any day.</p>
<p>the real reason i used c instead of c++ for this is because i didnt need any templates or OOP.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/13</link>
        <pubDate>Thu, 13 Nov 2008 16:10:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-13</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <blockquote>i assume you do use your function like this</blockquote>
i'm not sure why you're assuming that's how i use it, seeing as that's not how i explained how it should be used. let me clarify:
<pre><code class="lang-auto">1) receive the data and store it in buffer
1a) if foundBody is true, write the buffer to the file
1b) if foundBody is false, append to the main buffer
2) call write_message_body on the main buffer, set foundBody to its return value, go back to 1</code></pre>
<blockquote>i don't know why your function asks for the length of the buffer when that buffer needs to be null terminated anyway</blockquote>
the function asks for the length because you obviously already know it in the calling function. i don't see any reason to waste CPU cycles calling strlen() to find the length again. it's not like size_t imposes a huge burden on the program anyway.
<blockquote>when i said getBuffer(), i assumed fstream &amp;file was a stream</blockquote>
you can safely assume fstream is a class in the C++ standard library. if you're using C and aren't familiar with that class, that's too bad for you, because C is a horrible language.
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/12</link>
        <pubDate>Wed, 12 Nov 2008 01:36:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-12</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>i assume you do use your function like this</p>
<pre><code class="lang-auto">r = recv(socket_fd, buffer, sizeof(buffer), 0);
buffer[r] = 0;

if(write_message_body(some_stream, buffer, r)) {
    /* ... */
}</code></pre>
<p>if you do, it might not detect the \r\n\r\n<br>
also, i don’t know why your function asks for the length of the buffer when that buffer needs to be null terminated anyway.</p>
<p>when i said getBuffer(), i assumed fstream &amp;file was a stream which writes to a buffer in memory, and that you can get that buffer by calling some method.<br>
to properly detect the \r\n\r\n, you need to search the stored buffer in memory, not only the buffer you just got when you called recv()</p>
<p>[quote=“seand, post:6, topic:241850”][code]bool write_message_body(fstream &amp;file, const char buffer[], const size_t &amp;bufLen)<br>
{<br>
char *posEnd;<br>
if((posEnd = strstr(file.some_method_which_gets_a_char_array, “\r\n\r\n”)) != NULL)<br>
{<br>
file.write(&amp;posEnd[4], bufLen - ((intptr_t)posEnd - (intptr_t)buffer + 4));<br>
return true;<br>
}</p>
<pre><code>return false;
</code></pre>
<p>}[/code][/quote]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/11</link>
        <pubDate>Tue, 11 Nov 2008 14:48:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-11</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>getBuffer()? that code checks to see if there’s a string \r\n\r\n in the buffer. if there is, write whatever is after that (the first part of the body) to the file and return true so whatever is received after that can also be written to the file. if not, return false so alternative processing can commence, such as receiving more data and appending to the original buffer so you can call write_message_body() again. not the best name, but whatever…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/10</link>
        <pubDate>Tue, 11 Nov 2008 02:57:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-10</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>oh right, i assumed the file part was actually writing to a file</p>
<p>but anyway, i like to roll my own memory management</p>
<p>although shouldn’t you do file.getBuffer() or whatever, since in that code, it looks like you’re just doing strstr() on the buffer you just recv()'d</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/9</link>
        <pubDate>Mon, 10 Nov 2008 19:42:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-9</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>the function returns false if it doesn’t find the string, so you can store this part of the header in a buffer and append the next part of data received from the server, and then re-test</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/8</link>
        <pubDate>Mon, 10 Nov 2008 17:09:47 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-8</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>what happens if the server sends this…<br>
(CRLF are escaped)</p>
<pre><code class="lang-auto">HTTP 200 OK\r\n
Content-type: text/html\r\n
Connection: close\r\n</code></pre>
<p>then waits a bit, then sends this, so you get it in two different returns of select()</p>
<pre><code class="lang-auto">\r\n
&lt;html&gt;
&lt;!-- stuff goes here --&gt;
&lt;/html&gt;</code></pre>
<p>thats completely valid http, but your code wouldn’t pick it up</p>
<p>thank you for your bit of code, but i already considered that kind of thing.<br>
i think the only way to separate them is to buffer the http headers real nicely, so it works even if the server sends one byte at a time.<br>
it would also be good if the server sends content-length.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/7</link>
        <pubDate>Mon, 10 Nov 2008 16:31:36 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-7</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>here you can use this separate the message header from its body:</p>
<p>[code]bool write_message_body(fstream &amp;file, const char buffer[], const size_t &amp;bufLen)<br>
{<br>
char *posEnd;<br>
if((posEnd = strstr(buffer, “\r\n\r\n”)) != NULL)<br>
{<br>
file.write(&amp;posEnd[4], bufLen - ((intptr_t)posEnd - (intptr_t)buffer + 4));<br>
return true;<br>
}</p>
<pre><code>return false;
</code></pre>
<p>}[/code]</p>
<p>don’t worry, i will put that under the GPL too so you can use it.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/6</link>
        <pubDate>Mon, 10 Nov 2008 04:47:12 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-6</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@BAsh BAsh]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/bash">@BAsh</a> wrote:</p>
          <blockquote>
              <p>Nice. Add some parsing and you could make a webcrawler.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/5</link>
        <pubDate>Sun, 09 Nov 2008 05:59:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-5</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@frank frank_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/frank">@frank</a> wrote:</p>
          <blockquote>
              <p>y gpl that</p>
<p>also why make a macro for maximum url length when the host/file portions are magic numbers</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/4</link>
        <pubDate>Sat, 08 Nov 2008 04:40:54 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-4</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>the names of the sites come from the command line user input</p>
<p>after googling cURL, i dont think thats what i made.</p>
<blockquote>PHP supports libcurl, a library created by Daniel Stenberg, that allows you to connect and communicate to many different types of servers with many different types of protocols. libcurl currently supports the http, https, ftp, gopher, telnet, dict, file, and ldap protocols. libcurl also supports HTTPS certificates, HTTP POST, HTTP PUT, FTP uploading (this can also be done with PHP's ftp extension), HTTP form based upload, proxies, cookies, and user+password authentication.</blockquote>
<p>i just use http, and not every well for that matter</p>
<p>the point of this was that it does the stuff at the same time, instead of one by one.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/3</link>
        <pubDate>Fri, 07 Nov 2008 20:40:49 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-3</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@belbn belbn]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/belbn">@belbn</a> wrote:</p>
          <blockquote>
              <p>C++ version of php cURL? Very nice.</p>
<p>Where do the names of the sites come from, is it user input or random?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/2</link>
        <pubDate>Fri, 07 Nov 2008 20:07:57 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-2</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
      <item>
        <title>Loads of http at once</title>
        <dc:creator><![CDATA[@yakman yakman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/yakman">@yakman</a> wrote:</p>
          <blockquote>
              <p>was messing around with nonblocking sockets and select()<br>
made this,</p>
<p>downloads loads of pages at once with http and saves to a file.<br>
doesn’t parse it or anything, so the file has http headers.</p>
<p>trail run</p>
<pre><code class="lang-auto"> |    connecting to www.utas.edu.au...
 |    connecting to www.moparisthebest.com...
 |    connecting to rafb.net...
 |    connecting to www.google.co.uk...
 |    connecting to en.wikipedia.org...
 |    connecting to www.imageshack.us...
 |    connecting to www.richarddawkins.net...
 |    connecting to www.hevanet.com...
 |    connecting to beej.us...
 |    connecting to graphics.stanford.edu...
 ||   connected to www.moparisthebest.com in 1 secs, 4294282325 usecs
 ||   connected to rafb.net in 1 secs, 4294262155 usecs
 ||   connected to www.google.co.uk in 1 secs, 4294242404 usecs
 ||   connected to en.wikipedia.org in 1 secs, 4294219091 usecs
 |||  sent all data to www.moparisthebest.com in 0 secs, 37 usecs
 |||  sent all data to rafb.net in 0 secs, 151 usecs
 |||  sent all data to www.google.co.uk in 0 secs, 182 usecs
 |||  sent all data to en.wikipedia.org in 0 secs, 214 usecs
 ||   connected to www.utas.edu.au in 1 secs, 4294327242 usecs
 |||  sent all data to www.utas.edu.au in 0 secs, 24 usecs
 ||   connected to www.richarddawkins.net in 0 secs, 114947 usecs
 |||  sent all data to www.richarddawkins.net in 0 secs, 19 usecs
 |||| recv'd all data from www.google.co.uk in 0 secs, 84416 usecs
 ||   connected to www.imageshack.us in 0 secs, 189829 usecs
 |||  sent all data to www.imageshack.us in 0 secs, 20 usecs
 ||   connected to beej.us in 0 secs, 177506 usecs
 |||  sent all data to beej.us in 0 secs, 21 usecs
 ||   connected to www.hevanet.com in 0 secs, 198819 usecs
 |||  sent all data to www.hevanet.com in 0 secs, 30 usecs
 ||   connected to graphics.stanford.edu in 0 secs, 181828 usecs
 |||| recv'd all data from en.wikipedia.org in 0 secs, 181548 usecs
 |||  sent all data to graphics.stanford.edu in 0 secs, 141 usecs
 |||| recv'd all data from rafb.net in 0 secs, 212302 usecs
 |||| recv'd all data from beej.us in 0 secs, 374370 usecs
 |||| recv'd all data from www.hevanet.com in 0 secs, 400847 usecs
 |||| recv'd all data from www.richarddawkins.net in 0 secs, 620682 usecs
 |||| recv'd all data from www.moparisthebest.com in 0 secs, 780372 usecs
 |||| recv'd all data from www.imageshack.us in 0 secs, 720049 usecs
 |||| recv'd all data from graphics.stanford.edu in 1 secs, 4294934726 usecs
 |||| recv'd all data from www.utas.edu.au in 2 secs, 4294824835 usecs
** finished all jobs</code></pre>
<p>the code</p>
<pre><code class="lang-auto">
/*
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/

/*
 downloads loads of things at once with http
 yakman
*/

#include &lt;sys/time.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;netdb.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;


//stuff below parses a url
#define MAX_URL_LENGTH 256

typedef struct URL {
	char host[128];
	char file[128];
	int port;
} URL;

int
parseURL(URL* url, const char* string, char* error_msg, int error_size) {

	if(strlen(string) &gt; MAX_URL_LENGTH) {
		snprintf(error_msg, error_size, "string too long, max length is %d", MAX_URL_LENGTH);
		return 1;
	}

	if(strncmp(string, "http://", 7) != 0) {
		snprintf(error_msg, error_size, "wrong protocol, has to be \"http\"");
		return 1;
	}
	string += 7;

	char* end_of_host = strpbrk(string, "/:");
	if(end_of_host == NULL) {
		url-&gt;file[0] = '/';
		url-&gt;file[1] = '\0';
		url-&gt;port = 80;
		strcpy(url-&gt;host, string);
		return 0;
	}

	memcpy(url-&gt;host, string, (end_of_host - string));
	url-&gt;host[(end_of_host - string)] = '\0';
	char buf[8];

	switch(*end_of_host) {
		case '/': {
			url-&gt;port = 80;
			strcpy(url-&gt;file, end_of_host);
		} break;
		case ':': {
			end_of_host++;
			char* end_of_port = strchr(end_of_host, '/');
			url-&gt;file[0] = '/';
			url-&gt;file[1] = '\0';
			if(end_of_port != NULL) {
				strcpy(url-&gt;file + 1, end_of_port + 1);
				memset(buf, 0, sizeof(buf));
				memcpy(buf, end_of_host, (end_of_port - end_of_host));
				end_of_host = buf;
			}

			url-&gt;port = atoi(end_of_host);
		} break;
		default: {
			snprintf(error_msg, error_size, "[BUG] logic error line:%d *eoh = '%c' = 0x%x", __LINE__, *end_of_host, *end_of_host);
			return 1;
		}
	}

	return 0;
}

char*
make_file_name(URL* url) {
	static char buf[MAX_URL_LENGTH];

	int hl = strlen(url-&gt;host);
	int fl = strlen(url-&gt;file);

	memcpy(buf, url-&gt;host, hl);
	memcpy(buf + hl, url-&gt;file, fl + 1); //+1 to get the terminator

	char* t;
	while(t = strchr(buf, '/'))
		*t = '.';
	return buf;
}

typedef struct client {
	int status; //0= need to connect() 1= need to send data 2= need to read data
	int fd; //socket fd

	int pos; //buffer position
	int len; //buffer len
	char buf[512]; //send buffer

	FILE* output; //output file
	struct timeval tv;
	URL url; //url

	struct client* next; //linked list
} client;

client*
parse_command_line(int argc, char** argv) {
	client* head = NULL;
	client* prev;
	for(int f = 1; f &lt; argc; f++) {

		client* node = malloc(sizeof(client));
		memset(node, 0, sizeof(client));
		if(!head)
			head = prev = node;

		char err[512];
		if(0 != parseURL(&amp;node-&gt;url, argv[f], err, sizeof(err))) {
			fprintf(stderr, "parseURL(): &lt;%s&gt; %s\n", argv[f], err);
			return NULL;
		}

		prev-&gt;next = node;
		prev = node;
		if(f == argc-1)
			node-&gt;next = NULL;
	}
	return head;
}

char format[] = "GET %s HTTP/1.1\r\n"
		"Accept: */*\r\n"
		"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506; InfoPath.2)\r\n"
		"Host: %s\r\n"
		"Connection: Close\r\n\r\n";

int
main(int argc, char** argv) {
	if(argc == 1)
		return fprintf(stderr, "%s [url..]\n", argv[0]);
	client* head = parse_command_line(argc, argv);
	if(!head)
		return EXIT_FAILURE;

	client *c = head;
	do { //loop through clients opening files and sending syns
		c-&gt;fd = socket(AF_INET, SOCK_STREAM, 0);
		if(c-&gt;fd &lt; 0)
			return fprintf(stderr, "socket(): %s\n", strerror(errno));

		c-&gt;len = sprintf(c-&gt;buf, format, c-&gt;url.file, c-&gt;url.host);

		//lookup host
		struct hostent* he = gethostbyname(c-&gt;url.host);
		if(he == NULL)
			return fprintf(stderr, "gethostbyname(): &lt;%s&gt; %s\n", c-&gt;url.host, strerror(errno));

		//set nonblocking
		int arg = fcntl(c-&gt;fd, F_GETFL, NULL); 
		arg |= O_NONBLOCK; 
		fcntl(c-&gt;fd, F_SETFL, arg);

		struct sockaddr_in address;
		address.sin_family = AF_INET;
		address.sin_port = htons(c-&gt;url.port);
		address.sin_addr.s_addr = ((struct in_addr*)he-&gt;h_addr)-&gt;s_addr;

		//start the connect sequence
		errno = 0;
		if(connect(c-&gt;fd, (struct sockaddr*)&amp;address, sizeof(struct sockaddr)) &gt; 0)
			return fprintf(stderr, "connect returned unexpected\n");
		gettimeofday(&amp;c-&gt;tv, NULL);
		printf(" |    connecting to %s...\n", c-&gt;url.host);

		if(errno != EINPROGRESS)
			return fprintf(stderr, "unexpected: %s\n", strerror(errno));

		c = c-&gt;next;
	} while(c);


	while(head) {

		int maxfd = 0;
		#define update_fd(x) maxfd = (maxfd &gt; x ? maxfd : x)

		fd_set rset, wset;
		FD_ZERO(&amp;rset);
		FD_ZERO(&amp;wset);

		//fill up fd sets
		client* s = head;
		do {

			switch(s-&gt;status) {
				case 0: { //need to connect
					FD_SET(s-&gt;fd, &amp;wset);
					update_fd(s-&gt;fd);
				} break;
				case 1: { //need to send data
					FD_SET(s-&gt;fd, &amp;wset);
					update_fd(s-&gt;fd);
				} break;
				case 2: { //need to recv data
					FD_SET(s-&gt;fd, &amp;rset);
					update_fd(s-&gt;fd);
				} break;
				default:
					return fprintf(stderr, "unexpected status l:%d &lt;%d&gt;\n", __LINE__, s-&gt;status);
			}

			s = s-&gt;next;
		} while(s);


		if(select(maxfd + 1, &amp;rset, &amp;wset, NULL, NULL) &lt; 0)
			return fprintf(stderr, "select(): %s\n", strerror(errno));


		//process fds
		client* h = head;
		client* t = NULL;
		client* prev = NULL;
		do {

			switch(h-&gt;status) {
				case 0: { //need to connect
					if(!FD_ISSET(h-&gt;fd, &amp;wset)) //connected
						break;
					struct timeval tv;
					gettimeofday(&amp;tv, NULL);
					printf(" ||   connected to %s in %d secs, %u usecs\n",
						h-&gt;url.host, tv.tv_sec - h-&gt;tv.tv_sec, tv.tv_usec - h-&gt;tv.tv_usec);
					gettimeofday(&amp;h-&gt;tv, NULL);
					h-&gt;status++;

				} break;
				case 1: { //need to send

					if(!FD_ISSET(h-&gt;fd, &amp;wset))
						break;
					int r = send(h-&gt;fd, h-&gt;buf + h-&gt;pos, h-&gt;len - h-&gt;pos, 0);
					if(r &lt; 1)
						return fprintf(stderr, "send(): %s\n", strerror(errno));
					h-&gt;pos += r;

					if(h-&gt;pos == h-&gt;len) {//sent all the data
						struct timeval tv;
						gettimeofday(&amp;tv, NULL);
						printf(" |||  sent all data to %s in %d secs, %u usecs\n",
							h-&gt;url.host, tv.tv_sec - h-&gt;tv.tv_sec, tv.tv_usec - h-&gt;tv.tv_usec);
						gettimeofday(&amp;h-&gt;tv, NULL);

						h-&gt;status++;
						h-&gt;output = fopen(make_file_name(&amp;h-&gt;url), "wb");
						if(!h-&gt;output)
							return fprintf(stderr, "fopen(): %s\n", strerror(errno));
					}
				} break;
				case 2: { //need to recv
					if(!FD_ISSET(h-&gt;fd, &amp;rset))
						break;
					char buffer[1024];
					errno = 0;
					int r = recv(h-&gt;fd, buffer, sizeof(buffer), 0);
					if(r &lt; 1) { //eof or error
						if(errno) 
							return fprintf(stderr, "recv(): %s\n", strerror(errno));

						struct timeval tv;
						gettimeofday(&amp;tv, NULL);
						printf(" |||| recv'd all data from %s in %d secs, %u usecs\n",
							h-&gt;url.host, tv.tv_sec - h-&gt;tv.tv_sec, tv.tv_usec - h-&gt;tv.tv_usec);
						fclose(h-&gt;output);
						close(h-&gt;fd);

						if(prev)
							prev-&gt;next = h-&gt;next; //not the head
						else
						if(h-&gt;next)
							head = h-&gt;next; //the head, but not the last element
						else
							head = NULL;//the head, also the last element
						t = h-&gt;next;
						free(h);
						h = NULL;
						break;
					}

					fwrite(buffer, 1, r, h-&gt;output);
				} break;
				default:
					return fprintf(stderr, "unexpected status l:%d &lt;%d&gt;\n", __LINE__, s-&gt;status);
			}

			if(h) {
				prev = h; //if this element was freed
				h = h-&gt;next;
			} else {
				h = t;
			}
		} while(h);
	}

	printf("** finished all jobs\n");
	return EXIT_SUCCESS;
}
</code></pre>
<p>post criticism</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/loads-of-http-at-once/241850/1</link>
        <pubDate>Fri, 07 Nov 2008 19:54:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-241850-1</guid>
        <source url="https://forum.moparisthebest.com/t/loads-of-http-at-once/241850.rss">Loads of http at once</source>
      </item>
  </channel>
</rss>
