<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Riotscape/Project Insanity [NPC] Cheap way clip fix</title>
    <link>https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003</link>
    <description>NOTE WARNING WHATEVER: THIS IS NOT FULLY DONE AND THIS HAS A BUNCH OF SPOTS WHERE IT IS NOT CLIPPED. YOU CAN STILL ATTACK AND BE ATTACKED THROUGH DOORS AND WALLS. THIS IS JUST A CHEAP WAY IF YOU DONT WANT THEM MOVING THROUGH WALLS (although they do sometimes i tested)

Im not using it right now, i just released for newbs who cant think... and this is a HORRIBLE way of doing it. Don&#39;t ask me for help, im not using it I just tested and saw its not good.

STEP 1: go to server.world

replace your worldmap.java with this:

[CODE]package server.world;

import java.io.RandomAccessFile;
import java.util.HashMap;
import java.util.Hashtable;
import server.util.Misc;

public final class WorldMap {

	public static Hashtable&lt;Integer, GameObject&gt; gameObjects = new Hashtable&lt;Integer, GameObject&gt;();
	public static boolean solidObjectExists(int x, int y) {
		GameObject go = gameObjects.get(y + (x &lt;&lt; 16));
		if (go != null &amp;&amp; go.type() == 2 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
			return true;
		}
		if (go != null &amp;&amp; go.type() == 10 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
			return true;
		}
		if (go != null &amp;&amp; go.type() == 9 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
			return true;
		}
		if (go != null &amp;&amp; go.type() == 8 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
			return true;
		}
		if (go != null &amp;&amp; go.type() == 7 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
			return true;
		}
		if (go != null &amp;&amp; go.type() == 4 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
			return true;
		}
		return false;
	}

	public static boolean canMove(int baseX, int baseY, int toX, int toY) {
		int diffX = baseX - toX;
		int diffY = baseY - toY;
		int moveX = 0;
		int moveY = 0;
		if (diffX &lt; 0) {
			moveX = 1;
		} else if (diffX &gt; 0) {
			moveX = -1;
		}
		if (diffY &lt; 0) {
			moveY = 1;
		} else if (diffY &gt; 0) {
			moveY = -1;
		}
		if (moveX &gt; 0 &amp;&amp; moveY &gt; 0) {
			if (solidObjectExists(baseX + 1, baseY + 1)
					|| solidObjectExists(baseX + 1, baseY)
					|| solidObjectExists(baseX, baseY + 1)) {
				return false;
			}
		} else if (moveX &lt; 0 &amp;&amp; moveY &lt; 0) {
			if (solidObjectExists(baseX - 1, baseY - 1)
					|| solidObjectExists(baseX - 1, baseY)
					|| solidObjectExists(baseX, baseY - 1)) {
				return false;
			}
		} else if (moveX &gt; 0 &amp;&amp; moveY &lt; 0) {
			if (solidObjectExists(baseX + 1, baseY - 1)
					|| solidObjectExists(baseX + 1, baseY)
					|| solidObjectExists(baseX, baseY - 1)) {
				return false;
			}
		} else if (moveX &lt; 0 &amp;&amp; moveY &gt; 0) {
			if (solidObjectExists(baseX - 1, baseY + 1)
					|| solidObjectExists(baseX - 1, baseY)
					|| solidObjectExists(baseX, baseY + 1)) {
				return false;
			}
		} else if (moveX &lt; 0 &amp;&amp; moveY == 0) {
			if (solidObjectExists(baseX - 1, baseY)) {
				return false;
			}
		} else if (moveX &gt; 0 &amp;&amp; moveY == 0) {
			if (solidObjectExists(baseX + 1, baseY)) {
				return false;
			}
		} else if (moveX == 0 &amp;&amp; moveY &lt; 0) {
			if (solidObjectExists(baseX, baseY - 1)) {
				return false;
			}
		} else if (moveX == 0 &amp;&amp; moveY &gt; 0) {
			if (solidObjectExists(baseX, baseY + 1)) {
				return false;
			}
		}
		return true;
	}

	public static final int maxObjects = 2000000;
	public static int[] objectId = new int [maxObjects];
   public static int[] objectX = new int [maxObjects];
   public static int[] objectY = new int [maxObjects];
   public static int[] objectHeight = new int [maxObjects];
   public static int[] objectType = new int [maxObjects];
   public static int[] objectFace = new int [maxObjects];

	public static boolean isWalkAble(int height, int absX, int absY, int toAbsX, int toAbsY) {
      if (absX == toAbsX &amp;&amp; absY == toAbsY) return true;
      int direction1 = getDirection(absX, absY, toAbsX, toAbsY);
      int direction2 = getOppositeDirection(absX, absY, toAbsX, toAbsY);
      if (direction1 == -1 || direction2 == -1) {
         Misc.println(&quot;Direction Bug from(&quot; + absX + &quot;,&quot; + absY + &quot;) to (&quot; + toAbsX + &quot;,&quot; + toAbsY + &quot;) Height(&quot; + height + &quot;) abs(&quot; + toAbsX + &quot;,&quot; + toAbsY + &quot;)&quot;);
         return false;
      }
      for (int i = 0; i &lt; maxObjects; i++) {
        if (objectId[i] == -1) continue;
         if (objectHeight[i] != height) continue;
         if (objectType[i] == 22) continue;
         if (objectX[i] == toAbsX &amp;&amp; objectY[i] == toAbsY &amp;&amp; height == objectHeight[i]) 
		return false;

	  }
	  return true;
   }

    	public static int getOppositeDirection(int absX, int absY, int toAbsX, int toAbsY) {
// we must reverse direction, walking north will require object to stand south
      if ((absX - 1) == toAbsX &amp;&amp; absY == toAbsY) return 2;
      if ((absX + 1) == toAbsX &amp;&amp; absY == toAbsY) return 0;
      if (absX == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 1;
      if (absX == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 3;
      if ((absX - 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 11;
      if ((absX + 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 10;
      if ((absX - 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 8;
      if ((absX + 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 9;
	  if (absY == toAbsY &amp;&amp; (absX - 1) == toAbsX) return 12;
      if (absY == toAbsY &amp;&amp; (absX + 1) == toAbsX) return 13;
      return -1;
   }

	public static int getDirection(int absX, int absY, int toAbsX, int toAbsY) {
// we must reverse direction, walking north will require object to stand south
      if ((absX - 1) == toAbsX &amp;&amp; absY == toAbsY) return 0;
      if ((absX + 1) == toAbsX &amp;&amp; absY == toAbsY) return 2;
      if (absX == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 3;
      if (absX == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 1;
      if ((absX - 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 9;
      if ((absX + 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 8;
      if ((absX - 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 10;
      if ((absX + 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 11;
	  if (absY == toAbsY &amp;&amp; (absX - 1) == toAbsX) return 12;
      if (absY == toAbsY &amp;&amp; (absX + 1) == toAbsX) return 13;
      return -1;
   }



	@SuppressWarnings(&quot;unused&quot;)
	public static void loadWorldMap() {
		try {
			RandomAccessFile in = null;
			byte[] cache = null;
			int ptr = 0;
			long a = System.currentTimeMillis();
			in = new RandomAccessFile(&quot;./Data/worldmap.bin&quot;, &quot;r&quot;);
			cache = new byte[(int) in.length()];
			in.read(cache, 0, (int) in.length());
			in.close();
			for (int i = 0; i &lt; 1280618; i++/* ,j++ */) {
				int objectId = (((cache[ptr++] &amp; 0xFF) &lt;&lt; 8) | (cache[ptr++] &amp; 0xFF));
				int objectX = (((cache[ptr++] &amp; 0xFF) &lt;&lt; 8) | (cache[ptr++] &amp; 0xFF));
				int objectY = (((cache[ptr++] &amp; 0xFF) &lt;&lt; 8) | (cache[ptr++] &amp; 0xFF));
				int objectHeight = cache[ptr++] &amp; 0xFF;
				int objectType = cache[ptr++] &amp; 0xFF;
				int objectFace = cache[ptr++] &amp; 0xFF;
				GameObject go = new GameObject(objectId, objectType, objectX, objectY, objectFace);
				if (go.type() != 0) {
					gameObjects.put(go.y() + (go.x() &lt;&lt; 16), go);
				}
			}
			long took = System.currentTimeMillis() - a;
			System.out.println(&quot;Loaded &quot; + gameObjects.size() + &quot; clips.&quot;);
			System.out.println(&quot;Loaded WorldMap In (&quot; + took + &quot; ms)... &quot;);
		} catch (Exception e2) {
			e2.printStackTrace();
		}
	}
	
	public static final HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
	
}[/CODE]

EXPLANATION: This file makes it so the file can be read for solid non-moving objects and let the NPC pass through or not if a object is blocking it. 

public static void loadWorldMap() {
That loads the mapdata so it can dump the objects and find them.

public static int getDirection(int absX, int absY, int toAbsX, int toAbsY) {
This will make it so walking south the object must be facing north

public static int getOppositeDirection(int absX, int absY, int toAbsX, int toAbsY) {
This sets it so walking north the object must be facing south

Step 2: Go to server.model.npcs.NpcHandler.java

add at the top:
import server.world.WorldMap;

now find this:
public void followPlayer(int i, int playerId) {

replace that WHOLE METHOD with this:
[CODE]public void followPlayer(int i, int playerId) {
		if (Server.playerHandler.players[playerId] == null) {
			return;
		}
		if (Server.playerHandler.players[playerId].respawnTimer &gt; 0) {
			npcs[i].facePlayer(0);
			npcs[i].randomWalk = true; 
	      	npcs[i].underAttack = false;	
			return;
		}
		
		if (!followPlayer(i)) {
			npcs[i].facePlayer(playerId);
			return;
		}
		
		int playerX = Server.playerHandler.players[playerId].absX;
		int playerY = Server.playerHandler.players[playerId].absY;
		boolean canwalk = true;
		npcs[i].randomWalk = false;
		if (goodDistance(npcs[i].getX(), npcs[i].getY(), playerX, playerY, distanceRequired(i)))
			return;
		if((npcs[i].spawnedBy &gt; 0) || ((npcs[i].absX &lt; npcs[i].makeX + Config.NPC_FOLLOW_DISTANCE) &amp;&amp; (npcs[i].absX &gt; npcs[i].makeX - Config.NPC_FOLLOW_DISTANCE) &amp;&amp; (npcs[i].absY &lt; npcs[i].makeY + Config.NPC_FOLLOW_DISTANCE) &amp;&amp; (npcs[i].absY &gt; npcs[i].makeY - Config.NPC_FOLLOW_DISTANCE))) {
			if(npcs[i].heightLevel == Server.playerHandler.players[playerId].heightLevel) {
				if(Server.playerHandler.players[playerId] != null &amp;&amp; npcs[i] != null) {
					if(playerY &lt; npcs[i].absY) {
						npcs[i].moveX = GetMove(npcs[i].absX, playerX);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY);
					} else if(playerY &gt; npcs[i].absY) {
						npcs[i].moveX = GetMove(npcs[i].absX, playerX);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY);
					} else if(playerX &lt; npcs[i].absX) {
						npcs[i].moveX = GetMove(npcs[i].absX, playerX);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY);
					} else if(playerX &gt; npcs[i].absX)  {
						npcs[i].moveX = GetMove(npcs[i].absX, playerX);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY);
					} else if(playerX == npcs[i].absX || playerY == npcs[i].absY) {
						int o = Misc.random(3);
						switch(o) {
							case 0:
							npcs[i].moveX = GetMove(npcs[i].absX, playerX);
							npcs[i].moveY = GetMove(npcs[i].absY, playerY+1);
							if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
				canwalk = false;
							break;
							
							case 1:
							npcs[i].moveX = GetMove(npcs[i].absX, playerX);
							npcs[i].moveY = GetMove(npcs[i].absY, playerY-1);
							if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
				canwalk = false;
							break;
							
							case 2:
							npcs[i].moveX = GetMove(npcs[i].absX, playerX+1);
							npcs[i].moveY = GetMove(npcs[i].absY, playerY);
							if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
				canwalk = false;
							break;
							
							case 3:
							npcs[i].moveX = GetMove(npcs[i].absX, playerX-1);
							npcs[i].moveY = GetMove(npcs[i].absY, playerY);
							if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
				canwalk = false;
							break;
						}	
					}
					int x = (npcs[i].absX + npcs[i].moveX);
					int y = (npcs[i].absY + npcs[i].moveY);
					npcs[i].facePlayer(playerId);
					if(canwalk == true)
			npcs[i].getNextNPCMovement(i);
			npcs[i].updateRequired = true;
					if (checkClipping(i))
						npcs[i].getNextNPCMovement(i);
					else {
						npcs[i].moveX = 0;
						npcs[i].moveY = 0;
					}
					npcs[i].facePlayer(playerId);
			      	npcs[i].updateRequired = true;
				}	
			}
		} else {
			npcs[i].facePlayer(0);
			npcs[i].randomWalk = true; 
		   	npcs[i].underAttack = false;	
		}
	}[/CODE]

EXPLAINATION: [CODE]if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
				canwalk = false;[/CODE]

This makes it so if there is an object and the npc is in north or south it cant walk through it.

This makes it so following and walking is clipped not passing through objects ect.


Step 3 and final:
go to Server.java
its located at Server

and add this at top with rest of imports
import server.world.WorldMap;

find: [CODE]//public static WorldMap worldMap = new WorldMap();[/CODE]
replace with: [CODE]public static WorldMap worldMap = new WorldMap();[/CODE]

now find: [CODE]//VirtualWorld.init();[/CODE]
and the surrounding code replace with (if u use low mem):
[CODE]//if(!Config.SERVER_DEBUG)
			//VirtualWorld.init();
		WorldMap.loadWorldMap();[/CODE]

or else (use high JVM):
[CODE]if(!Config.SERVER_DEBUG)
			VirtualWorld.init();
		WorldMap.loadWorldMap();[/CODE]

EXPLAINATION: This makes it so when the server starts it loads the worldmaps, dumps the objects, gets the clipped spots. The higher JVM gets more clipped spots, but it uses a lot of memory.

There you go you have ur cheap way of npc clipped. This does not work good at all.... 


Have fun trying to fix it.


Credits:
Martin
sanity
mj2000
me</description>
    
    <lastBuildDate>Fri, 28 May 2010 21:06:40 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Riotscape/Project Insanity [NPC] Cheap way clip fix</title>
        <dc:creator><![CDATA[@insanepk insanepk]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/insanepk">@insanepk</a> wrote:</p>
          <blockquote>
              <p>Good work (y)</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/5</link>
        <pubDate>Fri, 28 May 2010 21:06:40 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-340003-5</guid>
        <source url="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003.rss">Riotscape/Project Insanity [NPC] Cheap way clip fix</source>
      </item>
      <item>
        <title>Riotscape/Project Insanity [NPC] Cheap way clip fix</title>
        <dc:creator><![CDATA[@Mod_Whip Mod Whip]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_whip">@Mod_Whip</a> wrote:</p>
          <blockquote>
              <p>seems like it would work, im not a huge fan of riotscape/project insanity personally though.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/4</link>
        <pubDate>Mon, 17 May 2010 22:18:38 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-340003-4</guid>
        <source url="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003.rss">Riotscape/Project Insanity [NPC] Cheap way clip fix</source>
      </item>
      <item>
        <title>Riotscape/Project Insanity [NPC] Cheap way clip fix</title>
        <dc:creator><![CDATA[@Pouch Pouch]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/pouch">@Pouch</a> wrote:</p>
          <blockquote>
              <p>I explained it with careful detail as the main ones are explained.</p>
<p>It is one of the only bases that is done for you… Use it and work on it, it works so do the rest on your own unless you want to make npc clipped base for project insanity/riotscape</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/3</link>
        <pubDate>Fri, 14 May 2010 02:11:54 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-340003-3</guid>
        <source url="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003.rss">Riotscape/Project Insanity [NPC] Cheap way clip fix</source>
      </item>
      <item>
        <title>Riotscape/Project Insanity [NPC] Cheap way clip fix</title>
        <dc:creator><![CDATA[@deathschaos9 DeathsChaos9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/deathschaos9">@deathschaos9</a> wrote:</p>
          <blockquote>
              <blockquote>Any code snippets provided have been thoroughly explained with careful detail.</blockquote>
<p>Explain the code or it will probably be locked. If its a horrible way of doing it why post…?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/2</link>
        <pubDate>Fri, 14 May 2010 01:40:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-340003-2</guid>
        <source url="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003.rss">Riotscape/Project Insanity [NPC] Cheap way clip fix</source>
      </item>
      <item>
        <title>Riotscape/Project Insanity [NPC] Cheap way clip fix</title>
        <dc:creator><![CDATA[@Pouch Pouch]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/pouch">@Pouch</a> wrote:</p>
          <blockquote>
              <p>NOTE WARNING WHATEVER: THIS IS NOT FULLY DONE AND THIS HAS A BUNCH OF SPOTS WHERE IT IS NOT CLIPPED. YOU CAN STILL ATTACK AND BE ATTACKED THROUGH DOORS AND WALLS. THIS IS JUST A CHEAP WAY IF YOU DONT WANT THEM MOVING THROUGH WALLS (although they do sometimes i tested)</p>
<p>Im not using it right now, i just released for newbs who cant think… and this is a HORRIBLE way of doing it. Don’t ask me for help, im not using it I just tested and saw its not good.</p>
<p>STEP 1: go to server.world</p>
<p>replace your worldmap.java with this:</p>
<p>[CODE]package server.world;</p>
<p>import java.io.RandomAccessFile;<br>
import java.util.HashMap;<br>
import java.util.Hashtable;<br>
import server.util.Misc;</p>
<p>public final class WorldMap {</p>
<pre><code>public static Hashtable&lt;Integer, GameObject&gt; gameObjects = new Hashtable&lt;Integer, GameObject&gt;();
public static boolean solidObjectExists(int x, int y) {
	GameObject go = gameObjects.get(y + (x &lt;&lt; 16));
	if (go != null &amp;&amp; go.type() == 2 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
		return true;
	}
	if (go != null &amp;&amp; go.type() == 10 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
		return true;
	}
	if (go != null &amp;&amp; go.type() == 9 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
		return true;
	}
	if (go != null &amp;&amp; go.type() == 8 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
		return true;
	}
	if (go != null &amp;&amp; go.type() == 7 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
		return true;
	}
	if (go != null &amp;&amp; go.type() == 4 &amp;&amp; go.x() == x &amp;&amp; go.y() == y) {
		return true;
	}
	return false;
}

public static boolean canMove(int baseX, int baseY, int toX, int toY) {
	int diffX = baseX - toX;
	int diffY = baseY - toY;
	int moveX = 0;
	int moveY = 0;
	if (diffX &lt; 0) {
		moveX = 1;
	} else if (diffX &gt; 0) {
		moveX = -1;
	}
	if (diffY &lt; 0) {
		moveY = 1;
	} else if (diffY &gt; 0) {
		moveY = -1;
	}
	if (moveX &gt; 0 &amp;&amp; moveY &gt; 0) {
		if (solidObjectExists(baseX + 1, baseY + 1)
				|| solidObjectExists(baseX + 1, baseY)
				|| solidObjectExists(baseX, baseY + 1)) {
			return false;
		}
	} else if (moveX &lt; 0 &amp;&amp; moveY &lt; 0) {
		if (solidObjectExists(baseX - 1, baseY - 1)
				|| solidObjectExists(baseX - 1, baseY)
				|| solidObjectExists(baseX, baseY - 1)) {
			return false;
		}
	} else if (moveX &gt; 0 &amp;&amp; moveY &lt; 0) {
		if (solidObjectExists(baseX + 1, baseY - 1)
				|| solidObjectExists(baseX + 1, baseY)
				|| solidObjectExists(baseX, baseY - 1)) {
			return false;
		}
	} else if (moveX &lt; 0 &amp;&amp; moveY &gt; 0) {
		if (solidObjectExists(baseX - 1, baseY + 1)
				|| solidObjectExists(baseX - 1, baseY)
				|| solidObjectExists(baseX, baseY + 1)) {
			return false;
		}
	} else if (moveX &lt; 0 &amp;&amp; moveY == 0) {
		if (solidObjectExists(baseX - 1, baseY)) {
			return false;
		}
	} else if (moveX &gt; 0 &amp;&amp; moveY == 0) {
		if (solidObjectExists(baseX + 1, baseY)) {
			return false;
		}
	} else if (moveX == 0 &amp;&amp; moveY &lt; 0) {
		if (solidObjectExists(baseX, baseY - 1)) {
			return false;
		}
	} else if (moveX == 0 &amp;&amp; moveY &gt; 0) {
		if (solidObjectExists(baseX, baseY + 1)) {
			return false;
		}
	}
	return true;
}

public static final int maxObjects = 2000000;
public static int[] objectId = new int [maxObjects];
</code></pre>
<p>public static int[] objectX = new int [maxObjects];<br>
public static int[] objectY = new int [maxObjects];<br>
public static int[] objectHeight = new int [maxObjects];<br>
public static int[] objectType = new int [maxObjects];<br>
public static int[] objectFace = new int [maxObjects];</p>
<pre><code>public static boolean isWalkAble(int height, int absX, int absY, int toAbsX, int toAbsY) {
  if (absX == toAbsX &amp;&amp; absY == toAbsY) return true;
  int direction1 = getDirection(absX, absY, toAbsX, toAbsY);
  int direction2 = getOppositeDirection(absX, absY, toAbsX, toAbsY);
  if (direction1 == -1 || direction2 == -1) {
     Misc.println("Direction Bug from(" + absX + "," + absY + ") to (" + toAbsX + "," + toAbsY + ") Height(" + height + ") abs(" + toAbsX + "," + toAbsY + ")");
     return false;
  }
  for (int i = 0; i &lt; maxObjects; i++) {
    if (objectId[i] == -1) continue;
     if (objectHeight[i] != height) continue;
     if (objectType[i] == 22) continue;
     if (objectX[i] == toAbsX &amp;&amp; objectY[i] == toAbsY &amp;&amp; height == objectHeight[i]) 
	return false;

  }
  return true;
</code></pre>
<p>}</p>
<pre><code>	public static int getOppositeDirection(int absX, int absY, int toAbsX, int toAbsY) {
</code></pre>
<p>// we must reverse direction, walking north will require object to stand south<br>
if ((absX - 1) == toAbsX &amp;&amp; absY == toAbsY) return 2;<br>
if ((absX + 1) == toAbsX &amp;&amp; absY == toAbsY) return 0;<br>
if (absX == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 1;<br>
if (absX == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 3;<br>
if ((absX - 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 11;<br>
if ((absX + 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 10;<br>
if ((absX - 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 8;<br>
if ((absX + 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 9;<br>
if (absY == toAbsY &amp;&amp; (absX - 1) == toAbsX) return 12;<br>
if (absY == toAbsY &amp;&amp; (absX + 1) == toAbsX) return 13;<br>
return -1;<br>
}</p>
<pre><code>public static int getDirection(int absX, int absY, int toAbsX, int toAbsY) {
</code></pre>
<p>// we must reverse direction, walking north will require object to stand south<br>
if ((absX - 1) == toAbsX &amp;&amp; absY == toAbsY) return 0;<br>
if ((absX + 1) == toAbsX &amp;&amp; absY == toAbsY) return 2;<br>
if (absX == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 3;<br>
if (absX == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 1;<br>
if ((absX - 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 9;<br>
if ((absX + 1) == toAbsX &amp;&amp; (absY - 1) == toAbsY) return 8;<br>
if ((absX - 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 10;<br>
if ((absX + 1) == toAbsX &amp;&amp; (absY + 1) == toAbsY) return 11;<br>
if (absY == toAbsY &amp;&amp; (absX - 1) == toAbsX) return 12;<br>
if (absY == toAbsY &amp;&amp; (absX + 1) == toAbsX) return 13;<br>
return -1;<br>
}</p>
<pre><code>@SuppressWarnings("unused")
public static void loadWorldMap() {
	try {
		RandomAccessFile in = null;
		byte[] cache = null;
		int ptr = 0;
		long a = System.currentTimeMillis();
		in = new RandomAccessFile("./Data/worldmap.bin", "r");
		cache = new byte[(int) in.length()];
		in.read(cache, 0, (int) in.length());
		in.close();
		for (int i = 0; i &lt; 1280618; i++/* ,j++ */) {
			int objectId = (((cache[ptr++] &amp; 0xFF) &lt;&lt; 8) | (cache[ptr++] &amp; 0xFF));
			int objectX = (((cache[ptr++] &amp; 0xFF) &lt;&lt; 8) | (cache[ptr++] &amp; 0xFF));
			int objectY = (((cache[ptr++] &amp; 0xFF) &lt;&lt; 8) | (cache[ptr++] &amp; 0xFF));
			int objectHeight = cache[ptr++] &amp; 0xFF;
			int objectType = cache[ptr++] &amp; 0xFF;
			int objectFace = cache[ptr++] &amp; 0xFF;
			GameObject go = new GameObject(objectId, objectType, objectX, objectY, objectFace);
			if (go.type() != 0) {
				gameObjects.put(go.y() + (go.x() &lt;&lt; 16), go);
			}
		}
		long took = System.currentTimeMillis() - a;
		System.out.println("Loaded " + gameObjects.size() + " clips.");
		System.out.println("Loaded WorldMap In (" + took + " ms)... ");
	} catch (Exception e2) {
		e2.printStackTrace();
	}
}

public static final HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
</code></pre>
<p>}[/CODE]</p>
<p>EXPLANATION: This file makes it so the file can be read for solid non-moving objects and let the NPC pass through or not if a object is blocking it.</p>
<p>public static void loadWorldMap() {<br>
That loads the mapdata so it can dump the objects and find them.</p>
<p>public static int getDirection(int absX, int absY, int toAbsX, int toAbsY) {<br>
This will make it so walking south the object must be facing north</p>
<p>public static int getOppositeDirection(int absX, int absY, int toAbsX, int toAbsY) {<br>
This sets it so walking north the object must be facing south</p>
<p>Step 2: Go to server.model.npcs.NpcHandler.java</p>
<p>add at the top:<br>
import server.world.WorldMap;</p>
<p>now find this:<br>
public void followPlayer(int i, int playerId) {</p>
<p>replace that WHOLE METHOD with this:</p>
<p>[CODE]public void followPlayer(int i, int playerId) {<br>
if (Server.playerHandler.players[playerId] == null) {<br>
return;<br>
}<br>
if (Server.playerHandler.players[playerId].respawnTimer &gt; 0) {<br>
npcs[i].facePlayer(0);<br>
npcs[i].randomWalk = true;<br>
npcs[i].underAttack = false;	<br>
return;<br>
}</p>
<pre><code>	if (!followPlayer(i)) {
		npcs[i].facePlayer(playerId);
		return;
	}
	
	int playerX = Server.playerHandler.players[playerId].absX;
	int playerY = Server.playerHandler.players[playerId].absY;
	boolean canwalk = true;
	npcs[i].randomWalk = false;
	if (goodDistance(npcs[i].getX(), npcs[i].getY(), playerX, playerY, distanceRequired(i)))
		return;
	if((npcs[i].spawnedBy &gt; 0) || ((npcs[i].absX &lt; npcs[i].makeX + Config.NPC_FOLLOW_DISTANCE) &amp;&amp; (npcs[i].absX &gt; npcs[i].makeX - Config.NPC_FOLLOW_DISTANCE) &amp;&amp; (npcs[i].absY &lt; npcs[i].makeY + Config.NPC_FOLLOW_DISTANCE) &amp;&amp; (npcs[i].absY &gt; npcs[i].makeY - Config.NPC_FOLLOW_DISTANCE))) {
		if(npcs[i].heightLevel == Server.playerHandler.players[playerId].heightLevel) {
			if(Server.playerHandler.players[playerId] != null &amp;&amp; npcs[i] != null) {
				if(playerY &lt; npcs[i].absY) {
					npcs[i].moveX = GetMove(npcs[i].absX, playerX);
					npcs[i].moveY = GetMove(npcs[i].absY, playerY);
				} else if(playerY &gt; npcs[i].absY) {
					npcs[i].moveX = GetMove(npcs[i].absX, playerX);
					npcs[i].moveY = GetMove(npcs[i].absY, playerY);
				} else if(playerX &lt; npcs[i].absX) {
					npcs[i].moveX = GetMove(npcs[i].absX, playerX);
					npcs[i].moveY = GetMove(npcs[i].absY, playerY);
				} else if(playerX &gt; npcs[i].absX)  {
					npcs[i].moveX = GetMove(npcs[i].absX, playerX);
					npcs[i].moveY = GetMove(npcs[i].absY, playerY);
				} else if(playerX == npcs[i].absX || playerY == npcs[i].absY) {
					int o = Misc.random(3);
					switch(o) {
						case 0:
						npcs[i].moveX = GetMove(npcs[i].absX, playerX);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY+1);
						if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
			canwalk = false;
						break;
						
						case 1:
						npcs[i].moveX = GetMove(npcs[i].absX, playerX);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY-1);
						if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
			canwalk = false;
						break;
						
						case 2:
						npcs[i].moveX = GetMove(npcs[i].absX, playerX+1);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY);
						if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
			canwalk = false;
						break;
						
						case 3:
						npcs[i].moveX = GetMove(npcs[i].absX, playerX-1);
						npcs[i].moveY = GetMove(npcs[i].absY, playerY);
						if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
			canwalk = false;
						break;
					}	
				}
				int x = (npcs[i].absX + npcs[i].moveX);
				int y = (npcs[i].absY + npcs[i].moveY);
				npcs[i].facePlayer(playerId);
				if(canwalk == true)
		npcs[i].getNextNPCMovement(i);
		npcs[i].updateRequired = true;
				if (checkClipping(i))
					npcs[i].getNextNPCMovement(i);
				else {
					npcs[i].moveX = 0;
					npcs[i].moveY = 0;
				}
				npcs[i].facePlayer(playerId);
		      	npcs[i].updateRequired = true;
			}	
		}
	} else {
		npcs[i].facePlayer(0);
		npcs[i].randomWalk = true; 
	   	npcs[i].underAttack = false;	
	}
}[/CODE]
</code></pre>
<p>EXPLAINATION: <code>if(WorldMap.isWalkAble(npcs[i].heightLevel, npcs[i].absX, npcs[i].absY, npcs[i].absX, npcs[i].absY+npcs[i].moveY) == false)
				canwalk = false;</code></p>
<p>This makes it so if there is an object and the npc is in north or south it cant walk through it.</p>
<p>This makes it so following and walking is clipped not passing through objects ect.</p>
<p>Step 3 and final:<br>
go to Server.java<br>
its located at Server</p>
<p>and add this at top with rest of imports<br>
import server.world.WorldMap;</p>
<p>find: <code>//public static WorldMap worldMap = new WorldMap();</code><br>
replace with: <code>public static WorldMap worldMap = new WorldMap();</code></p>
<p>now find: <code>//VirtualWorld.init();</code><br>
and the surrounding code replace with (if u use low mem):</p>
<p><code>//if(!Config.SERVER_DEBUG)
			//VirtualWorld.init();
		WorldMap.loadWorldMap();</code></p>
<p>or else (use high JVM):</p>
<p><code>if(!Config.SERVER_DEBUG)
			VirtualWorld.init();
		WorldMap.loadWorldMap();</code></p>
<p>EXPLAINATION: This makes it so when the server starts it loads the worldmaps, dumps the objects, gets the clipped spots. The higher JVM gets more clipped spots, but it uses a lot of memory.</p>
<p>There you go you have ur cheap way of npc clipped. This does not work good at all…</p>
<p>Have fun trying to fix it.</p>
<p>Credits:<br>
Martin<br>
sanity<br>
mj2000<br>
me</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003/1</link>
        <pubDate>Fri, 14 May 2010 01:27:54 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-340003-1</guid>
        <source url="https://forum.moparisthebest.com/t/riotscape-project-insanity-npc-cheap-way-clip-fix/340003.rss">Riotscape/Project Insanity [NPC] Cheap way clip fix</source>
      </item>
  </channel>
</rss>
