<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>(Concept) Abstract entity updating</title>
    <link>https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088</link>
    <description>This is a concept/design idea that I recently had and decided to sketch out to see if it could work. Not only could it work, there&#39;s also some major performance optimizations that this system brings with it.

[b]What is abstract entity updating?[/b]

Well, on some servers you may have seen an efficient abstract combat system; where players and NPCs are treated alike in a single system that processes both.
This very same concept can be applied to the updating process. Players and NPCs have very similar updating processes, allowing for abstraction. To implement this feature on an existing server would require a major overhaul of the updating process, the Player and NPC classes and a few more, which I will discuss below.

[b]Why implement it?[/b]

This system means you will only have to loop through all the entities once per cycle and construct the player updating [i]and[/i] npc updating packet for a single player in one go. This saves CPU cycles. When combined with an efficient 2D lookup method (I highly suggest a quadtree, but morton codes are a good alternative albeit more tricky to implement but are way more effective), this allows you to drastically speed up the player updating process.

[b]How to make it work[/b]

First of all, you have to create either an interface or an abstract class to allow for abstraction. I am unsure if you can cast an interface to the class that implements the interface but I am sure this is the case with abstract classes, so here is one:

(demonstrational; doesn&#39;t work and isn&#39;t finished)
[code=java]public abstract class UpdatableEntity {

	...

}[/code]

The next thing you want to do is to make your Player and NPC classes extend this class, so they become a subclass of UpdatableEntity;

[code=java]public class Player extends UpdatableEntity {

	...

}[/code]

[code=java]public class NPC extends UpdatableEntity {

	...

}[/code]

Now you want to create a central system that stores both Players and NPCs (which can be done now because they both inherit the UpdatableEntity class), like so:

[code=java]ArrayList&lt;UpdatableEntity&gt; updatables = new ArrayList&lt;UpdatableEntity&gt;();
ArrayList&lt;NPC&gt; npcs = new ArrayList&lt;NPC&gt;();
ArrayList&lt;Player&gt; players = new ArrayList&lt;Player&gt;();[/code]
The reason you also have the [i]npcs[/i] and [i]players[/i] lists is because you want to access them when you have to. There is no need to fetch npcs+players if you only want to process the npcs and there is no need to fetch npcs+players if you only want to process the players. (example below)

The next part is optional but definately suggested. You&#39;ll want to create a 2D lookup mechanism, created with the updatable entities.
The reason for this is performance. For all the people currently owning a server, think of it this way: You&#39;re essentially storing all your players and all your npc&#39;s in a single list. It is very unlikely for your server to benefit from any of the performance increases by this system if you&#39;re going to use the standard way of searching entities in a given range.

I suggest using a [url=https://en.wikipedia.org/wiki/Quadtree]quadtree[/url] or [url=https://en.wikipedia.org/wiki/Z-order_curve]morton codes[/url].

The implementation would look like this:
[code=java]public void updatePlayers() {
	//create a quadtree to hold all the updatables
	QuadTree&lt;UpdatableEntity&gt; qtree = new QuadTree&lt;UpdatableEntity&gt;();
	for (UpdatableEntity e : updatables) {
		int x = e.getX();
		int y = e.getY();
		qtree.insert(e, x, y);
	}
	
	//update all the players
	for (Player p : players) { //this is why we still store npcs and players seperately
		Area area = new Area(p.getX()-15, p.getY()-15, p.getX()+16, p.getY()+16); //32x32 area
		
		//retrieve all the entities in the 32x32 area around the player
		UpdatableEntity[] results = qtree.retrieve(area);
		
		//construct the npc updating and player updating packets
		Packet npcUpdating = new Packet();
		Packet playerUpdating = new Packet();
		
		for (UpdatableEntity e : results) {
			if (e.isNPC()) {
				appendUpdates(npcUpdating, e);
			} else {
				appendUpdates(playerUpdating, e);
			}
		}
		p.sendPacket(npcUpdating);
		p.sendPacket(playerUpdating)
	}
}[/code]

I don&#39;t know if anyone came up with this or has something like this but I haven&#39;t seen it done before.

Also, thanks to Sini for explaining morton codes; I really learned a lot :D

Thank you for reading this and I hope it has given you some inspiration :)</description>
    
    <lastBuildDate>Tue, 29 Mar 2016 15:49:33 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>(Concept) Abstract entity updating</title>
        <dc:creator><![CDATA[@Cres Cres]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/cres">@Cres</a> wrote:</p>
          <blockquote>
              <p>Thanks</p>
<p>Working on implementing this on my server since I hadn’t touched player updating yet.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/4</link>
        <pubDate>Tue, 29 Mar 2016 15:49:33 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-555088-4</guid>
        <source url="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088.rss">(Concept) Abstract entity updating</source>
      </item>
      <item>
        <title>(Concept) Abstract entity updating</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p>Cool</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/3</link>
        <pubDate>Tue, 29 Mar 2016 15:24:03 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-555088-3</guid>
        <source url="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088.rss">(Concept) Abstract entity updating</source>
      </item>
      <item>
        <title>(Concept) Abstract entity updating</title>
        <dc:creator><![CDATA[@Fabrice_L Fabrice L]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/fabrice_l">@Fabrice_L</a> wrote:</p>
          <blockquote>
              <p>I’ll take a closer look at Quad trees and Morton code, I like experimenting with stuff I don’t know.</p>
<p>Looks nice btw</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/2</link>
        <pubDate>Tue, 29 Mar 2016 11:41:54 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-555088-2</guid>
        <source url="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088.rss">(Concept) Abstract entity updating</source>
      </item>
      <item>
        <title>(Concept) Abstract entity updating</title>
        <dc:creator><![CDATA[@Cres Cres]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/cres">@Cres</a> wrote:</p>
          <blockquote>
              <p>This is a concept/design idea that I recently had and decided to sketch out to see if it could work. Not only could it work, there’s also some major performance optimizations that this system brings with it.</p>
<p><span class="bbcode-b">What is abstract entity updating?</span></p>
<p>Well, on some servers you may have seen an efficient abstract combat system; where players and NPCs are treated alike in a single system that processes both.<br>
This very same concept can be applied to the updating process. Players and NPCs have very similar updating processes, allowing for abstraction. To implement this feature on an existing server would require a major overhaul of the updating process, the Player and NPC classes and a few more, which I will discuss below.</p>
<p><span class="bbcode-b">Why implement it?</span></p>
<p>This system means you will only have to loop through all the entities once per cycle and construct the player updating <span class="bbcode-i">and</span> npc updating packet for a single player in one go. This saves CPU cycles. When combined with an efficient 2D lookup method (I highly suggest a quadtree, but morton codes are a good alternative albeit more tricky to implement but are way more effective), this allows you to drastically speed up the player updating process.</p>
<p><span class="bbcode-b">How to make it work</span></p>
<p>First of all, you have to create either an interface or an abstract class to allow for abstraction. I am unsure if you can cast an interface to the class that implements the interface but I am sure this is the case with abstract classes, so here is one:</p>
<p>(demonstrational; doesn’t work and isn’t finished)</p>
<p>[code=java]public abstract class UpdatableEntity {</p>
<pre><code>...
</code></pre>
<p>}[/code]</p>
<p>The next thing you want to do is to make your Player and NPC classes extend this class, so they become a subclass of UpdatableEntity;</p>
<p>[code=java]public class Player extends UpdatableEntity {</p>
<pre><code>...
</code></pre>
<p>}[/code]</p>
<p>[code=java]public class NPC extends UpdatableEntity {</p>
<pre><code>...
</code></pre>
<p>}[/code]</p>
<p>Now you want to create a central system that stores both Players and NPCs (which can be done now because they both inherit the UpdatableEntity class), like so:</p>
<p><code>ArrayList&lt;UpdatableEntity&gt; updatables = new ArrayList&lt;UpdatableEntity&gt;();
ArrayList&lt;NPC&gt; npcs = new ArrayList&lt;NPC&gt;();
ArrayList&lt;Player&gt; players = new ArrayList&lt;Player&gt;();</code><br>
The reason you also have the <span class="bbcode-i">npcs</span> and <span class="bbcode-i">players</span> lists is because you want to access them when you have to. There is no need to fetch npcs+players if you only want to process the npcs and there is no need to fetch npcs+players if you only want to process the players. (example below)</p>
<p>The next part is optional but definately suggested. You’ll want to create a 2D lookup mechanism, created with the updatable entities.<br>
The reason for this is performance. For all the people currently owning a server, think of it this way: You’re essentially storing all your players and all your npc’s in a single list. It is very unlikely for your server to benefit from any of the performance increases by this system if you’re going to use the standard way of searching entities in a given range.</p>
<p>I suggest using a <a href="https://en.wikipedia.org/wiki/Quadtree" data-bbcode="true" rel="nofollow noopener">quadtree</a> or <a href="https://en.wikipedia.org/wiki/Z-order_curve" data-bbcode="true" rel="nofollow noopener">morton codes</a>.</p>
<p>The implementation would look like this:</p>
<p>[code=java]public void updatePlayers() {<br>
//create a quadtree to hold all the updatables<br>
QuadTree qtree = new QuadTree();<br>
for (UpdatableEntity e : updatables) {<br>
int x = e.getX();<br>
int y = e.getY();<br>
qtree.insert(e, x, y);<br>
}</p>
<pre><code>//update all the players
for (Player p : players) { //this is why we still store npcs and players seperately
	Area area = new Area(p.getX()-15, p.getY()-15, p.getX()+16, p.getY()+16); //32x32 area
	
	//retrieve all the entities in the 32x32 area around the player
	UpdatableEntity[] results = qtree.retrieve(area);
	
	//construct the npc updating and player updating packets
	Packet npcUpdating = new Packet();
	Packet playerUpdating = new Packet();
	
	for (UpdatableEntity e : results) {
		if (e.isNPC()) {
			appendUpdates(npcUpdating, e);
		} else {
			appendUpdates(playerUpdating, e);
		}
	}
	p.sendPacket(npcUpdating);
	p.sendPacket(playerUpdating)
}
</code></pre>
<p>}[/code]</p>
<p>I don’t know if anyone came up with this or has something like this but I haven’t seen it done before.</p>
<p>Also, thanks to Sini for explaining morton codes; I really learned a lot <img src="https://forum.moparisthebest.com/images/emoji/twitter/smiley.png?v=5" title=":smiley:" class="emoji" alt=":smiley:"></p>
<p>Thank you for reading this and I hope it has given you some inspiration <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088/1</link>
        <pubDate>Tue, 29 Mar 2016 01:43:36 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-555088-1</guid>
        <source url="https://forum.moparisthebest.com/t/concept-abstract-entity-updating/555088.rss">(Concept) Abstract entity updating</source>
      </item>
  </channel>
</rss>
