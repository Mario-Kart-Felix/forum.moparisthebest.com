<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Ruse Cache</title>
    <link>https://forum.moparisthebest.com/t/ruse-cache/553867</link>
    <description>Hey,

So what i&#39;ve tryed is editting the ruse cache to make a custom background, login box etc etc.
I dumped the sprites and editted the back ground to this (to see if it works):
[img]http://puu.sh/lp6c7/185ea3960b.jpg[/img]
Then packed the cache using this tool: Galkons Sprite Cache Editor
[img]http://puu.sh/lp6gx/26fcc31c6d.png[/img]
What am i missing? It still shows the regular client background. I&#39;ve compiled it just in case .. No errors when compiling/running.

What i did exactly:
1. 
[code=java]
/*
				File directory = new File(signlink.findcachedir() + &quot;dump&quot;); if
		(!directory.exists()) { directory.mkdir(); } FileOperations.WriteFile(directory.getAbsolutePath() +
				System.getProperty(&quot;file.separator&quot;) + sprite.id + &quot;.png&quot;,
				sprite.spriteData);
		
		*/
[/code]

Removed the outcomment signs so that code in SpriteLoader.java makes it dump the cache in a folder called dump in the cache itself.
2. Ran the client. It dumped the sprites just like i wanted
3. Editted the background and saved it. Copied the entire dump folder and threw it in the sprites folder (it did show the 944 sprites in the tool, so that worked)
[img]http://puu.sh/lp6ph/df6e422a15.png[/img]
4. Pressed write cache, was succesfull according to the tool.
5. Copied the sprites.dat and sprites.idx in the toolfolder after they updated to the cache
7. Commented the dump code back in
6. Compiled/run the client

What am i missing here? I can&#39;t add the client background as a .png in the cache, thats the whole reason i used that tool. Anyone knows?

THING WORTH LETTING YOU KNOW: In the dump folder the number of the client background file is: 594, however in the tool 594 isn&#39;t the client background. I didn&#39;t find the background in the tool but because it was the same amount of files i assumed it was alright.

Thanks

EDIT: I found a code in signlink.java that calls ruse.dat, so i changed the name of the .dat file to ruse, didn&#39;t work though. There are also 7 .idx files, but i only get 1 .dat and 1.idx file when packing the cache.
signlink.java
[code=java]
// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3)
// Source File Name:   signlink.java



import java.applet.Applet;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.net.InetAddress;
import java.net.Socket;
import java.net.URL;

import javax.sound.midi.MidiChannel;
import javax.sound.midi.MidiSystem;
import javax.sound.midi.MidiUnavailableException;
import javax.sound.midi.Sequence;
import javax.sound.midi.Sequencer;
import javax.sound.midi.ShortMessage;
import javax.sound.midi.Synthesizer;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.UnsupportedAudioFileException;

public final class signlink implements Runnable {

	public static void startpriv(InetAddress inetaddress) {
		threadliveid = (int) (Math.random() * 99999999D);
		if (active) {
			try {
				Thread.sleep(500L);
			} catch (Exception _ex) {
			}
			active = false;
		}
		socketreq = 0;
		threadreq = null;
		savereq = null;
		urlreq = null;
		socketip = inetaddress;
		Thread thread = new Thread(new signlink());
		thread.setDaemon(true);
		thread.start();
		while (!active)
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}
	}

	enum Position {
		LEFT, RIGHT, NORMAL
	};

	private final int EXTERNAL_BUFFER_SIZE = 524288; // 128Kb
	private Position curPosition;

	public void run() {
		active = true;
		String s = findcachedir();
		try {
			cache_dat = new RandomAccessFile(s + &quot;ruse.dat&quot;, &quot;rw&quot;);
			for (int j = 0; j &lt; 7; j++) {
				cache_idx[j] = new RandomAccessFile(s + &quot;ruse.idx&quot; + j, &quot;rw&quot;);
			}
		} catch (Exception exception) {
			exception.printStackTrace();
		}
		for (int i = threadliveid; threadliveid == i;) {
			if (socketreq != 0) {
				try {
					socket = new Socket(socketip, socketreq);
				} catch (Exception _ex) {
					socket = null;
				}
				socketreq = 0;
			} else if (threadreq != null) {
				Thread thread = new Thread(threadreq);
				thread.setDaemon(true);
				thread.start();
				thread.setPriority(threadreqpri);
				threadreq = null;
			} else if (savereq != null) {
				if (savebuf != null)
					try {
						FileOutputStream fileoutputstream = new FileOutputStream(s + savereq);
						fileoutputstream.write(savebuf, 0, savelen);
						fileoutputstream.close();
					} catch (Exception _ex) {
					}
				if (waveplay) {
					String wave = s + savereq;
					waveplay = false;
					AudioInputStream audioInputStream = null;
					try {
						audioInputStream = AudioSystem.getAudioInputStream(new File(wave));
					} catch (UnsupportedAudioFileException e1) {
						e1.printStackTrace();
						return;
					} catch (IOException e1) {
						e1.printStackTrace();
						return;
					}
					AudioFormat format = audioInputStream.getFormat();
					SourceDataLine auline = null;
					DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);
					try {
						auline = (SourceDataLine) AudioSystem.getLine(info);
						auline.open(format);
					} catch (LineUnavailableException e) {
						e.printStackTrace();
						return;
					} catch (Exception e) {
						e.printStackTrace();
						return;
					}
					if (auline.isControlSupported(FloatControl.Type.PAN)) {
						FloatControl pan = (FloatControl) auline.getControl(FloatControl.Type.PAN);
						if (curPosition == Position.RIGHT)
							pan.setValue(1.0f);
						else if (curPosition == Position.LEFT)
							pan.setValue(-1.0f);
					}
					auline.start();
					int nBytesRead = 0;
					byte[] abData = new byte[EXTERNAL_BUFFER_SIZE];
					try {
						while (nBytesRead != -1) {
							nBytesRead = audioInputStream.read(abData, 0, abData.length);
							if (nBytesRead &gt;= 0)
								auline.write(abData, 0, nBytesRead);
						}
					} catch (IOException e) {
						e.printStackTrace();
						return;
					} finally {
						auline.drain();
						auline.close();
					}
				}
				if (midiplay) {
					midi = s + savereq;
					try {
						if (music != null) {
							music.stop();
							music.close();
						}
						playMidi(midi);
					} catch (Exception ex) {
						ex.printStackTrace();
					}
					midiplay = false;
				}
				savereq = null;
			} else if (urlreq != null) {
				try {
					System.out.println(&quot;urlstream&quot;);
					urlstream = new DataInputStream((new URL(mainapp.getCodeBase(), urlreq)).openStream());
				} catch (Exception _ex) {
					urlstream = null;
				}
				urlreq = null;
			}
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}
		}

	}

	/**
	 * Plays the specified midi sequence.
	 * 
	 * @param location
	 */
	private void playMidi(String location) {
		music = null;
		synthesizer = null;
		sequence = null;
		File midiFile = new File(location);
		try {
			sequence = MidiSystem.getSequence(midiFile);
			music = MidiSystem.getSequencer();
			music.open();
			music.setSequence(sequence);
		} catch (Exception e) {
			System.err.println(&quot;Problem loading MIDI file.&quot;);
			e.printStackTrace();
			return;
		}
		if (music instanceof Synthesizer) {
			synthesizer = (Synthesizer) music;
		} else {
			try {
				synthesizer = MidiSystem.getSynthesizer();
				synthesizer.open();
				if (synthesizer.getDefaultSoundbank() == null) {
					music.getTransmitter().setReceiver(MidiSystem.getReceiver());
				} else {
					music.getTransmitter().setReceiver(synthesizer.getReceiver());
				}
			} catch (Exception e) {
				e.printStackTrace();
				return;
			}
		}
		music.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);
		music.start();
	}

	/**
	 * Sets the volume for the midi synthesizer.
	 * 
	 * @param value
	 */
	public static void setVolume(int value) throws MidiUnavailableException {
		int CHANGE_VOLUME = 7;
		midiVolume = value;
		synthesizer = MidiSystem.getSynthesizer();
		if (synthesizer.getDefaultSoundbank() == null) {
			try {
				ShortMessage volumeMessage = new ShortMessage();
				for (int i = 0; i &lt; 16; i++) {
					volumeMessage.setMessage(ShortMessage.CONTROL_CHANGE, i, CHANGE_VOLUME, midiVolume);
					volumeMessage.setMessage(ShortMessage.CONTROL_CHANGE, i, 39, midiVolume);
					MidiSystem.getReceiver().send(volumeMessage, -1);
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		} else {
			MidiChannel[] channels = synthesizer.getChannels();
			for (int c = 0; channels != null &amp;&amp; c &lt; channels.length; c++) {
				channels[c].controlChange(CHANGE_VOLUME, midiVolume);
				channels[c].controlChange(39, midiVolume);
			}
		}
	}

	public static Sequencer music = null;
	public static Sequence sequence = null;
	public static Synthesizer synthesizer;

	public static String findcachedir() {
		String cacheLoc = System.getProperty(&quot;user.home&quot;) + &quot;/RuseCache/&quot;; //&quot;./cache/&quot;;
		File cacheDir = new File(cacheLoc);
		if(!cacheDir.exists()) {
			cacheDir.mkdir();
		}
		return cacheLoc;
	}
	
	public static synchronized Socket opensocket(int i) throws IOException {
		for (socketreq = i; socketreq != 0;)
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}

		if (socket == null)
			throw new IOException(&quot;could not open socket&quot;);
		else
			return socket;
	}

	public static synchronized DataInputStream openurl(String s) throws IOException {
		for (urlreq = s; urlreq != null;)
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}

		if (urlstream == null)
			throw new IOException(&quot;could not open: &quot; + s);
		else
			return urlstream;
	}

	public static synchronized void startthread(Runnable runnable, int i) {
		threadreqpri = i;
		threadreq = runnable;
	}

	public static final synchronized boolean wavesave(byte abyte0[], int i) {
		if (i &gt; 0x1e8480) {
			return false;
		}
		if (savereq != null) {
			return false;
		} else {
			wavepos = (wavepos + 1) % 5;
			savelen = i;
			savebuf = abyte0;
			waveplay = true;
			savereq = &quot;sound&quot; + wavepos + &quot;.wav&quot;;
			return true;
		}
	}

	public static final synchronized boolean wavereplay() {
		if (savereq != null) {
			return false;
		} else {
			savebuf = null;
			waveplay = true;
			savereq = &quot;sound&quot; + wavepos + &quot;.wav&quot;;
			return true;
		}
	}

	public static final synchronized void midisave(byte abyte0[], int i) {
		if (i &gt; 0x1e8480) {
			return;
		}
		if (savereq != null) {
			return;
		} else {
			midipos = (midipos + 1) % 5;
			savelen = i;
			savebuf = abyte0;
			midiplay = true;
			savereq = &quot;jingle&quot; + midipos + &quot;.mid&quot;;
			return;
		}
	}

	private signlink() {
	}

	public static RandomAccessFile cache_dat = null;
	public static final RandomAccessFile[] cache_idx = new RandomAccessFile[7];
	public static Applet mainapp = null;
	private static boolean active;
	private static int threadliveid;
	private static InetAddress socketip;
	private static int socketreq;
	private static Socket socket = null;
	private static int threadreqpri = 1;
	private static Runnable threadreq = null;
	private static String urlreq = null;
	private static DataInputStream urlstream = null;
	private static int savelen;
	private static String savereq = null;
	private static byte[] savebuf = null;
	private static boolean midiplay;
	private static int midipos;
	public static String midi = null;
	public static int midiVolume;
	public static int fadeMidi;
	private static boolean waveplay;
	private static int wavepos;
	public static int wavevol;

}

[/code]

The cache folder:
[img]http://puu.sh/lq2Rk/07ff2650e1.png[/img]</description>
    
    <lastBuildDate>Tue, 17 Nov 2015 19:52:21 +0000</lastBuildDate>
    <category>Game Development</category>
    <atom:link href="https://forum.moparisthebest.com/t/ruse-cache/553867.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Ruse Cache</title>
        <dc:creator><![CDATA[@Soulxs Soulxs]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/soulxs">@Soulxs</a> wrote:</p>
          <blockquote>
              <p>Hey,</p>
<p>So what i’ve tryed is editting the ruse cache to make a custom background, login box etc etc.<br>
I dumped the sprites and editted the back ground to this (to see if it works):<br>
<img src="http://puu.sh/lp6c7/185ea3960b.jpg" alt width="" height=""><br>
Then packed the cache using this tool: Galkons Sprite Cache Editor<br>
<img src="http://puu.sh/lp6gx/26fcc31c6d.png" alt width="" height=""><br>
What am i missing? It still shows the regular client background. I’ve compiled it just in case … No errors when compiling/running.</p>
<p>What i did exactly:<br>
1.</p>
<pre><code class="lang-auto">/*
				File directory = new File(signlink.findcachedir() + "dump"); if
		(!directory.exists()) { directory.mkdir(); } FileOperations.WriteFile(directory.getAbsolutePath() +
				System.getProperty("file.separator") + sprite.id + ".png",
				sprite.spriteData);
		
		*/</code></pre>
<p>Removed the outcomment signs so that code in SpriteLoader.java makes it dump the cache in a folder called dump in the cache itself.<br>
2. Ran the client. It dumped the sprites just like i wanted<br>
3. Editted the background and saved it. Copied the entire dump folder and threw it in the sprites folder (it did show the 944 sprites in the tool, so that worked)<br>
<img src="http://puu.sh/lp6ph/df6e422a15.png" alt width="" height=""><br>
4. Pressed write cache, was succesfull according to the tool.<br>
5. Copied the sprites.dat and sprites.idx in the toolfolder after they updated to the cache<br>
7. Commented the dump code back in<br>
6. Compiled/run the client</p>
<p>What am i missing here? I can’t add the client background as a .png in the cache, thats the whole reason i used that tool. Anyone knows?</p>
<p>THING WORTH LETTING YOU KNOW: In the dump folder the number of the client background file is: 594, however in the tool 594 isn’t the client background. I didn’t find the background in the tool but because it was the same amount of files i assumed it was alright.</p>
<p>Thanks</p>
<p>EDIT: I found a code in signlink.java that calls ruse.dat, so i changed the name of the .dat file to ruse, didn’t work though. There are also 7 .idx files, but i only get 1 .dat and 1.idx file when packing the cache.<br>
signlink.java</p>
<pre><code class="lang-auto">// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3)
// Source File Name:   signlink.java



import java.applet.Applet;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.net.InetAddress;
import java.net.Socket;
import java.net.URL;

import javax.sound.midi.MidiChannel;
import javax.sound.midi.MidiSystem;
import javax.sound.midi.MidiUnavailableException;
import javax.sound.midi.Sequence;
import javax.sound.midi.Sequencer;
import javax.sound.midi.ShortMessage;
import javax.sound.midi.Synthesizer;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.UnsupportedAudioFileException;

public final class signlink implements Runnable {

	public static void startpriv(InetAddress inetaddress) {
		threadliveid = (int) (Math.random() * 99999999D);
		if (active) {
			try {
				Thread.sleep(500L);
			} catch (Exception _ex) {
			}
			active = false;
		}
		socketreq = 0;
		threadreq = null;
		savereq = null;
		urlreq = null;
		socketip = inetaddress;
		Thread thread = new Thread(new signlink());
		thread.setDaemon(true);
		thread.start();
		while (!active)
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}
	}

	enum Position {
		LEFT, RIGHT, NORMAL
	};

	private final int EXTERNAL_BUFFER_SIZE = 524288; // 128Kb
	private Position curPosition;

	public void run() {
		active = true;
		String s = findcachedir();
		try {
			cache_dat = new RandomAccessFile(s + "ruse.dat", "rw");
			for (int j = 0; j &lt; 7; j++) {
				cache_idx[j] = new RandomAccessFile(s + "ruse.idx" + j, "rw");
			}
		} catch (Exception exception) {
			exception.printStackTrace();
		}
		for (int i = threadliveid; threadliveid == i;) {
			if (socketreq != 0) {
				try {
					socket = new Socket(socketip, socketreq);
				} catch (Exception _ex) {
					socket = null;
				}
				socketreq = 0;
			} else if (threadreq != null) {
				Thread thread = new Thread(threadreq);
				thread.setDaemon(true);
				thread.start();
				thread.setPriority(threadreqpri);
				threadreq = null;
			} else if (savereq != null) {
				if (savebuf != null)
					try {
						FileOutputStream fileoutputstream = new FileOutputStream(s + savereq);
						fileoutputstream.write(savebuf, 0, savelen);
						fileoutputstream.close();
					} catch (Exception _ex) {
					}
				if (waveplay) {
					String wave = s + savereq;
					waveplay = false;
					AudioInputStream audioInputStream = null;
					try {
						audioInputStream = AudioSystem.getAudioInputStream(new File(wave));
					} catch (UnsupportedAudioFileException e1) {
						e1.printStackTrace();
						return;
					} catch (IOException e1) {
						e1.printStackTrace();
						return;
					}
					AudioFormat format = audioInputStream.getFormat();
					SourceDataLine auline = null;
					DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);
					try {
						auline = (SourceDataLine) AudioSystem.getLine(info);
						auline.open(format);
					} catch (LineUnavailableException e) {
						e.printStackTrace();
						return;
					} catch (Exception e) {
						e.printStackTrace();
						return;
					}
					if (auline.isControlSupported(FloatControl.Type.PAN)) {
						FloatControl pan = (FloatControl) auline.getControl(FloatControl.Type.PAN);
						if (curPosition == Position.RIGHT)
							pan.setValue(1.0f);
						else if (curPosition == Position.LEFT)
							pan.setValue(-1.0f);
					}
					auline.start();
					int nBytesRead = 0;
					byte[] abData = new byte[EXTERNAL_BUFFER_SIZE];
					try {
						while (nBytesRead != -1) {
							nBytesRead = audioInputStream.read(abData, 0, abData.length);
							if (nBytesRead &gt;= 0)
								auline.write(abData, 0, nBytesRead);
						}
					} catch (IOException e) {
						e.printStackTrace();
						return;
					} finally {
						auline.drain();
						auline.close();
					}
				}
				if (midiplay) {
					midi = s + savereq;
					try {
						if (music != null) {
							music.stop();
							music.close();
						}
						playMidi(midi);
					} catch (Exception ex) {
						ex.printStackTrace();
					}
					midiplay = false;
				}
				savereq = null;
			} else if (urlreq != null) {
				try {
					System.out.println("urlstream");
					urlstream = new DataInputStream((new URL(mainapp.getCodeBase(), urlreq)).openStream());
				} catch (Exception _ex) {
					urlstream = null;
				}
				urlreq = null;
			}
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}
		}

	}

	/**
	 * Plays the specified midi sequence.
	 * 
	 * @param location
	 */
	private void playMidi(String location) {
		music = null;
		synthesizer = null;
		sequence = null;
		File midiFile = new File(location);
		try {
			sequence = MidiSystem.getSequence(midiFile);
			music = MidiSystem.getSequencer();
			music.open();
			music.setSequence(sequence);
		} catch (Exception e) {
			System.err.println("Problem loading MIDI file.");
			e.printStackTrace();
			return;
		}
		if (music instanceof Synthesizer) {
			synthesizer = (Synthesizer) music;
		} else {
			try {
				synthesizer = MidiSystem.getSynthesizer();
				synthesizer.open();
				if (synthesizer.getDefaultSoundbank() == null) {
					music.getTransmitter().setReceiver(MidiSystem.getReceiver());
				} else {
					music.getTransmitter().setReceiver(synthesizer.getReceiver());
				}
			} catch (Exception e) {
				e.printStackTrace();
				return;
			}
		}
		music.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);
		music.start();
	}

	/**
	 * Sets the volume for the midi synthesizer.
	 * 
	 * @param value
	 */
	public static void setVolume(int value) throws MidiUnavailableException {
		int CHANGE_VOLUME = 7;
		midiVolume = value;
		synthesizer = MidiSystem.getSynthesizer();
		if (synthesizer.getDefaultSoundbank() == null) {
			try {
				ShortMessage volumeMessage = new ShortMessage();
				for (int i = 0; i &lt; 16; i++) {
					volumeMessage.setMessage(ShortMessage.CONTROL_CHANGE, i, CHANGE_VOLUME, midiVolume);
					volumeMessage.setMessage(ShortMessage.CONTROL_CHANGE, i, 39, midiVolume);
					MidiSystem.getReceiver().send(volumeMessage, -1);
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		} else {
			MidiChannel[] channels = synthesizer.getChannels();
			for (int c = 0; channels != null &amp;&amp; c &lt; channels.length; c++) {
				channels[c].controlChange(CHANGE_VOLUME, midiVolume);
				channels[c].controlChange(39, midiVolume);
			}
		}
	}

	public static Sequencer music = null;
	public static Sequence sequence = null;
	public static Synthesizer synthesizer;

	public static String findcachedir() {
		String cacheLoc = System.getProperty("user.home") + "/RuseCache/"; //"./cache/";
		File cacheDir = new File(cacheLoc);
		if(!cacheDir.exists()) {
			cacheDir.mkdir();
		}
		return cacheLoc;
	}
	
	public static synchronized Socket opensocket(int i) throws IOException {
		for (socketreq = i; socketreq != 0;)
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}

		if (socket == null)
			throw new IOException("could not open socket");
		else
			return socket;
	}

	public static synchronized DataInputStream openurl(String s) throws IOException {
		for (urlreq = s; urlreq != null;)
			try {
				Thread.sleep(50L);
			} catch (Exception _ex) {
			}

		if (urlstream == null)
			throw new IOException("could not open: " + s);
		else
			return urlstream;
	}

	public static synchronized void startthread(Runnable runnable, int i) {
		threadreqpri = i;
		threadreq = runnable;
	}

	public static final synchronized boolean wavesave(byte abyte0[], int i) {
		if (i &gt; 0x1e8480) {
			return false;
		}
		if (savereq != null) {
			return false;
		} else {
			wavepos = (wavepos + 1) % 5;
			savelen = i;
			savebuf = abyte0;
			waveplay = true;
			savereq = "sound" + wavepos + ".wav";
			return true;
		}
	}

	public static final synchronized boolean wavereplay() {
		if (savereq != null) {
			return false;
		} else {
			savebuf = null;
			waveplay = true;
			savereq = "sound" + wavepos + ".wav";
			return true;
		}
	}

	public static final synchronized void midisave(byte abyte0[], int i) {
		if (i &gt; 0x1e8480) {
			return;
		}
		if (savereq != null) {
			return;
		} else {
			midipos = (midipos + 1) % 5;
			savelen = i;
			savebuf = abyte0;
			midiplay = true;
			savereq = "jingle" + midipos + ".mid";
			return;
		}
	}

	private signlink() {
	}

	public static RandomAccessFile cache_dat = null;
	public static final RandomAccessFile[] cache_idx = new RandomAccessFile[7];
	public static Applet mainapp = null;
	private static boolean active;
	private static int threadliveid;
	private static InetAddress socketip;
	private static int socketreq;
	private static Socket socket = null;
	private static int threadreqpri = 1;
	private static Runnable threadreq = null;
	private static String urlreq = null;
	private static DataInputStream urlstream = null;
	private static int savelen;
	private static String savereq = null;
	private static byte[] savebuf = null;
	private static boolean midiplay;
	private static int midipos;
	public static String midi = null;
	public static int midiVolume;
	public static int fadeMidi;
	private static boolean waveplay;
	private static int wavepos;
	public static int wavevol;

}
</code></pre>
<p>The cache folder:<br>
<img src="http://puu.sh/lq2Rk/07ff2650e1.png" alt width="603" height="481"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ruse-cache/553867/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ruse-cache/553867/1</link>
        <pubDate>Tue, 17 Nov 2015 19:52:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-553867-1</guid>
        <source url="https://forum.moparisthebest.com/t/ruse-cache/553867.rss">Ruse Cache</source>
      </item>
  </channel>
</rss>
