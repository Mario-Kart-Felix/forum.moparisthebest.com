<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>The amazing performance of java</title>
    <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123</link>
    <description>I&#39;ll just leave this picture here.

[img]http://i50.tinypic.com/2l8hr9f.png[/img]
http://i50.tinypic.com/2l8hr9f.png

Note: For C++ the CLOCKS_PER_SEC value on the system was 1000 - so that&#39;s 2262ms.</description>
    
    <lastBuildDate>Mon, 31 Dec 2012 10:01:55 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Pwnd Pwnd]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/pwnd">@Pwnd</a> wrote:</p>
          <blockquote>
              <p>Redundant, but when a language is more difficult to implement, how would that directly correlate to the amount of money you make?</p>
<p>difficulty != usefulness</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/24">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/24</link>
        <pubDate>Mon, 31 Dec 2012 10:01:55 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-24</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Smokey2 Smokey_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/smokey2">@Smokey2</a> wrote:</p>
          <blockquote>
              <p>In addition to running a compiled Java program, computers running Java applications generally must also run the Java virtual machine (JVM), while compiled C++ programs can be run without external applications. Early versions of Java were significantly outperformed by statically compiled languages such as C++. This is because the program statements of these two closely related languages may compile to a few machine instructions with C++, while compiling into several byte codes involving several machine instructions each when interpreted by a JVM. For example:</p>
<p>Java/C++ statement:</p>
<pre><code class="lang-auto"></code></pre>
<p>C++ generated code:</p>
<p><code>mov edx,[ebp+4h]
mov eax,[ebp+1Ch]
inc dword ptr [edx+eax*4] </code></p>
<p>Java generated code:</p>
<p><code>aload_1
iload_2
dup2
iaload
iconst_1
iadd
iastore</code></p>
<p>Certain inefficiencies are inherent to the Java language itself, primarily:<br>
All objects are allocated on the heap. For functions using small objects this can result in performance degradation as stack allocation, in contrast, costs essentially zero. However, this advantage is obsoleted by modern JIT compilers utilising escape analysis or escape detection to allocate objects on the stack. Escape analysis was introduced in Oracle JDK 6.<br>
Methods are virtual by default. This slightly increases memory usage by adding a single pointer to a virtual table per each object. It also induces a startup performance penalty, since a JIT compiler must perform additional optimization passes even for de-virtualization of small functions.<br>
A lot of casting required even using standard containers induces a performance penalty. However, most of these casts are statically eliminated by the JIT compiler, and the casts that remain in the code usually do not cost more than a single CPU cycle on modern processors, thanks to branch prediction.<br>
Array access must be safe. The compiler is required to put appropriate range checks in the code. The naive approach of guarding each array access with a range check is not efficient, so most JIT compilers generate range check instructions only if they cannot statically prove the array access is safe. Even if all runtime range checks cannot be statically elided, JIT compilers try to move them out of inner loops to make the performance degradation as low as possible.<br>
Lack of access to low-level details prevents the developer from improving the program where the compiler is unable to do so. Programmers can interface with the OS directly by providing code in C or C++ and calling that code from Java by means of JNI.<br>
In contrast, various optimizations in C++ are either too difficult or impractical to implement:<br>
Pointers make optimization difficult since they may point to arbitrary data. However, in some cases this is obsoleted as new compilers introduced a strict-aliasing rule and because of support of the C99 keyword restrict.<br>
Java garbage collection may have better cache coherence than the usual usage of malloc/new for memory allocation, as its allocations are generally made sequentially. Nevertheless, arguments exist[weasel words] that both allocators equally fragment the heap and neither exhibits better cache locality.<br>
Due to the lack of garbage collection in C++, programmers must supply their own memory management code, often in the form of reference-counted smart pointers.<br>
Since the code generated from various concretisations of the same templated class in C++ is not shared, excessive use of templates may lead to significant increase of the executable code size.<br>
Run-time compilation can potentially use additional information available at run-time to improve code more effectively, such as the processor on which the code will be executed. However, this claim is effectively made obsolete as most state-of-the-art C++ compilers generate multiple code paths to employ the full computational abilities of the given system<br>
Run-time compilation allows for more aggressive virtual function inlining than is possible for a static compiler, because the JIT compiler has complete information about all possible targets of the virtual call, even if they are in different dynamically loaded modules. Currently available JVM implementations have no problem in inlining most of the monomorphic, mostly monomorphic and dimorphic calls, and research is in progress to inline also megamorphic calls, thanks to the recent invoke dynamic enhancements added in Java 7. Inlining can allow for further optimisations like loop vectorisation or loop unrolling, resulting in a huge overall performance increase.<br>
Because dynamic linking is performed after code generation and optimisation in C++, function calls spanning different dynamic modules cannot be inlined.<br>
Because thread support is provided by libraries in C++, C++ compilers have no chance to perform thread-related optimisations. In Java, thread synchronisation is built into the language, so the JIT compiler can, with the help of escape analysis, easily elide or coarse locks, significantly improving performance of multithreaded code. This technique was introduced in Sun JDK 6 update 10 and is named biased locking.</p>
<aside class="onebox wikipedia">
  <header class="source">
      <a href="https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B" target="_blank" rel="nofollow noopener">en.wikipedia.org</a>
  </header>
  <article class="onebox-body">
    <img src="//upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Text_document_with_red_question_mark.svg/40px-Text_document_with_red_question_mark.svg.png" class="thumbnail onebox-full-image" width="40" height="40">

<h3><a href="https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B" target="_blank" rel="nofollow noopener">Comparison of Java and C++</a></h3>

<p>This is a comparison of the programming languages Java and C++.   The differences between the programming languages C++ and Java can be traced to their heritage, as they have different design goals.</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/23">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/23</link>
        <pubDate>Sat, 22 Dec 2012 18:27:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-23</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@JavaTC JavaTC]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/javatc">@JavaTC</a> wrote:</p>
          <blockquote>
              <p>Maybe I should have bought that Java book <img src="https://forum.moparisthebest.com/images/emoji/twitter/expressionless.png?v=5" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/22">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/22</link>
        <pubDate>Sat, 16 Jun 2012 20:25:04 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-22</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@slavemaster veer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/slavemaster">@slavemaster</a> wrote:</p>
          <blockquote>
              <p>In case any of you want to learn a bit more about the topic at hand, read here: <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5005861" rel="nofollow noopener">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5005861</a></p>
<p>Essentially, the JIT won’t help much here, except avoid the JNI overhead of calling since StrictMath is all delegated to native code. The reason Java lags behind is that StrictMath is implemented to return cross-platform strict results with a high-degree of precision and accuracy, while the C++ code most likely uses low-level fsin/fcos/fsincos instructions, which are going to be much faster. Unfortunately, fsin/fcos/fsincos are pretty arbitrary in their hardware implementation, and on Intel at least, they’re only accurate over the interval [-pi/4, pi/4] – as such, they require sophisticated precise argument reduction.</p>
<p>The JVM does attempt to optimize the calls on x86, as can be seen here: <a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/9b0ca45cd756/src/cpu/x86/vm/interpreter_x86_32.cpp" rel="nofollow noopener">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/9b0ca45cd756/src/cpu/x86/vm/interpreter_x86_32.cpp</a></p>
<p><code>address InterpreterGenerator::generate_math_entry(AbstractInterpreter::MethodKind kind) {
      109 
      110   // rbx,: methodOop
      111   // rcx: scratrch
      112   // rsi: sender sp
      113 
      114   if (!InlineIntrinsics) return NULL; // Generate a vanilla entry
      115 
      116   address entry_point = __ pc();
      117 
      118   // These don't need a safepoint check because they aren't virtually
      119   // callable. We won't enter these intrinsics from compiled code.
      120   // If in the future we added an intrinsic which was virtually callable
      121   // we'd have to worry about how to safepoint so that this code is used.
      122 
      123   // mathematical functions inlined by compiler
      124   // (interpreter must provide identical implementation
      125   // in order to avoid monotonicity bugs when switching
      126   // from interpreter to compiler in the middle of some
      127   // computation)
      128   //
      129   // stack: [ ret adr ] &lt;-- rsp
      130   //        [ lo(arg) ]
      131   //        [ hi(arg) ]
      132   //
      133 
      134   // Note: For JDK 1.2 StrictMath doesn't exist and Math.sin/cos/sqrt are
      135   //       native methods. Interpreter::method_kind(...) does a check for
      136   //       native methods first before checking for intrinsic methods and
      137   //       thus will never select this entry point. Make sure it is not
      138   //       called accidentally since the SharedRuntime entry points will
      139   //       not work for JDK 1.2.
      140   //
      141   // We no longer need to check for JDK 1.2 since it's EOL'ed.
      142   // The following check existed in pre 1.6 implementation,
      143   //    if (Universe::is_jdk12x_version()) {
      144   //      __ should_not_reach_here();
      145   //    }
      146   // Universe::is_jdk12x_version() always returns false since
      147   // the JDK version is not yet determined when this method is called.
      148   // This method is called during interpreter_init() whereas
      149   // JDK version is only determined when universe2_init() is called.
      150 
      151   // Note: For JDK 1.3 StrictMath exists and Math.sin/cos/sqrt are
      152   //       java methods.  Interpreter::method_kind(...) will select
      153   //       this entry point for the corresponding methods in JDK 1.3.
      154   // get argument
      155   __ fld_d(Address(rsp, 1*wordSize));
      156   switch (kind) {
      157     case Interpreter::java_lang_math_sin :
      158         __ trigfunc('s');
      159         break;
      160     case Interpreter::java_lang_math_cos :
      161         __ trigfunc('c');
      162         break;
      163     case Interpreter::java_lang_math_tan :
      164         __ trigfunc('t');
      165         break;
      166     case Interpreter::java_lang_math_sqrt:
      167         __ fsqrt();
      168         break;
      169     case Interpreter::java_lang_math_abs:
      170         __ fabs();
      171         break;
      172     case Interpreter::java_lang_math_log:
      173         __ flog();
      174         // Store to stack to convert 80bit precision back to 64bits
      175         __ push_fTOS();
      176         __ pop_fTOS();
      177         break;
      178     case Interpreter::java_lang_math_log10:
      179         __ flog10();
      180         // Store to stack to convert 80bit precision back to 64bits
      181         __ push_fTOS();
      182         __ pop_fTOS();
      183         break;
      184     default                              :
      185         ShouldNotReachHere();
      186   }
      187 
      188   // return double result in xmm0 for interpreter and compilers.
      189   if (UseSSE &gt;= 2) {
      190     __ subptr(rsp, 2*wordSize);
      191     __ fstp_d(Address(rsp, 0));
      192     __ movdbl(xmm0, Address(rsp, 0));
      193     __ addptr(rsp, 2*wordSize);
      194   }
      195 
      196   // done, result in FPU ST(0) or XMM0
      197   __ pop(rdi);                               // get return address
      198   __ mov(rsp, rsi);                          // set sp to sender sp
      199   __ jmp(rdi);
      200 
      201   return entry_point;
      202 }</code></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/21">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/21</link>
        <pubDate>Sat, 09 Jun 2012 16:06:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-21</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Cheese_Police c|p]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/cheese_police">@Cheese_Police</a> wrote:</p>
          <blockquote>
              <p>cus fuck u thats why</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/20">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/20</link>
        <pubDate>Thu, 07 Jun 2012 21:25:20 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-20</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>why can’t we all just get along… <img src="https://forum.moparisthebest.com/images/emoji/twitter/expressionless.png?v=5" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/19">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/19</link>
        <pubDate>Thu, 07 Jun 2012 21:10:59 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-19</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>[quote=“Disorder, post:16, topic:444123”][quote author=Taharok link=topic=546807.msg4009604#msg4009604 date=1339025464]<br>
Well how can you simply disregard one aspect of development (development time, in this case) and not others (arbitrary performance time)? I think you’re being entirely foolish here. <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> You brought up salaries, great. That’s a company’s expense. Would a company rather you develop something that takes hundreds of hours longer in a lower level language than in a more managed language? Only if they absolutely need that minor difference in performance (yes, it really is minor). If you want legitimate benchmarks, benchmark entire applications, not just number crunching.</p>
<p>As far as .NET versus Java speeds goes, that really comes down to other arguments such as AOT versus JIT, etc. AOT will sacrifice initialization time to increase runtime, whereas JIT wants to try to run as fast as is needed at any given point. I will reiterate my previous point here: neither is better than another. There are times when one aspect is better than another (especially since an AOT infrastructure seems to simplify pregenerating native code, which is great for sticky situations like developing in managed languages in iOS).</p>
<p>You’re really being short sighted if you are considering a single language to solve all your problems in software engineering. Yeah, maybe C++ programmers are being demanded more, but you’re going to be more successful as a software engineer if you are proficient in low and high, unmanaged and managed languages alike.<br>
[/quote]</p>
<p>I think you’re being foolish here. Are you claiming that all the software development companies out there that use C++ are doing it wrong because they’re not using managed languages that would help them be more productive? Those companies obviously have already done the “this versus that” analysis and the decision was C++. There are areas where native code is the only option. If you’re writing lame software such as a payroll management application - who cares what you write it in and how fast the dialog boxes appear. However, there’s more serious development going on, you’d be surprised.</p>
<p>Why are you talking about JIT vs AOT when referring to .NET vs java? Leaving aside Mono, only the ngen tool can be used to perform AOT compilation for .NET code - and it’s rarely used. It’s actually .NET’s JIT vs java’s JIT.</p>
<p>I don’t know if you’ve noticed that native code is getting more and more attention lately. Google and Apple are developing an entire new compiler for C++ - Clang. In the mobile space native code is the only option if you want to have a unified code base, minus the glue code. Lately expressions such “performance per watt” and “performance per user” have emerged. I suggest reading about C++ usage at Facebook, mainly the interviews given by Andrei Alexandrescu. At this point their back-end is entirely C++ and the front-end PHP code is automatically translated into C++. This allows them to run on only a small fraction of the servers that would be necessary to run a 100% PHP codebase.[/quote]</p>
<p>I am familiar with clang. The point of it is to simplify a lot of what was difficult to work with before. You can’t simply solve all of the pure-native issues with a brand new compiler, though. These are conceptual differences that have their limitations.</p>
<p>And perhaps you ultimately missed my point. I was not arguing against C++ once in this topic. I was stating there are times to use a more powerful yet more difficultly managed language and there are times to not. Facebook did not originate on such concepts, they only decided to move to them later on. Hell, they could have used a popular mono project which contains a php engine that dynamically compiles the php to CIL bytecode and lets the mono runtime deal with it. I guarantee that solution would be very close in performance but yet it’s magically in a managed language. :o If they had decided against using that approach and wanted to spend the extra time writing their own backend, that’s fine too. Either way, they had more reasons than even you probably know in choosing their exact solution.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/18">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/18</link>
        <pubDate>Thu, 07 Jun 2012 14:12:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-18</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Mopman Mopman]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mopman">@Mopman</a> wrote:</p>
          <blockquote>
              <p>its amusing that you refer to systems development as “serious development” and everything else as “lame software”</p>
<p>what use is the system without the useful software to run on it?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/17">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/17</link>
        <pubDate>Thu, 07 Jun 2012 11:50:25 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-17</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Disorder Disorder]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/disorder">@Disorder</a> wrote:</p>
          <blockquote>
              <p>[quote=“Taharok, post:14, topic:444123”]Well how can you simply disregard one aspect of development (development time, in this case) and not others (arbitrary performance time)? I think you’re being entirely foolish here. <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> You brought up salaries, great. That’s a company’s expense. Would a company rather you develop something that takes hundreds of hours longer in a lower level language than in a more managed language? Only if they absolutely need that minor difference in performance (yes, it really is minor). If you want legitimate benchmarks, benchmark entire applications, not just number crunching.</p>
<p>As far as .NET versus Java speeds goes, that really comes down to other arguments such as AOT versus JIT, etc. AOT will sacrifice initialization time to increase runtime, whereas JIT wants to try to run as fast as is needed at any given point. I will reiterate my previous point here: neither is better than another. There are times when one aspect is better than another (especially since an AOT infrastructure seems to simplify pregenerating native code, which is great for sticky situations like developing in managed languages in iOS).</p>
<p>You’re really being short sighted if you are considering a single language to solve all your problems in software engineering. Yeah, maybe C++ programmers are being demanded more, but you’re going to be more successful as a software engineer if you are proficient in low and high, unmanaged and managed languages alike.[/quote]</p>
<p>I think you’re being foolish here. Are you claiming that all the software development companies out there that use C++ are doing it wrong because they’re not using managed languages that would help them be more productive? Those companies obviously have already done the “this versus that” analysis and the decision was C++. There are areas where native code is the only option. If you’re writing lame software such as a payroll management application - who cares what you write it in and how fast the dialog boxes appear. However, there’s more serious development going on, you’d be surprised.</p>
<p>Why are you talking about JIT vs AOT when referring to .NET vs java? Leaving aside Mono, only the ngen tool can be used to perform AOT compilation for .NET code - and it’s rarely used. It’s actually .NET’s JIT vs java’s JIT.</p>
<p>I don’t know if you’ve noticed that native code is getting more and more attention lately. Google and Apple are developing an entire new compiler for C++ - Clang. In the mobile space native code is the only option if you want to have a unified code base, minus the glue code. Lately expressions such “performance per watt” and “performance per user” have emerged. I suggest reading about C++ usage at Facebook, mainly the interviews given by Andrei Alexandrescu. At this point their back-end is entirely C++ and the front-end PHP code is automatically translated into C++. This allows them to run on only a small fraction of the servers that would be necessary to run a 100% PHP codebase.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/16</link>
        <pubDate>Thu, 07 Jun 2012 06:04:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-16</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Taharok, post:14, topic:444123”]Well how can you simply disregard one aspect of development (development time, in this case) and not others (arbitrary performance time)? I think you’re being entirely foolish here. <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> You brought up salaries, great. That’s a company’s expense. Would a company rather you develop something that takes hundreds of hours longer in a lower level language than in a more managed language? Only if they absolutely need that minor difference in performance (yes, it really is minor). If you want legitimate benchmarks, benchmark entire applications, not just number crunching.</p>
<p>As far as .NET versus Java speeds goes, that really comes down to other arguments such as AOT versus JIT, etc. AOT will sacrifice initialization time to increase runtime, whereas JIT wants to try to run as fast as is needed at any given point. I will reiterate my previous point here: neither is better than another. There are times when one aspect is better than another (especially since an AOT infrastructure seems to simplify pregenerating native code, which is great for sticky situations like developing in managed languages in iOS).</p>
<p>You’re really being short sighted if you are considering a single language to solve all your problems in software engineering. Yeah, maybe C++ programmers are being demanded more, but you’re going to be more successful as a software engineer if you are proficient in low and high, unmanaged and managed languages alike.[/quote]<br>
– and if you have good practices.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/15</link>
        <pubDate>Thu, 07 Jun 2012 01:51:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-15</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>Well how can you simply disregard one aspect of development (development time, in this case) and not others (arbitrary performance time)? I think you’re being entirely foolish here. <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> You brought up salaries, great. That’s a company’s expense. Would a company rather you develop something that takes hundreds of hours longer in a lower level language than in a more managed language? Only if they absolutely need that minor difference in performance (yes, it really is minor). If you want legitimate benchmarks, benchmark entire applications, not just number crunching.</p>
<p>As far as .NET versus Java speeds goes, that really comes down to other arguments such as AOT versus JIT, etc. AOT will sacrifice initialization time to increase runtime, whereas JIT wants to try to run as fast as is needed at any given point. I will reiterate my previous point here: neither is better than another. There are times when one aspect is better than another (especially since an AOT infrastructure seems to simplify pregenerating native code, which is great for sticky situations like developing in managed languages in iOS).</p>
<p>You’re really being short sighted if you are considering a single language to solve all your problems in software engineering. Yeah, maybe C++ programmers are being demanded more, but you’re going to be more successful as a software engineer if you are proficient in low and high, unmanaged and managed languages alike.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/14</link>
        <pubDate>Wed, 06 Jun 2012 23:31:04 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-14</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Disorder, post:12, topic:444123”][quote author=t4 link=topic=546807.msg4009586#msg4009586 date=1339023453]</p>
<aside class="quote no-group">
<blockquote>
<aside class="quote no-group">
<blockquote>
<p>it must really get to you that there’s a higher demand/availability for Java and .NET programmers…</p>
</blockquote>
</aside>
<p>This indeed is the current trend. However, this doesn’t mean that C++ programmers would have to fight for a position. The amount of highly proficient C++ programmers is also decreasing since most newcomers turn to the managed languages - therefore you’ll always find a C++ job if you’re skilled enough. I also suggest taking a look at the java/C# job profiles. Over 50% of them are web development related - simple web apps/services with some SQL. Ending on a job like this is the worst thing that can happen to one. Finally, I suggest looking at the salary statistics.</p>
<aside class="quote no-group">
<blockquote>
<p>Actually if you read up on the JIT compilation process you’d realise that it’s far more intelligent then you may think.  c++ and c compilers can only optimise based on static inference whereas the JIT compiler is dynamic - <span class="bbcode-b">it can perform far more intelligent optimisations</span>.<br>
You also inferred far too much from my post, I simply said that your supplied benchmark code did not take the hotspot “warmup” time into account, I never said that the resultant java code would be any faster than the C++ code, infact in this mostly useless demonstration of course C++ will win, it is simply crunching numbers.</p>
</blockquote>
</aside>
<p>These “far more intelligent” optimizations are the scanarios when the jitter just cuts off a code branch. That’s as far as it gets. However, branches that can just be cut off are the result of crappy code anyway.</p>
<p>I suggest reading this blog post by Herb Sutter: <a href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/" rel="nofollow noopener">http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/</a> . He leads the C++ team at Microsoft (which also participates in writing the .NET jitter). He speaks for Microsoft so he has no reason to unjustifiably undermine C#. Note that C# (not using the Mono compilers!) is in most of the cases faster than java.</p>
</blockquote>
</aside>
<p>i’d say salary depends more on who you work for (or who you don’t) and how big of a name/resume you have than what exactly you’re doing. regardless of what language you end up using, the pay will always be pretty good if you’re half-way decent.<br>
[/quote]</p>
<p>Of course, those factors also affect the outcome. However, let’s be honest, C++ is several times more difficult - it should come as no surprise that the salaries are bigger.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="http://i47.tinypic.com/23tsbrn.png" title="23tsbrn.png" rel="nofollow noopener"><img src="http://i47.tinypic.com/23tsbrn.png" alt width="513" height="500"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">23tsbrn.png</span><span class="informations">652×635</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div><br>
The 3 most common salaries for both languages should give a good overview of how things are.[/quote]<br>
be careful, those scales are different.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/13</link>
        <pubDate>Wed, 06 Jun 2012 23:23:42 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-13</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Disorder Disorder]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/disorder">@Disorder</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:11, topic:444123”][quote author=Disorder link=topic=546807.msg4009568#msg4009568 date=1339022234]</p>
<aside class="quote no-group">
<blockquote>
<p>it must really get to you that there’s a higher demand/availability for Java and .NET programmers…</p>
</blockquote>
</aside>
<p>This indeed is the current trend. However, this doesn’t mean that C++ programmers would have to fight for a position. The amount of highly proficient C++ programmers is also decreasing since most newcomers turn to the managed languages - therefore you’ll always find a C++ job if you’re skilled enough. I also suggest taking a look at the java/C# job profiles. Over 50% of them are web development related - simple web apps/services with some SQL. Ending on a job like this is the worst thing that can happen to one. Finally, I suggest looking at the salary statistics.</p>
<aside class="quote no-group">
<blockquote>
<p>Actually if you read up on the JIT compilation process you’d realise that it’s far more intelligent then you may think.  c++ and c compilers can only optimise based on static inference whereas the JIT compiler is dynamic - <span class="bbcode-b">it can perform far more intelligent optimisations</span>.<br>
You also inferred far too much from my post, I simply said that your supplied benchmark code did not take the hotspot “warmup” time into account, I never said that the resultant java code would be any faster than the C++ code, infact in this mostly useless demonstration of course C++ will win, it is simply crunching numbers.</p>
</blockquote>
</aside>
<p>These “far more intelligent” optimizations are the scanarios when the jitter just cuts off a code branch. That’s as far as it gets. However, branches that can just be cut off are the result of crappy code anyway.</p>
<p>I suggest reading this blog post by Herb Sutter: <a href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/" rel="nofollow noopener">http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/</a> . He leads the C++ team at Microsoft (which also participates in writing the .NET jitter). He speaks for Microsoft so he has no reason to unjustifiably undermine C#. Note that C# (not using the Mono compilers!) is in most of the cases faster than java.<br>
[/quote]<br>
i’d say salary depends more on who you work for (or who you don’t) and how big of a name/resume you have than what exactly you’re doing. regardless of what language you end up using, the pay will always be pretty good if you’re half-way decent.[/quote]</p>
<p>Of course, those factors also affect the outcome. However, let’s be honest, C++ is several times more difficult - it should come as no surprise that the salaries are bigger.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="http://i47.tinypic.com/23tsbrn.png" title="23tsbrn.png" rel="nofollow noopener"><img src="http://i47.tinypic.com/23tsbrn.png" alt width="513" height="500"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">23tsbrn.png</span><span class="informations">652×635</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div><br>
The 3 most common salaries for both languages should give a good overview of how things are.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/12</link>
        <pubDate>Wed, 06 Jun 2012 23:08:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-12</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Disorder, post:10, topic:444123”][quote author=t4 link=topic=546807.msg4009550#msg4009550 date=1339020641]<br>
it must really get to you that there’s a higher demand/availability for Java and .NET programmers…<br>
[/quote]<br>
This indeed is the current trend. However, this doesn’t mean that C++ programmers would have to fight for a position. The amount of highly proficient C++ programmers is also decreasing since most newcomers turn to the managed languages - therefore you’ll always find a C++ job if you’re skilled enough. I also suggest taking a look at the java/C# job profiles. Over 50% of them are web development related - simple web apps/services with some SQL. Ending on a job like this is the worst thing that can happen to one. Finally, I suggest looking at the salary statistics.</p>
<aside class="quote">
<blockquote>
<p>Actually if you read up on the JIT compilation process you’d realise that it’s far more intelligent then you may think.  c++ and c compilers can only optimise based on static inference whereas the JIT compiler is dynamic - <span class="bbcode-b">it can perform far more intelligent optimisations</span>.<br>
You also inferred far too much from my post, I simply said that your supplied benchmark code did not take the hotspot “warmup” time into account, I never said that the resultant java code would be any faster than the C++ code, infact in this mostly useless demonstration of course C++ will win, it is simply crunching numbers.</p>
</blockquote>
</aside>
<p>These “far more intelligent” optimizations are the scanarios when the jitter just cuts off a code branch. That’s as far as it gets. However, branches that can just be cut off are the result of crappy code anyway.</p>
<p>I suggest reading this blog post by Herb Sutter: <a href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/" rel="nofollow noopener">http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/</a> . He leads the C++ team at Microsoft (which also participates in writing the .NET jitter). He speaks for Microsoft so he has no reason to unjustifiably undermine C#. Note that C# (not using the Mono compilers!) is in most of the cases faster than java.[/quote]<br>
i’d say salary depends more on who you work for (or who you don’t) and how big of a name/resume you have than what exactly you’re doing. regardless of what language you end up using, the pay will always be pretty good if you’re half-way decent.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/11</link>
        <pubDate>Wed, 06 Jun 2012 22:57:33 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-11</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Disorder Disorder]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/disorder">@Disorder</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="8" data-topic="444123">
<div class="title">
<div class="quote-controls"></div>
 t4:</div>
<blockquote>
<p>it must really get to you that there’s a higher demand/availability for Java and .NET programmers…</p>
</blockquote>
</aside>
<p>This indeed is the current trend. However, this doesn’t mean that C++ programmers would have to fight for a position. The amount of highly proficient C++ programmers is also decreasing since most newcomers turn to the managed languages - therefore you’ll always find a C++ job if you’re skilled enough. I also suggest taking a look at the java/C# job profiles. Over 50% of them are web development related - simple web apps/services with some SQL. Ending on a job like this is the worst thing that can happen to one. Finally, I suggest looking at the salary statistics.</p>
<p>[quote=“newbiehacker, post:9, topic:444123”]Actually if you read up on the JIT compilation process you’d realise that it’s far more intelligent then you may think.  c++ and c compilers can only optimise based on static inference whereas the JIT compiler is dynamic - <span class="bbcode-b">it can perform far more intelligent optimisations</span>.<br>
You also inferred far too much from my post, I simply said that your supplied benchmark code did not take the hotspot “warmup” time into account, I never said that the resultant java code would be any faster than the C++ code, infact in this mostly useless demonstration of course C++ will win, it is simply crunching numbers.[/quote]</p>
<p>These “far more intelligent” optimizations are the scanarios when the jitter just cuts off a code branch. That’s as far as it gets. However, branches that can just be cut off are the result of crappy code anyway.</p>
<p>I suggest reading this blog post by Herb Sutter: <a href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/" rel="nofollow noopener">http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/</a> . He leads the C++ team at Microsoft (which also participates in writing the .NET jitter). He speaks for Microsoft so he has no reason to unjustifiably undermine C#. Note that C# (not using the Mono compilers!) is in most of the cases faster than java.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/10</link>
        <pubDate>Wed, 06 Jun 2012 22:37:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-10</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@newbiehacker newbiehacker]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/newbiehacker">@newbiehacker</a> wrote:</p>
          <blockquote>
              <p>Actually if you read up on the JIT compilation process you’d realise that it’s far more intelligent then you may think.  c++ and c compilers can only optimise based on static inference whereas the JIT compiler is dynamic - it can perform far more intelligent optimisations.</p>
<p>You also inferred far too much from my post, I simply said that your supplied benchmark code did not take the hotspot “warmup” time into account, I never said that the resultant java code would be any faster than the C++ code, infact in this mostly useless demonstration of course C++ will win, it is simply crunching numbers.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/9</link>
        <pubDate>Wed, 06 Jun 2012 22:16:10 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-9</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>it must really get to you that there’s a higher demand/availability for Java and .NET programmers…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/8</link>
        <pubDate>Wed, 06 Jun 2012 22:10:41 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-8</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Disorder Disorder]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/disorder">@Disorder</a> wrote:</p>
          <blockquote>
              <p>[quote=“Taharok, post:6, topic:444123”][quote author=Disorder link=topic=546807.msg4009321#msg4009321 date=1339003072]</p>
<aside class="quote">
<blockquote>
<p>dude, you didn’t even give the hotspot time to optimise, pretty flawed benchmark imo</p>
</blockquote>
</aside>
<p>I found this benchmark quite interesting. I rewrote it all based on the picture and tested it. I made the benchmark run for 40 times consecutively - always regenerating the random elements of input arrays a and b to eliminate the possibility of cached results. The first few runs are all around 18600ms. It needs 4 runs to “warm up”, after that it gains a speedup of 800ms (4%) and no further improvements are made.</p>
<p>Would you like to desribe what you think the JIT compiler’s optimizer can do? A lot of people seem to think JIT compilation is some ultimate process. In reality they have been brainwashed by the promoters of managed languages. I’ll hold back my viewpoint on this because I really would like to see how you define optimization.<br>
[/quote]</p>
<p><span class="bbcode-b">Are you implying that the hotspot compiler has no impact on performance?</span> Let me ask you, how do <span class="bbcode-b">you</span> define optimization? Are you naive enough to think it’s only related to cpu time on a specific task? Optimization is a focus of prioritizing one aspect of runtime or compile time, which is well beyond the scope of just cpu time (if that’s what you would presume). I may optimize memory monitoring (and subsequently, garbage collection), at a cost of extra memory and perhaps cpu time. I may optimize compile time at the expense of runtime (or vice versa) by compiling to a simpler, high-level language and interpreting it, which also allows for easy architecture retargetting. I may optimize abstraction in a language design at the expense of offering no low-level functional support and, rather, provide an easy-to-use object oriented syntactical paradigm.</p>
<p>Most of what I just mentioned vaguely outlined the Java programming language (and several others at the same time). Would you have considered any of those aspects to be “optimizations?” If it’s just down to cpu time (as you implied in this topic), then go ahead and use C for everything. Hell, you might as well use raw assembly on the off chance you are able to make it go a few microseconds faster than optimized and compiled gcc binary.</p>
<p>If you were a wise programmer, you’d realize that “optimizing” your program involves asking many questions and making many decisions, the least of which is cpu time. If you wanted to make a very fast math library and wanted to do it at the assembly level, it could take you months before it would target several different popular architectures. The higher the level of language you use though, the faster you will be able to program it. With some languages, this is at the expense of performance. If you used Java, then you save the development time of writing a needed or unneeded memory handler, among other concepts. If you use C++, you have more you have to write, but more control over the end program.</p>
<p>I could probably go on for several hours on this topic and be redundant as hell. The point is, it’s the same naivete as thinking there is one universally “good” language for every solution. It’s project-specific and depends heavily on the application in question and what aspects you want to be most efficient.[/quote]</p>
<p>What you have there is a tl;dr lecture on power/performance vs developer productivity (I read it anyway). Totally unrelated to my previous post, the only related sentence is the one I highlighted in bold - therefore I’m going to reply to that part only. I’m glad you didn’t go as far as explaining the word “optimization” in every possible area of life where the word has a meaning.</p>
<p>Did I say that a JIT optimizer produces no side effects? No.</p>
<p>My previous post was about the fact that most java fanboys believe that the JIT compiler is some mysterious tool that does “this and that” - and since it performs the optimizations at runtime it must spit out extraordinary machine code - it doesn’t. A C++ compiler does “this and that” too and even more. It’s just funny how the java fanboys go on about their theoretical jitters. Let’s look at the benchmarks, alright. And guess what, my imaginary static C++ compiler will always be better than the imaginary java jitters.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/7</link>
        <pubDate>Wed, 06 Jun 2012 22:02:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-7</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>[quote=“Disorder, post:5, topic:444123”][quote author=newbiehacker link=topic=546807.msg4009162#msg4009162 date=1338980737]<br>
dude, you didn’t even give the hotspot time to optimise, pretty flawed benchmark imo<br>
[/quote]</p>
<p>I found this benchmark quite interesting. I rewrote it all based on the picture and tested it. I made the benchmark run for 40 times consecutively - always regenerating the random elements of input arrays a and b to eliminate the possibility of cached results. The first few runs are all around 18600ms. It needs 4 runs to “warm up”, after that it gains a speedup of 800ms (4%) and no further improvements are made.</p>
<p>Would you like to desribe what you think the JIT compiler’s optimizer can do? A lot of people seem to think JIT compilation is some ultimate process. In reality they have been brainwashed by the promoters of managed languages. I’ll hold back my viewpoint on this because I really would like to see how you define optimization.[/quote]</p>
<p>Are you implying that the hotspot compiler has no impact on performance? Let me ask you, how do <span class="bbcode-b">you</span> define optimization? Are you naive enough to think it’s only related to cpu time on a specific task? Optimization is a focus of prioritizing one aspect of runtime or compile time, which is well beyond the scope of just cpu time (if that’s what you would presume). I may optimize memory monitoring (and subsequently, garbage collection), at a cost of extra memory and perhaps cpu time. I may optimize compile time at the expense of runtime (or vice versa) by compiling to a simpler, high-level language and interpreting it, which also allows for easy architecture retargetting. I may optimize abstraction in a language design at the expense of offering no low-level functional support and, rather, provide an easy-to-use object oriented syntactical paradigm.</p>
<p>Most of what I just mentioned vaguely outlined the Java programming language (and several others at the same time). Would you have considered any of those aspects to be “optimizations?” If it’s just down to cpu time (as you implied in this topic), then go ahead and use C for everything. Hell, you might as well use raw assembly on the off chance you are able to make it go a few microseconds faster than optimized and compiled gcc binary.</p>
<p>If you were a wise programmer, you’d realize that “optimizing” your program involves asking many questions and making many decisions, the least of which is cpu time. If you wanted to make a very fast math library and wanted to do it at the assembly level, it could take you months before it would target several different popular architectures. The higher the level of language you use though, the faster you will be able to program it. With some languages, this is at the expense of performance. If you used Java, then you save the development time of writing a needed or unneeded memory handler, among other concepts. If you use C++, you have more you have to write, but more control over the end program.</p>
<p>I could probably go on for several hours on this topic and be redundant as hell. The point is, it’s the same naivete as thinking there is one universally “good” language for every solution. It’s project-specific and depends heavily on the application in question and what aspects you want to be most efficient.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/6</link>
        <pubDate>Wed, 06 Jun 2012 20:55:06 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-6</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Disorder Disorder]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/disorder">@Disorder</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="4" data-topic="444123">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/newbiehacker/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> newbiehacker:</div>
<blockquote>
<p>dude, you didn’t even give the hotspot time to optimise, pretty flawed benchmark imo</p>
</blockquote>
</aside>
<p>I found this benchmark quite interesting. I rewrote it all based on the picture and tested it. I made the benchmark run for 40 times consecutively - always regenerating the random elements of input arrays a and b to eliminate the possibility of cached results. The first few runs are all around 18600ms. It needs 4 runs to “warm up”, after that it gains a speedup of 800ms (4%) and no further improvements are made.</p>
<p>Would you like to desribe what you think the JIT compiler’s optimizer can do? A lot of people seem to think JIT compilation is some ultimate process. In reality they have been brainwashed by the promoters of managed languages. I’ll hold back my viewpoint on this because I really would like to see how you define optimization.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/5</link>
        <pubDate>Wed, 06 Jun 2012 17:17:52 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-5</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@newbiehacker newbiehacker]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/newbiehacker">@newbiehacker</a> wrote:</p>
          <blockquote>
              <p>dude, you didn’t even give the hotspot time to optimise, pretty flawed benchmark imo</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/4</link>
        <pubDate>Wed, 06 Jun 2012 11:05:37 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-4</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@woo_bee woo bee]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/woo_bee">@woo_bee</a> wrote:</p>
          <blockquote>
              <p>thanks for the update rep++++</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/3</link>
        <pubDate>Wed, 06 Jun 2012 09:45:30 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-3</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>C better at number crunching? you don’t say!</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/2</link>
        <pubDate>Tue, 05 Jun 2012 21:49:41 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-2</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
      <item>
        <title>The amazing performance of java</title>
        <dc:creator><![CDATA[@Receptor Receptor]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/receptor">@Receptor</a> wrote:</p>
          <blockquote>
              <p>I’ll just leave this picture here.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="http://i50.tinypic.com/2l8hr9f.png" title="2l8hr9f.png" rel="nofollow noopener"><img src="http://i50.tinypic.com/2l8hr9f.png" alt width="417" height="500"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">2l8hr9f.png</span><span class="informations">1221×1463</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div><br>
          <a href="http://i50.tinypic.com/2l8hr9f.png" target="_blank" class="onebox" rel="nofollow noopener">
            <img src="http://i50.tinypic.com/2l8hr9f.png" width="417" height="500">
          </a>
</p>
<p>Note: For C++ the CLOCKS_PER_SEC value on the system was 1000 - so that’s 2262ms.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123/1</link>
        <pubDate>Tue, 05 Jun 2012 20:34:19 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-444123-1</guid>
        <source url="https://forum.moparisthebest.com/t/the-amazing-performance-of-java/444123.rss">The amazing performance of java</source>
      </item>
  </channel>
</rss>
