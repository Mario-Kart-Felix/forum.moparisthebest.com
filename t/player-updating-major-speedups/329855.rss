<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Player updating: major speedups</title>
    <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855</link>
    <description>As a forward, I am only disclosing these findings with the hope that some of you may find use for it, but I don&#39;t expect anything to actually come from any of the following information and opinions. This community has never been very productive, but for the very slim chance that this changes, the following may be found very useful.

First of all, it seems that game updating is the most tedious of all processes that the server has to do. When breaking it down, we see that game updating generally includes, but isn&#39;t limited to, the following tasks:

[ul][li]Updating players[/li]
[li]Updating NPCs[/li]
[li]Updating ground items/world objects[/li]
[li]Updating shops[/li]
[li]Updating general server state[/li][/ul]

[size=6pt]major update[/size]
[size=6pt]minor update[/size]

The question is why the two entity updates are such large tasks. Overall, the server shouldn&#39;t be suffering from too much processing. Packet reading and processing is extremely fast, if done properly. Content and systematic implementations should preferably based on an event-driven system, thus reducing overall load on the server. So again, why is entity updating so tedious?

There is a technique that has been used over and over again in servers. To be frank, it actually disgusts me a little. Currently, servers update the positions of entities (and items/custom objects) by iterating across all the tiles (or positions) of the current player&#39;s viewport, then caching this player during the duration of the player update. This is done in one of two ways:


[ol][li]All registered players in the world are iterated across, then their positions are matched in relativity to that of the current players (classic implementation)[/li]
[li]A tiling system is implemented which stores the entities of that tile, thus allowing a reduced search for players (as shown in RS2D and other recent servers)[/li][/ol]


Both of these methods are extremely inefficient:

In the first scenario, every player is iterated across and their positions are compared in relativity to that of one player. If there are 1,000 players online, then there are 999 players to iterate across for 1,000 players. This means that there are 999,000 position comparisons for every player update, which occurs every 500-600 milliseconds, in addition to other server updates (depending on design, of course).

In the second scenario, the tiles within the player&#39;s view area are iterated across and are then monitored. Assuming that the viewport is approximately 30 tiles in diameter (or one side length, as the view area is treated as a square), then 900 tiles must be checked for every player. If one thousand players are online, this means that 900,000 tiles must be checked and contained entities cached. Another thing that must be considered in this system is how tiles are allocated. Generally, a large array is created for ease of use, as so:

[tt]new Tile[4000][4000];[/tt]

For those who are unaware, this array, with no entries, consumes 64,000,000 (4k * 4k * 4) bytes of memory, or 64 megabytes. This also only takes into consideration the default height level, nothing above or below it. As there are 4 known height levels, the above should really be modified to:

[tt]new Tile[4000][4000][4];[/tt]

This will consume 4 times more memory than the previous, or about 256 megabytes. Now, as I have seen no tile system properly cleanup unused tiles, we can assume that, at minimum, 50% of these tiles will be allocated on a server with 1,000 active players. If this is so, we can safely approximate the amount of memory a [tt]Tile[/tt] instance would consume is that of 50 bytes (a rough estimation, but these classes do have collection fields which also take up memory). If you are ahead of me, you would have modified the original equation to: ((4000 * 4000 * 4 * 4) + (((4000 * 4000 * 4) / 2) * 50), giving an incredible amount of 1,856,000,000 bytes of memory, or nearly 2 gigabytes. This is obviously a huge problem in player updating.

So, why has no one yet reduced the load of player updating from 900,000~ iterations per frame, or realized the incredible amount of memory a naive tiling system consumes?

I had a theory a few months ago, one that I had great difficulties in implementing. My theory was that entity list updating could be reduced one thousand fold simply by updating the list upon [i]movement notification[/i]. Using a design where the [i]World[/i] instance (assuming this object exists) is notified when a player moves, the world instance updates the tiles the player has moved from/to. I extended this design by also notifying the players of those tiles of the moved entity&#39;s whereabouts, creating a very efficient and demand-based updating system.

My World class file is provided below. This system is implemented in the 3 update methods. The primary update method, [tt]updateSquares[/tt], follows the same idea as update option 2 presented above utilizes. We iterate across the entire view area and notify the entities in this area of the movement change. However, this method is not used exclusively. In fact, it is only used when the entire region is reloaded. The other two methods, [tt]updateRows[/tt] and [tt]updateColumns[/tt], exist to reduce the usage of the larger iteration. These methods create an iteration count of 16 for a movement action, an extremely low amount of effort in the long scheme of things.

In order to reduce memory usage in such a tiling system, one should pool tiles for efficient usage of this object. Based on theory, if tiles are pooled and recycled, then there should only be [tt]((entityCount = playerCount + npcCount) + (otherCollections = droppedItemCount + customWorldObjects)) - interestedTiles[/tt] number of tiles allocated at any time. If there are 500 NPCs, 1,000 players, 250 dropped items, and 150 custom world objects, there are, at maximum, 1,900 tile objects allocated at any given time, excluding intersections (similar tiles used by multiple categories). If a tile instance takes up 50 bytes of memory, then this is only 95,000 bytes of memory, or 95k being used at any given time on a very active server.

[hr]

The above solutions are great, but they are only the start. They allow cpu usage to drop dramatically during entity updating, but they do not take into consideration the actual storage procedure of the entity lists for each entity. I won&#39;t try to approximate the amount of memory that is used based on the inefficient storage collections currently established. However, the easiest one to create is one that uses three collection [tt]List[/tt]s to store newly added, realized, and expired entities in a tentative fashion. However, this is quite a large amount of memory to be consumed for each and every entity, and is hardly recommended in my opinion.

In addition to the above lists, the most common way of iterating across collected players is by creating a new [tt]Iterator[/tt] instance for every update. Personally, I find creating a new object instance for every single entity every half second to be very, very bad news. So, to find a proper solution, one should realize that entities have unique slot positions for a reason.

The supplied [tt]EntityCollection[/tt] class allows for both intelligent storing of entities as well as very, very low memory usage. No new objects are needed, nor is many different arrays and positions required. Using very simple bit logic, this collection is extremely fast and lightweight, the ideal alternative to the very memory and processing intensive variation that is popular to use nowadays.

[hr]

The last and final speedup I can provide is that of proper appearance caching. Now, as this isn&#39;t as large of a speedup as the other provisions, it still should be addressed. Others have attempted to cache portions of the update procedure, but none to any considerable length.

The class provided last, [tt]Apparal[/tt], is one that uses the traditional method of storing appearance information (inside an integer array), but transforms the values so that they can be immediately written to the update packet without using another object (thus, to count the amount of bytes written). Although this is hardly considered &#39;caching&#39; the block, it surely speeds up the process slightly. It also moves the handling of appearance and equipment to another location, in an efficient manner.

The specific implementation path I took to achieve this goal was partially complicated, but it gets the job done, as it were. The appearance array inside this class is really constructed of integer bitmasks, which allow for multiple values to be stored as one value. This is a great way to save memory, but at the same time requires a little more processing power (in theory, there are some situations where these systems could be more efficient in memory and processing).

This is the first topic of several I intend on posting in this section. I originally wanted to include all of my server critiques in one topic, that is, until I realized how long the topic was becoming.

The following are classes referenced to from above:

[size=8pt][i]World.java[/i][/size]
[code=java]package org.jaghax.server.rs.world;

import java.util.Arrays;

import org.jaghax.server.util.Global;
import org.jaghax.server.util.pool.TilePool;

/**
 * A simple {@code World} class that incorporates the speedy movement
 * implementation.
 * 
 * @author Ben Henning
 */
public class World implements Global {

	private int id, playerCount;
	private Player[] players;
	private Tile[] tiles;
	private int[] tileLocators;

	public World(int id, int playerCapacity) {
		this.id = id;
		this.players = new Player[playerCapacity + 1];
		this.tiles = new Tile[10];
		this.tileLocators = new int[10];
	}

	public int getId() {
		return id;
	}

	public int getCapacity() {
		return players.length - 1;
	}

	public synchronized int register(Player player) {
		int nextSlot = -1;
		long id = player.getLongIdentifier();
		for (int i = 1; i &lt; players.length; i++) {
			Player next = players[i];
			if (next == null) {
				if (nextSlot == -1)
					nextSlot = i;
			} else if (next.getLongIdentifier() == id)
				return LOGIN_RESP_LOGGED_IN;
		}
		if (nextSlot == -1)
			return LOGIN_RESP_FULL;
		players[nextSlot] = player;
		player.setSlot(nextSlot);
		playerCount++;
		System.out.println(player + &quot; just logged in&quot;);
		return LOGIN_RESP_ACCEPTED;
	}

	public synchronized boolean unregister(Player player) {
		for (int i = 1; i &lt; players.length; i++)
			if (players[i] == player) {
				players[i] = null;
				playerCount--;
				System.out.println(player + &quot; just logged out&quot;);
				return true;
			}
		return false;
	}

	public synchronized void prepare(Player player) {
		int px = player.getX(), py = player.getY(), ph = player.getHeight();
		for (int y = py - 7, tY = py + 7; y &lt;= tY; y++)
			for (int x = px - 7, tX = px + 7; x &lt;= tX; x++) {
				Tile tile = locateExisting(x, y, ph);
				if (tile != null)
					for (Player plr : tile.players)
						if (plr != null)
							player.monitor(plr);
			}
	}

	public synchronized void unprepare(Player player) {
		int px = player.getX(), py = player.getY(), ph = player.getHeight();
		for (int y = py - 7, tY = py + 7; y &lt;= tY; y++)
			for (int x = px - 7, tX = px + 7; x &lt;= tX; x++) {
				Tile tile = locateExisting(x, y, ph);
				if (tile != null) {
					for (Player plr : tile.players)
						if (plr != null)
							plr.ignore(player);
					tile.exit(player);
				}
			}
	}

	public int getPlayerCount() {
		return playerCount;
	}

	public Player getPlayer(int slot) {
		return players[slot];
	}

	public Tile setLocation(Entity e, int x, int y, int h) {
		return setLocation(e, x, y, h, false);
	}

	public synchronized Tile setLocation(Entity e, int x, int y, int h,
			boolean regUpdate) {
		synchronized (e) {
			Tile tile = e.location;
			if (tile != null) {
				tile.exit(e);
				if (tile.playerCount == 0) {
					for (int i = 0; i &lt; tiles.length; i++)
						if (tiles[i] == tile) {
							tiles[i] = null;
							tileLocators[i] = 0;
							break;
						}
					TilePool.release(tile);
				}
				if (regUpdate)
					updateSquares(e, tile.x, tile.y, x, y, h, 0);
				else {
					int dX = tile.x - x, dY = tile.y - y;
					if (dX != 0)
						updateColumns(e, tile.x, tile.y, x, y, h, dX);
					if (dY != 0)
						updateRows(e, tile.x, tile.y, x, y, h, dY);
				}
			} else if (regUpdate)
				updateSquares(e, 0, 0, x, y, h, 1);
			tile = locate(x, y, h);
			tile.enter(e); // let&#39;s hope the entity isn&#39;t already here
			return tile;
		}
	}

	private void updateColumns(Entity e, int fromX, int fromY, int toX,
			int toY, int h, int distX) {
		fromX += distX * 14;
		for (int y = fromY - 13, tY = fromY + 13; y &lt;= tY; y++) {
			Tile tile = locateExisting(fromX, y, h);
			if (tile != null)
				tile.ignore(e);
		}
		toX += -distX * 14;
		for (int y = toY - 13, tY = toY + 13; y &lt;= tY; y++) {
			Tile tile = locateExisting(toX, y, h);
			if (tile != null)
				tile.monitor(e);
		}
	}

	private void updateRows(Entity e, int fromX, int fromY, int toX, int toY,
			int h, int distY) {
		fromY += distY * 14;
		for (int x = fromX - 13, tX = fromX + 13; x &lt;= tX; x++) {
			Tile tile = locateExisting(x, fromY, h);
			if (tile != null)
				tile.monitor(e);
		}
		toY += -distY * 14;
		for (int x = toX - 13, tX = toX + 13; x &lt;= tX; x++) {
			Tile tile = locateExisting(x, toY, h);
			if (tile != null)
				tile.ignore(e);
		}
	}

	private void updateSquares(Entity e, int fromX, int fromY, int toX,
			int toY, int h, int type) {
		if (type == 0 || type == 2)
			for (int y = fromY - 7, tY = fromY + 7; y &lt;= tY; y++)
				for (int x = fromX - 7, tX = fromX + 7; x &lt;= tX; x++) {
					Tile tile = locateExisting(x, y, h);
					if (tile != null)
						tile.ignore(e);
				}
		if (type == 0 || type == 1)
			for (int y = toY - 7, tY = toY + 7; y &lt;= tY; y++)
				for (int x = toX - 7, tX = toX + 7; x &lt;= tX; x++) {
					Tile tile = locateExisting(x, y, h);
					if (tile != null)
						tile.monitor(e);
				}
	}

	private Tile locate(int x, int y, int h) {
		int locator = x + (y &lt;&lt; 14) + (h &lt;&lt; 28);
		for (int i = 0; i &lt; tiles.length; i++)
			if (tileLocators[i] == locator)
				return tiles[i];
		int index = -1;
		for (int i = 0; i &lt; tiles.length; i++)
			if (tiles[i] == null) {
				index = i;
				break;
			}
		if (index == -1) {
			index = tiles.length;
			int newCap = index + (index &gt;&gt; 1);
			this.tiles = Arrays.copyOf(tiles, newCap);
			this.tileLocators = Arrays.copyOf(tileLocators, newCap);
		}
		tileLocators[index] = locator;
		return tiles[index] = TilePool.acquire(x, y, h);
	}

	private Tile locateExisting(int x, int y, int h) {
		// XXX: find a faster way to do this search
		int locator = x + (y &lt;&lt; 14) + (h &lt;&lt; 28);
		for (int i = 0; i &lt; tiles.length; i++) {
			if (tileLocators[i] == locator) {
				return tiles[i];
			}
		}
		return null;
	}
}
[/code]</description>
    
    <lastBuildDate>Fri, 19 Feb 2010 22:47:02 +0000</lastBuildDate>
    <category>Community Inside Talk</category>
    <atom:link href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>[quote=“oksuper_, post:23, topic:329855”][quote author=blakeman8192 link=topic=426238.msg3132062#msg3132062 date=1266595409]</p>
<aside class="quote no-group">
<blockquote>
<p>11:54 &lt;frank_&gt; dear anyone with access to <a href="http://www.moparisthebest.com/smf/index.php/topic,426238.0.html">http://www.moparisthebest.com/smf/index.php/topic,426238.0.html</a><br>
11:55 &lt;frank_&gt; please post that they should learn some datastructures and fucking use a bsp tree<br>
[/quote]why not a quadtree?</p>
</blockquote>
</aside>
<p>because he didn’t want a quadtree? afaik a bsp tree and quadtree are quite alike except that the bsp tree obviously is a BINARY tree while the quadtree is a QUATERNARY tree[/quote]quad tree is more fit for the regions etc imo</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/24">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/24</link>
        <pubDate>Fri, 19 Feb 2010 22:47:02 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-24</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@Jython super_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jython">@Jython</a> wrote:</p>
          <blockquote>
              <p>[quote=“blakeman8192, post:21, topic:329855”][quote author=sppt link=topic=426238.msg3131811#msg3131811 date=1266576964]<br>
11:54 &lt;frank_&gt; dear anyone with access to <a href="http://www.moparisthebest.com/smf/index.php/topic,426238.0.html" rel="nofollow noopener">http://www.moparisthebest.com/smf/index.php/topic,426238.0.html</a><br>
11:55 &lt;frank_&gt; please post that they should learn some datastructures and fucking use a bsp tree<br>
[/quote]why not a quadtree?[/quote]<br>
because he didn’t want a quadtree? afaik a bsp tree and quadtree are quite alike except that the bsp tree obviously is a BINARY tree while the quadtree is a QUATERNARY tree</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/23">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/23</link>
        <pubDate>Fri, 19 Feb 2010 22:24:15 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-23</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@moparisthebest Moparisthebest]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/moparisthebest">@moparisthebest</a> wrote:</p>
          <blockquote>
              <p>I haven’t studied the implementations yet, but this particular sentance struck me:</p>
<aside class="quote no-group" data-post="1" data-topic="329855">
<div class="title">
<div class="quote-controls"></div>
 Taharok:</div>
<blockquote>
<p>The specific implementation path I took to achieve this goal was partially complicated, but it gets the job done, as it were. The appearance array inside this class is really constructed of integer bitmasks, which allow for multiple values to be stored as one value. This is a great way to save memory, but at the same time requires a little more processing power (in theory, there are some situations where these systems could be more efficient in memory and processing).</p>
</blockquote>
</aside>
<p>I think that is a bad way to go, in these days and times, this isn’t still the 90s, memory is DIRT cheap and processing power is the more expensive of the two nowadays by far.  The dedicated server I own and use for IRC has 6 gigs of ram, and this web server has 16.  In a server nowadays, I would take less processing power for more RAM any day, although there is always a trade off between the two and you have to be smart about it, I just don’t think it is appropriate in this condition.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/22">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/22</link>
        <pubDate>Fri, 19 Feb 2010 18:27:43 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-22</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>[quote=“sppt, post:20, topic:329855”]11:54 &lt;frank_&gt; dear anyone with access to <a href="http://www.moparisthebest.com/smf/index.php/topic,426238.0.html">http://www.moparisthebest.com/smf/index.php/topic,426238.0.html</a><br>
11:55 &lt;frank_&gt; please post that they should learn some datastructures and fucking use a bsp tree[/quote]why not a quadtree?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/21">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/21</link>
        <pubDate>Fri, 19 Feb 2010 16:03:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-21</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@sppt sppt]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sppt">@sppt</a> wrote:</p>
          <blockquote>
              <p>11:54 &lt;frank_&gt; dear anyone with access to <a href="http://www.moparisthebest.com/smf/index.php/topic,426238.0.html">http://www.moparisthebest.com/smf/index.php/topic,426238.0.html</a><br>
11:55 &lt;frank_&gt; please post that they should learn some datastructures and fucking use a bsp tree</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/20">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/20</link>
        <pubDate>Fri, 19 Feb 2010 10:56:04 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-20</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@lothy Lothy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lothy">@lothy</a> wrote:</p>
          <blockquote>
              <aside class="quote no-group quote-modified" data-post="18" data-topic="329855">
<div class="title">
<div class="quote-controls"></div>
 la­wl:</div>
<blockquote>
<p>why would you keep a list of tiles? just separate map into regions, and put everything thats in one region into that array… i dont see the problem. this might be what lothy is talking about but i cbf reading his posts</p>
</blockquote>
</aside>
<p>Yeah, that’s it. Subscription based regions work well, imo. Graham has already implemented his own version of this which is pretty much as outlined above in the post by Vrunk (although Vrunk’s post was with regards to RSC servers, so his suggested region was smaller in keeping with the RSC client’s view area).</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/19">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/19</link>
        <pubDate>Fri, 19 Feb 2010 05:11:03 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-19</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@lawl lawl]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lawl">@lawl</a> wrote:</p>
          <blockquote>
              <p>why would you keep a list of tiles? just separate map into regions, and put everything thats in one region into that array… i dont see the problem. this might be what lothy is talking about but i cbf reading his posts</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/18">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/18</link>
        <pubDate>Fri, 19 Feb 2010 04:07:12 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-18</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>[center]<img src="http://frank.upinthisbit.ch/img/rollthy.gif" alt width="" height="">[/center]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/17">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/17</link>
        <pubDate>Fri, 19 Feb 2010 02:17:26 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-17</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@lothy Lothy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lothy">@lothy</a> wrote:</p>
          <blockquote>
              <p>Yeah, it hasn’t been going so well, has it? Mind you, I quoted that post for the other information it contains.<br>
If each region was 32x32 then there would be 125*125 regions, presuming the 4000x4000 tile count is correct and accounts for all game tiles. Graham has already implemented this solution, and it works. Information about the individual tiles (such as which way your character can exit a tile) only needs to be loaded when an entity, and specifically a mobile entity, is added to the region as a subscriber. The tile’s clipping information can be stored in a bitmask anyway though, so memory usage is minimal.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/16</link>
        <pubDate>Fri, 19 Feb 2010 01:12:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-16</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@Jython super_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jython">@Jython</a> wrote:</p>
          <blockquote>
              <p>darkstar rofl</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/15</link>
        <pubDate>Thu, 18 Feb 2010 23:33:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-15</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@lothy Lothy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lothy">@lothy</a> wrote:</p>
          <blockquote>
              <p><a class="mention" href="/u/stork">@Stork</a>: If you’re talking about the development of the region system, that discussion is in the hidden RSC dev section. <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> Taharok/blake/most people can’t see that section.</p>
<p>[quote=“Vrunk, post:6, topic:258397”][quote author=Lothy link=topic=341224.msg2641861#msg2641861 date=1232928069]<br>
I guess I should probably post some design goals. There’s a class called Area in the environment package. I’d like to remove the use of ActiveTile objects to store Player objects.<br>
We could break the map up based on how we believe the game would be used. For example, Tree Gnome Stronghold may not be a popular location in private servers - we have an Area that covers 200<em>200 tiles there. On the other hand Varrock might be highly popular, so we break the areas up into 50</em>50 tiles. ActiveTile objects would only exist to store items on the ground, and would be removed when the items are picked up.<br>
[/quote]</p>
<p>As much as I like using prediction to optimize the network traffic, optimization as fine-grained as that is something that should be saved until last.<br>
Not to beat a dead horse, but what I’d planned on doing for the old RSCDv_25 source is what I had in mind for the network traffic</p>
<p><img src="http://img72.imageshack.us/img72/3430/ss20081217184301cx4.png" alt width="" height=""></p>
<p>Blue box represents the viewport of Player A:</p>
<p>[ul][li]Located in Zone 3[/li]<br>
[li]Sends messages to Zone 3[/li]<br>
[li]Receives messages from Zones 2,3,5,6[/li][/ul]</p>
<p>Green box represents the viewport of Player B:</p>
<p>[ul][li]Located in Zone 2[/li]<br>
[li]Sends messages to Zone 2[/li]<br>
[li]Receives messages from Zones 1,2,4,5[/li][/ul]</p>
<p>[hr]</p>
<p>BDB is used in favor of MySQL simply for the speed that darkstar requires. There is an extension for the darkstar project that allows you to write somewhat of a mirror image of what is happening in BDB to a MySQL database lazily, simply so you can view it more easily. Perhaps that could be used eventually.[/quote]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/14</link>
        <pubDate>Thu, 18 Feb 2010 23:10:15 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-14</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>[quote=“Stork, post:10, topic:329855”]Shrugs, doesn’t sit well with me[quote author=blakeman8192 link=topic=426238.msg3131249#msg3131249 date=1266527081]</p>
<aside class="quote no-group">
<blockquote>
<p>Shrugs, don’t sit well with me when some newfag moparscaper pops up acting like hot shit with just a bunch of old poorly thought out ideas.</p>
<p>About the memory usage of a big Tile[][], fair enough. I’m used to RSCD servers where there’s just a 1000x4000 array. Still, could always just use a hashmap or summat.<br>
[/quote]erm, excuse me but, i’ve been around <span class="bbcode-b">these</span> forums about as long as you have (you have one month on me). not to mention kaitnieks.<br>
(i’m assuming you’re talking about me as there’s no way anybody in their right mind would call taharok a “newfag moparscaper”)</p>
<p>i’m not acting like hot shit either way. if i’m out of line to attempt to correct somebody (you) - and you’re calling me on it - then not only are you out of line for attempting to correct somebody (that person being Taharok, the poster of this thread), you’re also being a hypocrite for calling me out on something you yourself just did.</p>
<p>also a hashmap would use the same amount of memory as you’d still have that many objects anways, just instead of looking up tiles via their coordinates (they’re indexed to their coordinates) you’d be using hashing which is even less sensible imo</p>
</blockquote>
</aside>
<p>I was talking about taharok, silly.</p>
<p>Anyway the hashmap would only need to store non empty tiles, anything empty would just be a null value. Dunno about in rs2 but in rsc like 90% of the 4000x1000 map is empty space.[/quote]sorry for the misunderstanding xD</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/13</link>
        <pubDate>Thu, 18 Feb 2010 22:23:23 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-13</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@Jython super_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jython">@Jython</a> wrote:</p>
          <blockquote>
              <p>i think what taharok is trying to say is that we should excessively use redundant ‘pool’ classes for management of all kinds of resources. or that he is gay. both go hand in hand.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/12</link>
        <pubDate>Thu, 18 Feb 2010 22:18:21 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-12</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>[quote=“Stork, post:10, topic:329855”]Shrugs, doesn’t sit well with me[quote author=blakeman8192 link=topic=426238.msg3131249#msg3131249 date=1266527081]</p>
<aside class="quote no-group">
<blockquote>
<p>Shrugs, don’t sit well with me when some newfag moparscaper pops up acting like hot shit with just a bunch of old poorly thought out ideas.</p>
<p>About the memory usage of a big Tile[][], fair enough. I’m used to RSCD servers where there’s just a 1000x4000 array. Still, could always just use a hashmap or summat.<br>
[/quote]erm, excuse me but, i’ve been around <span class="bbcode-b">these</span> forums about as long as you have (you have one month on me). not to mention kaitnieks.<br>
(i’m assuming you’re talking about me as there’s no way anybody in their right mind would call taharok a “newfag moparscaper”)</p>
<p>i’m not acting like hot shit either way. if i’m out of line to attempt to correct somebody (you) - and you’re calling me on it - then not only are you out of line for attempting to correct somebody (that person being Taharok, the poster of this thread), you’re also being a hypocrite for calling me out on something you yourself just did.</p>
<p>also a hashmap would use the same amount of memory as you’d still have that many objects anways, just instead of looking up tiles via their coordinates (they’re indexed to their coordinates) you’d be using hashing which is even less sensible imo</p>
</blockquote>
</aside>
<p>I was talking about taharok, silly.</p>
<p>Anyway the hashmap would only need to store non empty tiles, anything empty would just be a null value. Dunno about in rs2 but in rsc like 90% of the 4000x1000 map is empty space.[/quote]</p>
<p><span class="mention">@being</span> newfag, I’ve been here nearly as long as blakeman. I can’t say I was around during kait times, but private servers hardly were then either.</p>
<p>As for the hashmap, that’s exactly what I am doing in the provided system. I create a unique hash based on the x, y, and z coordinates in order to locate a tile. Tiles are then recycled instead of being dereferenced, as this saves the number of times tile has to be constructed in the duration of the server.</p>
<p>The only negative part to the system is how tiles are located. Yes, my current method of locating a tile is somewhat high, but [tt]if_icmpne[/tt] is quite fast. I approximated the size of the tile at 1,900 for a 1,000 player server, thus the number of iterations required to update columns or rows of a moving player is 16 * 1,900 * 2, or 60,800. This is still <span class="bbcode-i">considerably</span> less than the current way.</p>
<p>In addition to reducing load using the specialized walking systems, you are also reducing list updating to nearly nothing if no players are moving. I really don’t see why you have such a problem with the system I provided, as it’s evidently faster and more efficient. <img src="https://forum.moparisthebest.com/images/emoji/twitter/expressionless.png?v=5" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
<p>Edit: It’s actually <span class="bbcode-i">up</span> to 60,800, as it will locate the tile before iterating across the entire array.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/11</link>
        <pubDate>Thu, 18 Feb 2010 22:15:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-11</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@Stork Stork]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/stork">@Stork</a> wrote:</p>
          <blockquote>
              <p>Shrugs, doesn’t sit well with me[quote=“blakeman8192, post:9, topic:329855”][quote author=Stork link=topic=426238.msg3131214#msg3131214 date=1266524469]<br>
Shrugs, don’t sit well with me when some newfag moparscaper pops up acting like hot shit with just a bunch of old poorly thought out ideas.</p>
<p>About the memory usage of a big Tile[][], fair enough. I’m used to RSCD servers where there’s just a 1000x4000 array. Still, could always just use a hashmap or summat.<br>
[/quote]erm, excuse me but, i’ve been around <span class="bbcode-b">these</span> forums about as long as you have (you have one month on me). not to mention kaitnieks.<br>
(i’m assuming you’re talking about me as there’s no way anybody in their right mind would call taharok a “newfag moparscaper”)</p>
<p>i’m not acting like hot shit either way. if i’m out of line to attempt to correct somebody (you) - and you’re calling me on it - then not only are you out of line for attempting to correct somebody (that person being Taharok, the poster of this thread), you’re also being a hypocrite for calling me out on something you yourself just did.</p>
<p>also a hashmap would use the same amount of memory as you’d still have that many objects anways, just instead of looking up tiles via their coordinates (they’re indexed to their coordinates) you’d be using hashing which is even less sensible imo[/quote]<br>
I was talking about taharok, silly.</p>
<p>Anyway the hashmap would only need to store non empty tiles, anything empty would just be a null value. Dunno about in rs2 but in rsc like 90% of the 4000x1000 map is empty space.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/10</link>
        <pubDate>Thu, 18 Feb 2010 21:58:51 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-10</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <p>[quote=“Stork, post:8, topic:329855”]Shrugs, don’t sit well with me when some newfag moparscaper pops up acting like hot shit with just a bunch of old poorly thought out ideas.</p>
<p>About the memory usage of a big Tile[][], fair enough. I’m used to RSCD servers where there’s just a 1000x4000 array. Still, could always just use a hashmap or summat.[/quote]erm, excuse me but, i’ve been around <span class="bbcode-b">these</span> forums about as long as you have (you have one month on me). not to mention kaitnieks.<br>
(i’m assuming you’re talking about me as there’s no way anybody in their right mind would call taharok a “newfag moparscaper”)</p>
<p>i’m not acting like hot shit either way. if i’m out of line to attempt to correct somebody (you) - and you’re calling me on it - then not only are you out of line for attempting to correct somebody (that person being Taharok, the poster of this thread), you’re also being a hypocrite for calling me out on something you yourself just did.</p>
<p>also a hashmap would use the same amount of memory as you’d still have that many objects anways, just instead of looking up tiles via their coordinates (they’re indexed to their coordinates) you’d be using hashing which is even less sensible imo</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/9</link>
        <pubDate>Thu, 18 Feb 2010 21:04:41 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-9</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@Stork Stork]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/stork">@Stork</a> wrote:</p>
          <blockquote>
              <p>Shrugs, don’t sit well with me when some newfag moparscaper pops up acting like hot shit with just a bunch of old poorly thought out ideas.</p>
<p>About the memory usage of a big Tile[][], fair enough. I’m used to RSCD servers where there’s just a 1000x4000 array. Still, could always just use a hashmap or summat.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/8</link>
        <pubDate>Thu, 18 Feb 2010 20:21:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-8</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@system system]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/system">@system</a> wrote:</p>
          <blockquote>
              <aside class="quote no-group quote-modified" data-post="6" data-topic="329855">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/stork/40/5_513041d5f7104045db30895d3b90af16.png" class="avatar"> Stork:</div>
<blockquote>
<p>To be frank, you’re a massive douche.</p>
</blockquote>
</aside>
<p>umad</p>
<blockquote>1) The community hasn't been productive? Well, yeah, I don't see you doing a lot (read: anything) about that. There have been plenty of developments - having skim read your posts I'm pretty sure all your exciting new 'innovations' have been discussed (possibly even implemented) before, so really mate the reason you think this place ain't productive is because you haven't been paying attention. If you had, you'd have realised what you're saying is old shoe.</blockquote>
in ratio to the amount of ability this community has, we really haven't done shit with the amount of time we've had imo
<blockquote>2) The tile system isn't as bad as you make out. In most implementations, un-used Tile instances in the Tile[][] array are nulled (and garbage collected) every 10 minutes or something so you'd never even get close to 2GB usage.</blockquote>
<p>false, this program alone uses &gt;600mb of memory:</p>
<pre><code class="lang-auto">public class Test
{

	private static Test[][][] testArray = new Test[4000][4000][4];

	public static void main(String[] args) throws Exception
	{
		for (;;)
		{
			System.gc();
			Thread.sleep(5000);
		}
	}

}</code></pre>
<blockquote>3) The reason the positions aren't changed as the player moves is because the player is only allowed to move once every 600ms (tick).</blockquote>
kk
<blockquote>4) So we've gone from a fixed (constant time = GOOD) 900 comparisons per player to a wildly varying number depending on god knows what (any estimates)? Looks like every time your players move, a call to the update rows/columns method iterates over the player's view (constant time) and then tries to look up tiles from an array (linear time!) so unless I got something wrong we've gone from O(constant) to O(constant * size of the tile array)....</blockquote>
i'm not sure if you're right but it's event based so it's not like it's doing it all at once during a giant update loop
<blockquote>5) FYI look into the Sector system that has been described before by numerous people (I remember a post by Lothy in this section) which looks to me to be a fuck ton simpler and more efficient than what you're suggesting.</blockquote>
never heard of it - link?
<blockquote>6) Have you heard of java's collections API? l2use. If you're gonna sacrifice correctness and readability for the sake of some minor speed improvements why the bloody hell are you writing this in Java anyway?</blockquote>
the java api on it's own is not as fast as possible as it's meant for general use - a custom class that does only what is needed and it optimized for it's purpose is better in almost every situation. i agree with you entirely on the "If you're gonna sacrifice correctness and readability for the sake of some minor speed improvements why the bloody hell are you writing this in Java anyway?" part.
<blockquote>Edit: 7) Silabsoft is right about storing tile values (walls, water, unwalkable, doors, etc) you're gonna have to be storing a LOT of those so good luck fitting all them in a linear unsorted list (seems like your 1900 tile estimate is a *little bit* off).</blockquote>
agreed
<p>no need to insult taharok though, seeing as he was just presenting a discussion and possible solutions to common problems for us to debate about. you kind of stepped out of line there by flaming him but who am i to say anything</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/7</link>
        <pubDate>Thu, 18 Feb 2010 19:38:01 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-7</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@Stork Stork]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/stork">@Stork</a> wrote:</p>
          <blockquote>
              <p>To be frank, you’re a massive douche.</p>
<ol>
<li>
<p>The community hasn’t been productive? Well, yeah, I don’t see you doing a lot (read: anything) about that. There have been plenty of developments - having skim read your posts I’m pretty sure all your exciting new ‘innovations’ have been discussed (possibly even implemented) before, so really mate the reason you think this place ain’t productive is because you haven’t been paying attention. If you had, you’d have realised what you’re saying is old shoe.</p>
</li>
<li>
<p>The tile system isn’t as bad as you make out. In most implementations, un-used Tile instances in the Tile[][] array are nulled (and garbage collected) every 10 minutes or something so you’d never even get close to 2GB usage.</p>
</li>
<li>
<p>The reason the positions aren’t changed as the player moves is because the player is only allowed to move once every 600ms (tick).</p>
</li>
<li>
<p>So we’ve gone from a fixed (constant time = GOOD) 900 comparisons per player to a wildly varying number depending on god knows what (any estimates)? Looks like every time your players move, a call to the update rows/columns method iterates over the player’s view (constant time) and then tries to look up tiles from an array (linear time!) so unless I got something wrong we’ve gone from O(constant) to O(constant * size of the tile array)…</p>
</li>
<li>
<p>FYI look into the Sector system that has been described before by numerous people (I remember a post by Lothy in this section) which looks to me to be a fuck ton simpler and more efficient than what you’re suggesting.</p>
</li>
<li>
<p>Have you heard of java’s collections API? l2use. If you’re gonna sacrifice correctness and readability for the sake of some minor speed improvements why the bloody hell are you writing this in Java anyway?</p>
</li>
</ol>
<p>Edit: 7) Silabsoft is right about storing tile values (walls, water, unwalkable, doors, etc) you’re gonna have to be storing a LOT of those so good luck fitting all them in a linear unsorted list (seems like your 1900 tile estimate is a <em>little bit</em> off).</p>
<p>o lawd.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/6</link>
        <pubDate>Thu, 18 Feb 2010 13:59:32 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-6</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@lothy Lothy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lothy">@lothy</a> wrote:</p>
          <blockquote>
              <p>You’re right. I haven’t had an in-depth look at your actual implementation, but the packet building methods that build the update packets shouldn’t have to do as much as they do… they really should be just polling another object for it’s information.</p>
<p>I might have a go at a solution myself sometime.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/5</link>
        <pubDate>Thu, 18 Feb 2010 12:02:38 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-5</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@Budda Budda]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/budda">@Budda</a> wrote:</p>
          <blockquote>
              <p>where do i put this in my client.java??</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/4</link>
        <pubDate>Thu, 18 Feb 2010 08:48:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-4</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@silabsoft RuneAgent]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/silabsoft">@silabsoft</a> wrote:</p>
          <blockquote>
              <p>I really do not see any reason to hold an array for every single tile. Instead only tiles in use should be accounted for and methods like wall checking should be processed only when the entity is moving.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/3</link>
        <pubDate>Thu, 18 Feb 2010 06:51:43 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-3</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>[size=8pt]<span class="bbcode-i">Tile.java</span>[/size]</p>
<p>[code=java]package org.jaghax.server.rs.world;</p>
<p>import java.util.Arrays;</p>
<p>public class Tile {</p>
<pre><code>public Tile next, previous;
public int x, y, height, startRegionX, startRegionY, regionX, regionY;
public int localX, localY, playerCount, droppedItems[], droppedAmounts[];
public Player[] players;

public Tile() {
	this.players = new Player[10]; // should be cached perhaps?
	this.droppedItems = new int[10]; // XXX: unimplemented
	this.droppedAmounts = new int[10]; // XXX: unimplemented
	Arrays.fill(droppedItems, -1);
}

public Tile(int x, int y, int h) {
	this();
	reset(x, y, h);
}

public void reset(int x, int y, int h) {
	this.x = x;
	this.y = y;
	this.height = h;
	this.regionX = (x &gt;&gt; 3) - 6;
	this.regionY = (y &gt;&gt; 3) - 6;
	this.startRegionX = regionX &lt;&lt; 3;
	this.startRegionY = regionY &lt;&lt; 3;
	this.localX = x - startRegionX;
	this.localY = y - startRegionY;
}

public synchronized void enter(Entity e) {
	if (!(e instanceof Player))
		return;
	int slot = -1;
	for (int i = 0; i &lt; players.length; i++)
		if (players[i] == null) {
			slot = i;
			break;
		}
	if (slot == -1) {
		slot = players.length;
		this.players = Arrays.copyOf(players, slot + (slot &gt;&gt; 1));
	}
	players[slot] = (Player) e;
	playerCount++;
}

public synchronized void exit(Entity e) {
	if (!(e instanceof Player))
		return;
	for (int i = 0; i &lt; players.length; i++)
		if (players[i] == e) {
			players[i] = null;
			playerCount--;
			return;
		}
}

public synchronized void addDroppedItem(int id, int amount) {
	int slot = -1;
	for (int i = 0; i &lt; droppedItems.length; i++)
		if (droppedItems[i] == -1) {
			slot = i;
			break;
		}
	if (slot == -1) {
		slot = droppedItems.length;
		this.droppedItems = Arrays.copyOf(droppedItems, slot + (slot &gt;&gt; 1));
		this.droppedAmounts = Arrays.copyOf(droppedAmounts, slot
				+ (slot &gt;&gt; 1));
	}
	droppedItems[slot] = id;
	droppedAmounts[slot] = amount;
	for (Player plr : players)
		if (plr != null)
			plr.issueGroundItem(id, amount, x, y);
}

public synchronized boolean removeDroppedItem(int id) {
	int slot = -1;
	for (int i = 0; i &lt; droppedItems.length; i++)
		if (droppedItems[i] == id) {
			slot = i;
			break;
		}
	if (slot == -1)
		return false;
	droppedItems[slot] = -1;
	droppedAmounts[slot] = 0;
	for (Player plr : players)
		if (plr != null)
			plr.removeGroundItem(id, x, y);
	return true;
}

public synchronized void monitor(Entity e) {
	if (e instanceof Player) {
		Player p = (Player) e;
		for (Player plr : players)
			if (plr != null) {
				plr.monitor(e);
				p.monitor(plr);
			}
		for (int i = 0; i &lt; droppedItems.length; i++) {
			int id = droppedItems[i];
			if (id != -1)
				p.issueGroundItem(id, droppedAmounts[i], x, y);
		}
	}
}

public synchronized void ignore(Entity e) {
	if (e instanceof Player) {
		Player p = (Player) e;
		for (Player plr : players)
			if (plr != null) {
				plr.ignore(e);
				p.ignore(plr);
			}
		for (int i = 0; i &lt; droppedItems.length; i++) {
			int id = droppedItems[i];
			if (id != -1)
				p.removeGroundItem(id, x, y);
		}
	}
}

@Override
public int hashCode() {
	return x + (y &lt;&lt; 14) + (height &lt;&lt; 28);
}

@Override
public String toString() {
	return toString(false);
}

public String toString(boolean verbose) {
	StringBuilder b = new StringBuilder("Tile[").append("x=").append(x)
			.append(", y=").append(y).append(", h=").append(height);
	if (verbose)
		b.append(", locX=").append(localX).append(", locY=").append(localY)
				.append(", regX=").append(regionX).append(", regY=")
				.append(regionY);
	return b.append(", loc=x").append(Integer.toHexString(hashCode()))
			.append(']').toString();
}
</code></pre>
<p>}<br>
[/code]</p>
<p>[size=8pt]<span class="bbcode-i">TilePool.java</span>[/size]</p>
<p>[code=java]package org.jaghax.server.util.pool;</p>
<p>import org.jaghax.server.rs.world.Tile;</p>
<p>public final class TilePool {</p>
<pre><code>private static Tile header;

static {
	header = new Tile();
	header.previous = header.next = header;
	synchronized (header) {
		for (int i = 0; i &lt; 5; i++)
			release(new Tile());
	}
}

public static Tile acquire(int x, int y, int h) {
	synchronized (header) {
		Tile node = header.next;
		if (node == header)
			return new Tile(x, y, h);
		node.previous.next = node.next;
		node.next.previous = node.previous;
		node.next = node.previous = null;
		node.reset(x, y, h);
		return node;
	}
}

public static void release(Tile node) {
	synchronized (header) {
		(node.previous = header.previous).next = node;
		(node.next = header).previous = node;
	}
}
</code></pre>
<p>}[/code]</p>
<p>[size=8pt]<span class="bbcode-i">EntityCollection.java</span>[/size]</p>
<p>[code=java]package org.jaghax.server.util;</p>
<p>import org.jaghax.server.rs.world.Entity;<br>
import org.jaghax.server.util.pool.IntArrayPool;</p>
<p>/**</p>
<ul>
<li>
<p>A very quick approach to tentatively monitoring entities.</p>
</li>
<li>
</li>
<li>
<p><span class="mention">@author</span> Ben Henning<br>
*/<br>
public class EntityCollection {</p>
<p>public static final int NON_ENTRY = 0;<br>
public static final int NEW_ENTRY = 1 &lt;&lt; 30;<br>
public static final int OLD_ENTRY = 1 &lt;&lt; 31;<br>
public static final int REGULAR_ENTRY = NEW_ENTRY | OLD_ENTRY;</p>
<p>private int[] entities;<br>
private int pending, entityCount, searchPos, searchAlpha, searchBeta;</p>
<p>public EntityCollection() {<br>
this.entities = IntArrayPool.acquire(10, true);<br>
}</p>
<p>public boolean add(Entity e) {<br>
int slot = -1, eslot = e.getSlot();<br>
for (int i = 0; i &lt; entities.length; i++) {<br>
int next;<br>
if (((next = entities[i]) &amp; 0xffff) == eslot)<br>
return false;<br>
else if (next == 0 &amp;&amp; slot == -1)<br>
slot = i;<br>
}<br>
if (slot == -1) {<br>
slot = entities.length;<br>
this.entities = IntArrayPool.copyOf(entities, slot + (slot &gt;&gt; 1));<br>
}<br>
entities[slot] = eslot | NEW_ENTRY;<br>
pending++;<br>
return true;<br>
}</p>
<p>public boolean remove(Entity e) {<br>
int eslot = e.getSlot();<br>
for (int i = 0; i &lt; entities.length; i++) {<br>
if ((entities[i] &amp; 0xffff) == eslot) {<br>
entities[i] = (eslot &amp; 0xffff) | OLD_ENTRY;<br>
return true;<br>
}<br>
}<br>
return false;<br>
}</p>
<p>public int indexOf(Entity e) {<br>
int eslot = e.getSlot();<br>
for (int i = 0; i &lt; entities.length; i++)<br>
if ((entities[i] &amp; 0xffff) == eslot)<br>
return i;<br>
return -1;<br>
}</p>
<p>public int statusOf(Entity e) {<br>
int eslot = e.getSlot();<br>
for (int i = 0; i &lt; entities.length; i++)<br>
if ((entities[i] &amp; 0xffff) == eslot)<br>
return entities[i] &gt;&gt;&gt; 30;<br>
return NON_ENTRY;<br>
}</p>
<p>public boolean isOfType(int search, int type) {<br>
type &gt;&gt;&gt;= 30;<br>
for (int i = 0; i &lt; entities.length; i++)<br>
if ((entities[i] &amp; 0xffff) == search)<br>
return (entities[i] &gt;&gt;&gt; 30) == type;<br>
return false;<br>
}</p>
<p>public void update() {<br>
for (int i = 0; i &lt; entities.length; i++) {<br>
int next = entities[i];<br>
int type = (next &gt;&gt;&gt; 30);<br>
switch (type) {<br>
case 1: // new entry<br>
entities[i] = next | REGULAR_ENTRY;<br>
entityCount++;<br>
pending–;<br>
break;<br>
case 2: // old entry<br>
entities[i] = 0;<br>
entityCount–;<br>
break;<br>
}<br>
}<br>
}</p>
<p>public int getPendingCount() {<br>
return pending;<br>
}</p>
<p>public int getListSize() {<br>
return entityCount;<br>
}</p>
<p>public boolean isEmpty() {<br>
return pending == 0 &amp;&amp; entityCount == 0;<br>
}</p>
<p>public void beginIter(int type) {<br>
this.searchAlpha = (type &gt;&gt; 30);<br>
this.searchBeta = 0;<br>
this.searchPos = 0;<br>
}</p>
<p>public void beginDualIter(int type1, int type2) {<br>
this.searchAlpha = (type1 &gt;&gt;&gt; 30);<br>
this.searchBeta = (type2 &gt;&gt;&gt; 30);<br>
this.searchPos = 0;<br>
}</p>
<p>public int nextEntity() {<br>
if (searchBeta != 0)<br>
while (searchPos &lt; entities.length) {<br>
int next = entities[searchPos++];<br>
int type = (next &gt;&gt;&gt; 30);<br>
if (type == searchAlpha || type == searchBeta)<br>
return next &amp; 0xffff;<br>
}<br>
else {<br>
while (searchPos &lt; entities.length) {<br>
int next = entities[searchPos++];<br>
if ((next &gt;&gt;&gt; 30) == searchAlpha)<br>
return next &amp; 0xffff;<br>
}<br>
}<br>
return -1;<br>
}</p>
<p><a class="mention" href="/u/override">@Override</a><br>
public void finalize() throws Throwable {<br>
super.finalize();<br>
IntArrayPool.release(entities);<br>
this.entities = null;<br>
}<br>
}<br>
[/code]</p>
</li>
</ul>
<p>[size=8pt]<span class="bbcode-i">Apparel.java</span>[/size]</p>
<p>[code=java]package org.jaghax.server.rs.world;</p>
<p>import org.jaghax.server.rs.net.PacketBuilder;<br>
import org.jaghax.server.util.Global;<br>
import org.jaghax.server.util.Items;<br>
import org.jaghax.server.util.pool.IntArrayPool;</p>
<p>public class Apparel extends ItemContainer implements Global {</p>
<pre><code>private static final int ofsGender = 0, ofsIcon = 1, ofsHat = 2,
		ofsCape = 3, ofsAmulet = 4, ofsWeapon = 5, ofsBody = 6,
		ofsShield = 7, ofsArms = 8, ofsLegs = 9, ofsHead = 10,
		ofsHands = 11, ofsFeet = 12, ofsJaw = 13, ofsHairColor = 14,
		ofsTorsoColor = 15, ofsLegsColor = 16, ofsFeetColor = 17,
		ofsSkinColor = 18;

private static final int[] equipXlate;
private Player context;
private int[] updatePacket;
private int updatePacketSize;

Apparel(Player player) {
	super(ITEMS_EQUIPMENT, 14);
	this.context = player;
	this.updatePacket = IntArrayPool.acquire(26, true);
	this.updatePacketSize = 44;
	setup();
}

public void setDefaultAppearance(boolean male) {
	if (male)
		setAppearance(0, 10, 18, 26, 33, 36, 42, 0, 0, 0, 0, 0);
	else
		setAppearance(45, 255, 56, 61, 67, 70, 79, 0, 0, 0, 0, 0);
	setGender(male);
}

private void setup() {
	updatePacket[19] = PLR_STAND_ANIMATION &lt;&lt; 9;
	updatePacket[20] = PLR_STAND_TURN_ANIMATION &lt;&lt; 9;
	updatePacket[21] = PLR_WALK_ANIMATION &lt;&lt; 9;
	updatePacket[22] = PLR_TURN_180_ANIMATION &lt;&lt; 9;
	updatePacket[23] = PLR_TURN_90_CLOCKWISE_ANIMATION &lt;&lt; 9;
	updatePacket[24] = PLR_TURN_90_ANTICLOCKWISE_ANIMATION &lt;&lt; 9;
	updatePacket[25] = PLR_RUN_ANIMATION &lt;&lt; 9;
}

public void dump(PacketBuilder builder) {
	builder.putI(updatePacketSize);
	for (int i = 0; i &lt; 26; i++) {
		int next = updatePacket[i];
		if (next == 0)
			builder.put(0);
		else if (next &lt; 0)
			builder.put(-next);
		else if (next &gt; 0x1ff)
			builder.putShort(next &gt;&gt; 9);
		else
			builder.putShort(next &amp; 0x1ff);
	}
	builder.putLong(context.getLongIdentifier()).put(3).putShort(0);
}

public boolean isMale() {
	return updatePacket[ofsGender] == 0;
}

public void setGender(boolean male) {
	int last = updatePacket[ofsGender];
	updatePacket[ofsGender] = male ? 0 : -1;
	if ((last == 0) ^ male) {
		last = updatePacket[ofsJaw];
		if (last != 0)
			updatePacketSize--;
		updatePacket[ofsJaw] = 0;
	}
}

public int getHeadIcon() {
	return -updatePacket[ofsIcon];
}

public void setHeadIcon(int icon) {
	updatePacket[ofsIcon] = -icon;
}

public int getHead() {
	return updatePacket[ofsHead];
}

public void setHead(int value) {
	setApprComp(ofsHead, value);
	context.setAppearanceUpdate(true);
}

public int getJaw() {
	return updatePacket[ofsJaw];
}

public void setJaw(int value) {
	if (updatePacket[ofsGender] == -1)
		value = -1;
	setApprComp(ofsJaw, value);
	context.setAppearanceUpdate(true);
}

public int getTorso() {
	return updatePacket[ofsBody] &amp; 0x1ff;
}

public void setTorso(int value) {
	setApprComp(ofsBody, value);
	context.setAppearanceUpdate(true);
}

public int getArms() {
	return updatePacket[ofsArms];
}

public void setArms(int value) {
	if (getItem(EQUIP_BODY) != -1)
		value = 0;
	setApprComp(ofsArms, value);
	context.setAppearanceUpdate(true);
}

public int getHands() {
	return updatePacket[ofsHands] &amp; 0x1ff;
}

public void setHands(int value) {
	setApprComp(ofsHands, value);
	context.setAppearanceUpdate(true);
}

public int getLegs() {
	return updatePacket[ofsLegs] &amp; 0x1ff;
}

public void setLegs(int value) {
	setApprComp(ofsLegs, value);
	context.setAppearanceUpdate(true);
}

public int getFeet() {
	return updatePacket[ofsFeet] &amp; 0x1ff;
}

public void setFeet(int value) {
	setApprComp(ofsFeet, value);
	context.setAppearanceUpdate(true);
}

public int getHairColor() {
	return -updatePacket[ofsHairColor];
}

public void setHairColor(int value) {
	updatePacket[ofsHairColor] = -value;
	context.setAppearanceUpdate(true);
}

public int getTorsoColor() {
	return -updatePacket[ofsTorsoColor];
}

public void setTorsoColor(int value) {
	updatePacket[ofsTorsoColor] = -value;
	context.setAppearanceUpdate(true);
}

public int getLegsColor() {
	return -updatePacket[ofsLegsColor];
}

public void setLegsColor(int value) {
	updatePacket[ofsLegsColor] = -value;
	context.setAppearanceUpdate(true);
}

public int getSkinColor() {
	return -updatePacket[ofsSkinColor];
}

public void setSkinColor(int value) {
	updatePacket[ofsSkinColor] = -value;
	context.setAppearanceUpdate(true);
}

public int getFeetColor() {
	return -updatePacket[ofsFeetColor];
}

public void setFeetColor(int value) {
	updatePacket[ofsFeetColor] = -value;
	context.setAppearanceUpdate(true);
}

public void setAppearance(int head, int jaw, int torso, int arms,
		int hands, int legs, int feet, int hairColor, int torsoColor,
		int legsColor, int skinColor, int feetColor) {
	setApprComp(ofsHead, head);
	setApprComp(ofsJaw, updatePacket[ofsGender] != 0 ? -1 : jaw);
	setApprComp(ofsBody, torso);
	setApprComp(ofsArms, getItem(EQUIP_BODY) != -1 ? 0 : arms);
	context.setAppearanceUpdate(true);
	setApprComp(ofsHands, hands);
	setApprComp(ofsLegs, legs);
	setApprComp(ofsFeet, feet);
	updatePacket[ofsHairColor] = -hairColor;
	updatePacket[ofsTorsoColor] = -torsoColor;
	updatePacket[ofsLegsColor] = -legsColor;
	updatePacket[ofsSkinColor] = -skinColor;
	updatePacket[ofsFeetColor] = -feetColor;
	context.setAppearanceUpdate(true);
}

public int getHat() {
	return getItem(EQUIP_HAT);
}

public int setHat(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_HAT, id, 1, true);
	send(context);
	return slot;
}

public int getCape() {
	return getItem(EQUIP_CAPE);
}

public int setCape(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_CAPE, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getAmulet() {
	return getItem(EQUIP_AMULET);
}

public int setAmulet(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_AMULET, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getMissiles() {
	return getItem(EQUIP_MISSILES);
}

public int setMissiles(int id, int amount) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_MISSILES, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getWeapon() {
	return getItem(EQUIP_WEAPON);
}

public boolean isArmed() {
	return getItem(EQUIP_WEAPON) != -1;
}

public int setWeapon(int id) {
	return setWeapon(id, 1);
}

public int setWeapon(int id, int amount) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_WEAPON, id, amount, true);
	refresh(context, true);
	context.issueAttackInterface(id);
	return slot;
}

public int getBody() {
	return getItem(EQUIP_BODY);
}

public int setBody(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_BODY, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getShield() {
	return getItem(EQUIP_SHIELD);
}

public int setShield(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_SHIELD, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getLegsEquip() {
	return getItem(EQUIP_LEGS);
}

public int setLegsEquip(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_LEGS, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getGloves() {
	return getItem(EQUIP_GLOVES);
}

public int setGloves(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_GLOVES, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getBoots() {
	return getItem(EQUIP_BOOTS);
}

public int setBoots(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_BOOTS, id, 1, true);
	refresh(context, true);
	return slot;
}

public int getRing() {
	return getItem(EQUIP_RING);
}

public int setRing(int id) {
	context.setAppearanceUpdate(true);
	int slot = set(EQUIP_RING, id, 1, true);
	refresh(context, true);
	return slot;
}

public boolean isEquipped(int type) {
	return getItem(type) != -1;
}

public boolean isItemEquipped(int id) {
	return getItem(Items.getEquipmentType(id)) != -1;
}

@Override
void setItem(int slot, int id, int amount, int countFactor) {
	super.setItem(slot, id, amount, countFactor);
	slot = equipXlate[slot];
	if (slot == -1)
		return;
	int last = updatePacket[slot];
	if (id != -1) {
		if (last == 0)
			updatePacketSize++; // short-size
		id += 0x200;
	} else {
		if (last != 0)
			updatePacketSize--; // byte-size
		id = 0;
	}
	if (slot == ofsBody) {
		last = updatePacket[ofsArms];
		if (last != 0) {
			updatePacket[ofsArms] = 0;
			updatePacketSize--;
		}
	}
	updatePacket[slot] = (updatePacket[slot] &amp; 0x1ff) | (id &lt;&lt; 9);
	context.setAppearanceUpdate(true);
}

private final void setApprComp(int index, int value) {
	int last = updatePacket[index];
	if (value != -1) {
		if (last == 0)
			updatePacketSize++; // short-size
		value += 0x100;
	} else {
		if (last != 0)
			updatePacketSize--; // byte-size
		value = 0;
	}
	updatePacket[index] = (updatePacket[index] &amp; 0xfffffe00) | value;
}

@Override
public void finalize() throws Throwable {
	super.finalize();
	IntArrayPool.release(updatePacket);
	this.context = null;
	this.updatePacket = null;
}

static {
	equipXlate = new int[14];
	equipXlate[EQUIP_HAT] = ofsHat;
	equipXlate[EQUIP_CAPE] = ofsCape;
	equipXlate[EQUIP_AMULET] = ofsAmulet;
	equipXlate[EQUIP_MISSILES] = -1;
	equipXlate[EQUIP_WEAPON] = ofsWeapon;
	equipXlate[EQUIP_BODY] = ofsBody;
	equipXlate[EQUIP_SHIELD] = ofsShield;
	equipXlate[EQUIP_LEGS] = ofsLegs;
	equipXlate[EQUIP_GLOVES] = ofsHands;
	equipXlate[EQUIP_BOOTS] = ofsFeet;
	equipXlate[EQUIP_RING] = -1;
}
</code></pre>
<p>}<br>
[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/2</link>
        <pubDate>Thu, 18 Feb 2010 06:17:34 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-2</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
      <item>
        <title>Player updating: major speedups</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>As a forward, I am only disclosing these findings with the hope that some of you may find use for it, but I don’t expect anything to actually come from any of the following information and opinions. This community has never been very productive, but for the very slim chance that this changes, the following may be found very useful.</p>
<p>First of all, it seems that game updating is the most tedious of all processes that the server has to do. When breaking it down, we see that game updating generally includes, but isn’t limited to, the following tasks:</p>
<p>[ul][li]Updating players[/li]<br>
[li]Updating NPCs[/li]<br>
[li]Updating ground items/world objects[/li]<br>
[li]Updating shops[/li]<br>
[li]Updating general server state[/li][/ul]</p>
<p>[size=6pt]major update[/size]<br>
[size=6pt]minor update[/size]</p>
<p>The question is why the two entity updates are such large tasks. Overall, the server shouldn’t be suffering from too much processing. Packet reading and processing is extremely fast, if done properly. Content and systematic implementations should preferably based on an event-driven system, thus reducing overall load on the server. So again, why is entity updating so tedious?</p>
<p>There is a technique that has been used over and over again in servers. To be frank, it actually disgusts me a little. Currently, servers update the positions of entities (and items/custom objects) by iterating across all the tiles (or positions) of the current player’s viewport, then caching this player during the duration of the player update. This is done in one of two ways:</p>
<p>[ol][li]All registered players in the world are iterated across, then their positions are matched in relativity to that of the current players (classic implementation)[/li]<br>
[li]A tiling system is implemented which stores the entities of that tile, thus allowing a reduced search for players (as shown in RS2D and other recent servers)[/li][/ol]</p>
<p>Both of these methods are extremely inefficient:</p>
<p>In the first scenario, every player is iterated across and their positions are compared in relativity to that of one player. If there are 1,000 players online, then there are 999 players to iterate across for 1,000 players. This means that there are 999,000 position comparisons for every player update, which occurs every 500-600 milliseconds, in addition to other server updates (depending on design, of course).</p>
<p>In the second scenario, the tiles within the player’s view area are iterated across and are then monitored. Assuming that the viewport is approximately 30 tiles in diameter (or one side length, as the view area is treated as a square), then 900 tiles must be checked for every player. If one thousand players are online, this means that 900,000 tiles must be checked and contained entities cached. Another thing that must be considered in this system is how tiles are allocated. Generally, a large array is created for ease of use, as so:</p>
<p>[tt]new Tile[4000][4000];[/tt]</p>
<p>For those who are unaware, this array, with no entries, consumes 64,000,000 (4k * 4k * 4) bytes of memory, or 64 megabytes. This also only takes into consideration the default height level, nothing above or below it. As there are 4 known height levels, the above should really be modified to:</p>
<p>[tt]new Tile[4000][4000][4];[/tt]</p>
<p>This will consume 4 times more memory than the previous, or about 256 megabytes. Now, as I have seen no tile system properly cleanup unused tiles, we can assume that, at minimum, 50% of these tiles will be allocated on a server with 1,000 active players. If this is so, we can safely approximate the amount of memory a [tt]Tile[/tt] instance would consume is that of 50 bytes (a rough estimation, but these classes do have collection fields which also take up memory). If you are ahead of me, you would have modified the original equation to: ((4000 * 4000 * 4 * 4) + (((4000 * 4000 * 4) / 2) * 50), giving an incredible amount of 1,856,000,000 bytes of memory, or nearly 2 gigabytes. This is obviously a huge problem in player updating.</p>
<p>So, why has no one yet reduced the load of player updating from 900,000~ iterations per frame, or realized the incredible amount of memory a naive tiling system consumes?</p>
<p>I had a theory a few months ago, one that I had great difficulties in implementing. My theory was that entity list updating could be reduced one thousand fold simply by updating the list upon <span class="bbcode-i">movement notification</span>. Using a design where the <span class="bbcode-i">World</span> instance (assuming this object exists) is notified when a player moves, the world instance updates the tiles the player has moved from/to. I extended this design by also notifying the players of those tiles of the moved entity’s whereabouts, creating a very efficient and demand-based updating system.</p>
<p>My World class file is provided below. This system is implemented in the 3 update methods. The primary update method, [tt]updateSquares[/tt], follows the same idea as update option 2 presented above utilizes. We iterate across the entire view area and notify the entities in this area of the movement change. However, this method is not used exclusively. In fact, it is only used when the entire region is reloaded. The other two methods, [tt]updateRows[/tt] and [tt]updateColumns[/tt], exist to reduce the usage of the larger iteration. These methods create an iteration count of 16 for a movement action, an extremely low amount of effort in the long scheme of things.</p>
<p>In order to reduce memory usage in such a tiling system, one should pool tiles for efficient usage of this object. Based on theory, if tiles are pooled and recycled, then there should only be [tt]((entityCount = playerCount + npcCount) + (otherCollections = droppedItemCount + customWorldObjects)) - interestedTiles[/tt] number of tiles allocated at any time. If there are 500 NPCs, 1,000 players, 250 dropped items, and 150 custom world objects, there are, at maximum, 1,900 tile objects allocated at any given time, excluding intersections (similar tiles used by multiple categories). If a tile instance takes up 50 bytes of memory, then this is only 95,000 bytes of memory, or 95k being used at any given time on a very active server.</p>
<p>[hr]</p>
<p>The above solutions are great, but they are only the start. They allow cpu usage to drop dramatically during entity updating, but they do not take into consideration the actual storage procedure of the entity lists for each entity. I won’t try to approximate the amount of memory that is used based on the inefficient storage collections currently established. However, the easiest one to create is one that uses three collection [tt]List[/tt]s to store newly added, realized, and expired entities in a tentative fashion. However, this is quite a large amount of memory to be consumed for each and every entity, and is hardly recommended in my opinion.</p>
<p>In addition to the above lists, the most common way of iterating across collected players is by creating a new [tt]Iterator[/tt] instance for every update. Personally, I find creating a new object instance for every single entity every half second to be very, very bad news. So, to find a proper solution, one should realize that entities have unique slot positions for a reason.</p>
<p>The supplied [tt]EntityCollection[/tt] class allows for both intelligent storing of entities as well as very, very low memory usage. No new objects are needed, nor is many different arrays and positions required. Using very simple bit logic, this collection is extremely fast and lightweight, the ideal alternative to the very memory and processing intensive variation that is popular to use nowadays.</p>
<p>[hr]</p>
<p>The last and final speedup I can provide is that of proper appearance caching. Now, as this isn’t as large of a speedup as the other provisions, it still should be addressed. Others have attempted to cache portions of the update procedure, but none to any considerable length.</p>
<p>The class provided last, [tt]Apparal[/tt], is one that uses the traditional method of storing appearance information (inside an integer array), but transforms the values so that they can be immediately written to the update packet without using another object (thus, to count the amount of bytes written). Although this is hardly considered ‘caching’ the block, it surely speeds up the process slightly. It also moves the handling of appearance and equipment to another location, in an efficient manner.</p>
<p>The specific implementation path I took to achieve this goal was partially complicated, but it gets the job done, as it were. The appearance array inside this class is really constructed of integer bitmasks, which allow for multiple values to be stored as one value. This is a great way to save memory, but at the same time requires a little more processing power (in theory, there are some situations where these systems could be more efficient in memory and processing).</p>
<p>This is the first topic of several I intend on posting in this section. I originally wanted to include all of my server critiques in one topic, that is, until I realized how long the topic was becoming.</p>
<p>The following are classes referenced to from above:</p>
<p>[size=8pt]<span class="bbcode-i">World.java</span>[/size]</p>
<p>[code=java]package org.jaghax.server.rs.world;</p>
<p>import java.util.Arrays;</p>
<p>import org.jaghax.server.util.Global;<br>
import org.jaghax.server.util.pool.TilePool;</p>
<p>/**</p>
<ul>
<li>
<p>A simple {<a class="mention" href="/u/code">@code</a> World} class that incorporates the speedy movement</p>
</li>
<li>
<p>implementation.</p>
</li>
<li>
</li>
<li>
<p><span class="mention">@author</span> Ben Henning<br>
*/<br>
public class World implements Global {</p>
<p>private int id, playerCount;<br>
private Player[] players;<br>
private Tile[] tiles;<br>
private int[] tileLocators;</p>
<p>public World(int id, int playerCapacity) {<br>
this.id = id;<br>
this.players = new Player[playerCapacity + 1];<br>
this.tiles = new Tile[10];<br>
this.tileLocators = new int[10];<br>
}</p>
<p>public int getId() {<br>
return id;<br>
}</p>
<p>public int getCapacity() {<br>
return players.length - 1;<br>
}</p>
<p>public synchronized int register(Player player) {<br>
int nextSlot = -1;<br>
long id = player.getLongIdentifier();<br>
for (int i = 1; i &lt; players.length; i++) {<br>
Player next = players[i];<br>
if (next == null) {<br>
if (nextSlot == -1)<br>
nextSlot = i;<br>
} else if (next.getLongIdentifier() == id)<br>
return LOGIN_RESP_LOGGED_IN;<br>
}<br>
if (nextSlot == -1)<br>
return LOGIN_RESP_FULL;<br>
players[nextSlot] = player;<br>
player.setSlot(nextSlot);<br>
playerCount++;<br>
System.out.println(player + " just logged in");<br>
return LOGIN_RESP_ACCEPTED;<br>
}</p>
<p>public synchronized boolean unregister(Player player) {<br>
for (int i = 1; i &lt; players.length; i++)<br>
if (players[i] == player) {<br>
players[i] = null;<br>
playerCount–;<br>
System.out.println(player + " just logged out");<br>
return true;<br>
}<br>
return false;<br>
}</p>
<p>public synchronized void prepare(Player player) {<br>
int px = player.getX(), py = player.getY(), ph = player.getHeight();<br>
for (int y = py - 7, tY = py + 7; y &lt;= tY; y++)<br>
for (int x = px - 7, tX = px + 7; x &lt;= tX; x++) {<br>
Tile tile = locateExisting(x, y, ph);<br>
if (tile != null)<br>
for (Player plr : tile.players)<br>
if (plr != null)<br>
player.monitor(plr);<br>
}<br>
}</p>
<p>public synchronized void unprepare(Player player) {<br>
int px = player.getX(), py = player.getY(), ph = player.getHeight();<br>
for (int y = py - 7, tY = py + 7; y &lt;= tY; y++)<br>
for (int x = px - 7, tX = px + 7; x &lt;= tX; x++) {<br>
Tile tile = locateExisting(x, y, ph);<br>
if (tile != null) {<br>
for (Player plr : tile.players)<br>
if (plr != null)<br>
plr.ignore(player);<br>
tile.exit(player);<br>
}<br>
}<br>
}</p>
<p>public int getPlayerCount() {<br>
return playerCount;<br>
}</p>
<p>public Player getPlayer(int slot) {<br>
return players[slot];<br>
}</p>
<p>public Tile setLocation(Entity e, int x, int y, int h) {<br>
return setLocation(e, x, y, h, false);<br>
}</p>
<p>public synchronized Tile setLocation(Entity e, int x, int y, int h,<br>
boolean regUpdate) {<br>
synchronized (e) {<br>
Tile tile = e.location;<br>
if (tile != null) {<br>
tile.exit(e);<br>
if (tile.playerCount == 0) {<br>
for (int i = 0; i &lt; tiles.length; i++)<br>
if (tiles[i] == tile) {<br>
tiles[i] = null;<br>
tileLocators[i] = 0;<br>
break;<br>
}<br>
TilePool.release(tile);<br>
}<br>
if (regUpdate)<br>
updateSquares(e, tile.x, tile.y, x, y, h, 0);<br>
else {<br>
int dX = tile.x - x, dY = tile.y - y;<br>
if (dX != 0)<br>
updateColumns(e, tile.x, tile.y, x, y, h, dX);<br>
if (dY != 0)<br>
updateRows(e, tile.x, tile.y, x, y, h, dY);<br>
}<br>
} else if (regUpdate)<br>
updateSquares(e, 0, 0, x, y, h, 1);<br>
tile = locate(x, y, h);<br>
tile.enter(e); // let’s hope the entity isn’t already here<br>
return tile;<br>
}<br>
}</p>
<p>private void updateColumns(Entity e, int fromX, int fromY, int toX,<br>
int toY, int h, int distX) {<br>
fromX += distX * 14;<br>
for (int y = fromY - 13, tY = fromY + 13; y &lt;= tY; y++) {<br>
Tile tile = locateExisting(fromX, y, h);<br>
if (tile != null)<br>
tile.ignore(e);<br>
}<br>
toX += -distX * 14;<br>
for (int y = toY - 13, tY = toY + 13; y &lt;= tY; y++) {<br>
Tile tile = locateExisting(toX, y, h);<br>
if (tile != null)<br>
tile.monitor(e);<br>
}<br>
}</p>
<p>private void updateRows(Entity e, int fromX, int fromY, int toX, int toY,<br>
int h, int distY) {<br>
fromY += distY * 14;<br>
for (int x = fromX - 13, tX = fromX + 13; x &lt;= tX; x++) {<br>
Tile tile = locateExisting(x, fromY, h);<br>
if (tile != null)<br>
tile.monitor(e);<br>
}<br>
toY += -distY * 14;<br>
for (int x = toX - 13, tX = toX + 13; x &lt;= tX; x++) {<br>
Tile tile = locateExisting(x, toY, h);<br>
if (tile != null)<br>
tile.ignore(e);<br>
}<br>
}</p>
<p>private void updateSquares(Entity e, int fromX, int fromY, int toX,<br>
int toY, int h, int type) {<br>
if (type == 0 || type == 2)<br>
for (int y = fromY - 7, tY = fromY + 7; y &lt;= tY; y++)<br>
for (int x = fromX - 7, tX = fromX + 7; x &lt;= tX; x++) {<br>
Tile tile = locateExisting(x, y, h);<br>
if (tile != null)<br>
tile.ignore(e);<br>
}<br>
if (type == 0 || type == 1)<br>
for (int y = toY - 7, tY = toY + 7; y &lt;= tY; y++)<br>
for (int x = toX - 7, tX = toX + 7; x &lt;= tX; x++) {<br>
Tile tile = locateExisting(x, y, h);<br>
if (tile != null)<br>
tile.monitor(e);<br>
}<br>
}</p>
<p>private Tile locate(int x, int y, int h) {<br>
int locator = x + (y &lt;&lt; 14) + (h &lt;&lt; 28);<br>
for (int i = 0; i &lt; tiles.length; i++)<br>
if (tileLocators[i] == locator)<br>
return tiles[i];<br>
int index = -1;<br>
for (int i = 0; i &lt; tiles.length; i++)<br>
if (tiles[i] == null) {<br>
index = i;<br>
break;<br>
}<br>
if (index == -1) {<br>
index = tiles.length;<br>
int newCap = index + (index &gt;&gt; 1);<br>
this.tiles = Arrays.copyOf(tiles, newCap);<br>
this.tileLocators = Arrays.copyOf(tileLocators, newCap);<br>
}<br>
tileLocators[index] = locator;<br>
return tiles[index] = TilePool.acquire(x, y, h);<br>
}</p>
<p>private Tile locateExisting(int x, int y, int h) {<br>
// XXX: find a faster way to do this search<br>
int locator = x + (y &lt;&lt; 14) + (h &lt;&lt; 28);<br>
for (int i = 0; i &lt; tiles.length; i++) {<br>
if (tileLocators[i] == locator) {<br>
return tiles[i];<br>
}<br>
}<br>
return null;<br>
}<br>
}<br>
[/code]</p>
</li>
</ul>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/player-updating-major-speedups/329855/1</link>
        <pubDate>Thu, 18 Feb 2010 06:14:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-329855-1</guid>
        <source url="https://forum.moparisthebest.com/t/player-updating-major-speedups/329855.rss">Player updating: major speedups</source>
      </item>
  </channel>
</rss>
