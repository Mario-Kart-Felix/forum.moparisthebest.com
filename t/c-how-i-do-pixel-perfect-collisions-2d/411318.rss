<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>C# - How I do Pixel-Perfect Collisions (2D)</title>
    <link>https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318</link>
    <description>One thing I promised Frell was a tutorial on how I do my collisions. They&#39;re not perfect, but they do provide decent framerates.

Because there&#39;s a large amount of code and it&#39;s sort of complicated, I won&#39;t explain it all completely. Instead, I&#39;ll post the code and give an outline on what it does. The code I&#39;ll be providing is from my 2D game engine.

[i]Class: CollisionMask[i] - This class holds all the important information regarding collisions and is capable of actually checking whether or not a mask actually collides with another one. Here&#39;s the code for it:
[code]using System;
using System.ComponentModel;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using Microsoft.Xna.Framework.Net;
using Microsoft.Xna.Framework.Storage;
using Microsoft.Xna.Framework.Graphics.PackedVector;

using Level_Engine_Online.Graphics;

namespace Level_Engine_Online.Objects
{
	public class CollisionMask
	{
		public bool[, ,] MaskValues { get; set; }

		public CollisionMask(Vector2 size, Image i)
		{
			MaskValues = new bool[1, (int)size.X, (int)size.Y];
			//Read the pixels to scan the transparent ones
			Byte4[] storage = new Byte4[(int)size.X * (int)size.Y];

			if (i != null)
			{
				i.BaseTexture.GetData&lt;Byte4&gt;(storage);
				for (int y = 0; y &lt; (int)size.Y; y++)
				{
					for (int x = 0; x &lt; (int)size.X; x++)
					{
						if (storage[x + (y * (int)size.X)].PackedValue != 0)
							MaskValues[0, x, y] = true;
					}
				}
			}
		}

		public CollisionMask(Image i, Vector2 frameSize, int hFrames, int vFrames)
		{
			int frameCount = hFrames * vFrames;
			MaskValues = new bool[frameCount, (int)frameSize.X, (int)frameSize.Y];
			//Read the pixels to scan the transparent ones
			Byte4[] storage = new Byte4[(int)i.Width * (int)i.Height];

			if (i != null)
			{
				i.BaseTexture.GetData&lt;Byte4&gt;(storage);
				int f = 0;
				for (int yFrame = 0; yFrame &lt; vFrames; yFrame++)
				{
					for (int xFrame = 0; xFrame &lt; hFrames; xFrame++)
					{
						f = xFrame + (yFrame * hFrames);
						for (int y = 0; y &lt; frameSize.Y; y++)
						{
							for (int x = 0; x &lt; frameSize.X; x++)
							{
								if (storage[(xFrame * (int)frameSize.X) + x + (yFrame * i.Width * (int)frameSize.Y) + (y * i.Width)].PackedValue != 0)
									MaskValues[f, x, y] = true;
							}
						}
					}
				}
			}
		}

		public bool CollidesWithMask(CollisionMask other, int thisFrame, int otherFrame, Vector2 thisSize, Vector2 otherSize, Rectangle boundryThis, Rectangle boundryOther)
		{
			int checkX = 0;
			int checkY = 0;

			for (int yy = 0; yy &lt; (int)thisSize.Y; yy++)
			{
				checkX = 0;
				if (boundryThis.Y + yy &gt;= boundryOther.Y + boundryOther.Height)
					break;
				for (int xx = 0; xx &lt; (int)thisSize.X; xx++)
				{
					if (boundryThis.X + xx &gt;= boundryOther.X + boundryOther.Width) //If left + X goes out of the bounds of the other object...
						break;
					if (MaskValues[thisFrame, xx, yy] == false)
						continue;
					if (boundryThis.Y + yy &gt;= boundryOther.Y &amp;&amp; boundryThis.X + xx &gt;= boundryOther.X)
					{
						if (boundryThis.Y + yy &gt; boundryOther.Y)
						{
							checkY = boundryThis.Y - boundryOther.Y + yy;
						}
						if (boundryThis.X + xx &gt; boundryOther.X)
						{
							checkX = boundryThis.X - boundryOther.X + xx;
						}
						if (other.MaskValues[otherFrame, checkX, checkY] == true)
							return true;
						checkX++;
					}
				}
				if (checkX &gt; 0)
				{
					checkY++;
				}
			}

			return false;
		}
	}
}
[/code]

Past all the imports, a 3-dimensional array is declared, with the first dimension as the frame index, second X, third Y. If any of the values is true, the pixel is solid. Next, the constructor calculates what&#39;s solid and what&#39;s not by checking each pixel, and if it&#39;s not transparent, it qualifies. The second constructor does the same but for animations with the entire sheet provided. By scanning the image and caching the results, collision checking can be made faster.

The method checking if two masks collide is where things get a little tricky. By providing boundaries, only the parts intersecting will be compared. This also saves time. Inside the method the collision masks are looped through skipping the parts that don&#39;t intersect and the corresponding dimension indexes are calculated. From there it&#39;s just a simple compare and the job is done.

Outside of this class, only call the CollidesWithMask method if the boundaries intersect at all, or else you&#39;re wasting processing time.

So there ya go. All of the code is pretty much straightforward, so I feel I don&#39;t have to elaborate on it too much. Don&#39;t feel hesitated to convert this code to whatever you&#39;re writing your game in and use it.

~Lin</description>
    
    <lastBuildDate>Mon, 22 Aug 2011 19:55:29 +0000</lastBuildDate>
    <category>Game Development</category>
    <atom:link href="https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>C# - How I do Pixel-Perfect Collisions (2D)</title>
        <dc:creator><![CDATA[@xryz xryz]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xryz">@xryz</a> wrote:</p>
          <blockquote>
              <p>nice. thx. ill look more in to this when i have the time.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318/3</link>
        <pubDate>Mon, 22 Aug 2011 19:55:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-411318-3</guid>
        <source url="https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318.rss">C# - How I do Pixel-Perfect Collisions (2D)</source>
      </item>
      <item>
        <title>C# - How I do Pixel-Perfect Collisions (2D)</title>
        <dc:creator><![CDATA[@Morx Morx]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/morx">@Morx</a> wrote:</p>
          <blockquote>
              <p>Pretty intresting, Thanks for posting this.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318/2</link>
        <pubDate>Sun, 21 Aug 2011 04:13:43 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-411318-2</guid>
        <source url="https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318.rss">C# - How I do Pixel-Perfect Collisions (2D)</source>
      </item>
      <item>
        <title>C# - How I do Pixel-Perfect Collisions (2D)</title>
        <dc:creator><![CDATA[@Lin Lin]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lin">@Lin</a> wrote:</p>
          <blockquote>
              <p>One thing I promised Frell was a tutorial on how I do my collisions. They’re not perfect, but they do provide decent framerates.</p>
<p>Because there’s a large amount of code and it’s sort of complicated, I won’t explain it all completely. Instead, I’ll post the code and give an outline on what it does. The code I’ll be providing is from my 2D game engine.</p>
<p>[i]Class: CollisionMask[i] - This class holds all the important information regarding collisions and is capable of actually checking whether or not a mask actually collides with another one. Here’s the code for it:</p>
<p>[code]using System;<br>
using System.ComponentModel;<br>
using System.Collections.Generic;<br>
using Microsoft.Xna.Framework;<br>
using Microsoft.Xna.Framework.Audio;<br>
using Microsoft.Xna.Framework.Content;<br>
using Microsoft.Xna.Framework.GamerServices;<br>
using Microsoft.Xna.Framework.Graphics;<br>
using Microsoft.Xna.Framework.Input;<br>
using Microsoft.Xna.Framework.Media;<br>
using <a href="http://Microsoft.Xna.Framework.Net" rel="nofollow noopener">Microsoft.Xna.Framework.Net</a>;<br>
using Microsoft.Xna.Framework.Storage;<br>
using Microsoft.Xna.Framework.Graphics.PackedVector;</p>
<p>using Level_Engine_Online.Graphics;</p>
<p>namespace Level_Engine_Online.Objects<br>
{<br>
public class CollisionMask<br>
{<br>
public bool[, ,] MaskValues { get; set; }</p>
<pre><code>	public CollisionMask(Vector2 size, Image i)
	{
		MaskValues = new bool[1, (int)size.X, (int)size.Y];
		//Read the pixels to scan the transparent ones
		Byte4[] storage = new Byte4[(int)size.X * (int)size.Y];

		if (i != null)
		{
			i.BaseTexture.GetData&lt;Byte4&gt;(storage);
			for (int y = 0; y &lt; (int)size.Y; y++)
			{
				for (int x = 0; x &lt; (int)size.X; x++)
				{
					if (storage[x + (y * (int)size.X)].PackedValue != 0)
						MaskValues[0, x, y] = true;
				}
			}
		}
	}

	public CollisionMask(Image i, Vector2 frameSize, int hFrames, int vFrames)
	{
		int frameCount = hFrames * vFrames;
		MaskValues = new bool[frameCount, (int)frameSize.X, (int)frameSize.Y];
		//Read the pixels to scan the transparent ones
		Byte4[] storage = new Byte4[(int)i.Width * (int)i.Height];

		if (i != null)
		{
			i.BaseTexture.GetData&lt;Byte4&gt;(storage);
			int f = 0;
			for (int yFrame = 0; yFrame &lt; vFrames; yFrame++)
			{
				for (int xFrame = 0; xFrame &lt; hFrames; xFrame++)
				{
					f = xFrame + (yFrame * hFrames);
					for (int y = 0; y &lt; frameSize.Y; y++)
					{
						for (int x = 0; x &lt; frameSize.X; x++)
						{
							if (storage[(xFrame * (int)frameSize.X) + x + (yFrame * i.Width * (int)frameSize.Y) + (y * i.Width)].PackedValue != 0)
								MaskValues[f, x, y] = true;
						}
					}
				}
			}
		}
	}

	public bool CollidesWithMask(CollisionMask other, int thisFrame, int otherFrame, Vector2 thisSize, Vector2 otherSize, Rectangle boundryThis, Rectangle boundryOther)
	{
		int checkX = 0;
		int checkY = 0;

		for (int yy = 0; yy &lt; (int)thisSize.Y; yy++)
		{
			checkX = 0;
			if (boundryThis.Y + yy &gt;= boundryOther.Y + boundryOther.Height)
				break;
			for (int xx = 0; xx &lt; (int)thisSize.X; xx++)
			{
				if (boundryThis.X + xx &gt;= boundryOther.X + boundryOther.Width) //If left + X goes out of the bounds of the other object...
					break;
				if (MaskValues[thisFrame, xx, yy] == false)
					continue;
				if (boundryThis.Y + yy &gt;= boundryOther.Y &amp;&amp; boundryThis.X + xx &gt;= boundryOther.X)
				{
					if (boundryThis.Y + yy &gt; boundryOther.Y)
					{
						checkY = boundryThis.Y - boundryOther.Y + yy;
					}
					if (boundryThis.X + xx &gt; boundryOther.X)
					{
						checkX = boundryThis.X - boundryOther.X + xx;
					}
					if (other.MaskValues[otherFrame, checkX, checkY] == true)
						return true;
					checkX++;
				}
			}
			if (checkX &gt; 0)
			{
				checkY++;
			}
		}

		return false;
	}
}
</code></pre>
<p>}<br>
[/code]</p>
<p>Past all the imports, a 3-dimensional array is declared, with the first dimension as the frame index, second X, third Y. If any of the values is true, the pixel is solid. Next, the constructor calculates what’s solid and what’s not by checking each pixel, and if it’s not transparent, it qualifies. The second constructor does the same but for animations with the entire sheet provided. By scanning the image and caching the results, collision checking can be made faster.</p>
<p>The method checking if two masks collide is where things get a little tricky. By providing boundaries, only the parts intersecting will be compared. This also saves time. Inside the method the collision masks are looped through skipping the parts that don’t intersect and the corresponding dimension indexes are calculated. From there it’s just a simple compare and the job is done.</p>
<p>Outside of this class, only call the CollidesWithMask method if the boundaries intersect at all, or else you’re wasting processing time.</p>
<p>So there ya go. All of the code is pretty much straightforward, so I feel I don’t have to elaborate on it too much. Don’t feel hesitated to convert this code to whatever you’re writing your game in and use it.</p>
<p>~Lin</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318/1</link>
        <pubDate>Sun, 21 Aug 2011 03:50:01 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-411318-1</guid>
        <source url="https://forum.moparisthebest.com/t/c-how-i-do-pixel-perfect-collisions-2d/411318.rss">C# - How I do Pixel-Perfect Collisions (2D)</source>
      </item>
  </channel>
</rss>
