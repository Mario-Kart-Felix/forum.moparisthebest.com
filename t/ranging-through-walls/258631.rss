<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Ranging through walls</title>
    <link>https://forum.moparisthebest.com/t/ranging-through-walls/258631</link>
    <description>A) I&#39;m not a 100% sure this works properly. Going to test on DQ tonightish, so I&#39;ll get back to you on it, but as far as my testing went, it works. 
B) Big thanks goes to KO9 for help with the maths formula. 

[code]
package org.darkquest.server.event;

import java.util.ArrayList;

import org.darkquest.server.model.InvItem;
import org.darkquest.server.model.Item;
import org.darkquest.server.model.Mob;
import org.darkquest.server.model.Npc;
import org.darkquest.server.model.Player;
import org.darkquest.server.model.Point;
import org.darkquest.server.model.Projectile;
import org.darkquest.server.model.TileValue;
import org.darkquest.server.states.Action;
import org.darkquest.server.util.DataConversions;
import org.darkquest.server.util.Formulae;

public class RangeEvent extends DelayedEvent {
	private Mob affectedMob;
	private boolean firstRun = true;

	public RangeEvent(Player owner, Mob affectedMob) {
		super(owner, 2000);
		this.affectedMob = affectedMob;
	}
	private Item getArrows(int id) {
		for(Item i : world.getTile(affectedMob.getLocation()).getItems()) {
			if(i.getID() == id &amp;&amp; i.visibleTo(owner) &amp;&amp; !i.isRemoved()) {
				return i;
			}
		}
		return null;
	}

	public void run() {
		int bowID = owner.getRangeEquip();
		if(!owner.loggedIn() || (affectedMob instanceof Player &amp;&amp; !((Player)affectedMob).loggedIn()) || affectedMob.getHits() &lt;= 0 || !owner.checkAttack(affectedMob, true) || bowID &lt; 0) {
			owner.resetRange();
			return;
		}
		if(owner.withinRange(affectedMob, 5)) {
			if(owner.isFollowing()) {
				owner.resetFollowing();
			}
			if(!owner.finishedPath()) {
				owner.resetPath();
			}
		}
		else {
			owner.setFollowing(affectedMob);
			return;
		}
		boolean xbow = DataConversions.inArray(Formulae.xbowIDs, bowID);
		int arrowID = -1;
		for(int aID : (xbow ? Formulae.boltIDs : Formulae.arrowIDs)) {
			int slot = owner.getInventory().getLastIndexById(aID);
			if(slot &lt; 0) {
				continue;
			}
			InvItem arrow = owner.getInventory().get(slot);
			if(arrow == null) { // This shouldn&#39;t happen
				continue;
			}
			arrowID = aID;
			int newAmount = arrow.getAmount() - 1;
			if(newAmount &lt;= 0) {
				owner.getInventory().remove(slot);
				owner.getActionSender().sendInventory();
			}
			else {
				arrow.setAmount(newAmount);
				owner.getActionSender().sendUpdateItem(slot);
			}
			break;
		}
		if(arrowID &lt; 0) {
			owner.getActionSender().sendMessage(&quot;You have run out of &quot; + (xbow ? &quot;bolts&quot; : &quot;arrows&quot;));
			owner.resetRange();
			return;
		}
		int playerAx = owner.getX();
		int playerAy = owner.getY();
		int playerBx = affectedMob.getX();
		int playerBy = affectedMob.getY();
		int[] path = new int[2];
		path[0] = owner.getX();
		path[1] = owner.getY();
		for(int x=(playerAx+1); x &lt; (playerBx+1); x++)
			{
			int y = ((((playerBy - playerAy) * (x - playerAx)) / (playerBx - playerAx)) + playerAy);
			if (isBlocking(x, y, getDirection(new Point(path[0],path[1]),new Point(x,y)))) 
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}
		path[0] = affectedMob.getX();
		path[1] = affectedMob.getY();
		for(int x=(playerBx+1); x &lt; (playerAx+1); x++)
			{
			int y = ((((playerBy - playerAy) * (x - playerAx)) / (playerBx - playerAx)) + playerAy);
			if (isBlocking(x, y, getDirection(new Point(x,y),new Point(path[0],path[1])))) 
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}
		path[0] = owner.getX();
		path[1] = owner.getY();
		for(int y=playerAy+1; y &lt; playerBy+1; y++)
			{
			int x = (((y - playerAy) * (playerBx - playerAx)) / (playerBy - playerAy)) + playerAx;
			if (isBlocking(x, y, getDirection(new Point(path[0],path[1]),new Point(x,y))))
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}
		path[0] = owner.getX();
		path[1] = owner.getY();
		for(int y=playerAy-1; y &gt; playerBy-1; y--)
			{
			int x = (((y - playerAy) * (playerBx - playerAx)) / (playerBy - playerAy)) + playerAx;
			if (isBlocking(x, y, getDirection(new Point(x,y),new Point(path[0],path[1])))) 
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}		
		if(affectedMob.isPrayerActivated(13))
			{
			owner.getActionSender().sendMessage(&quot;Your missiles are blocked&quot;);
			owner.resetRange();
			return;
			}
		if(affectedMob instanceof Npc &amp;&amp; owner instanceof Player) // We&#39;re ranging an NPC, so make it chase the player.
			{
			final Npc npc = (Npc)affectedMob;

             //Radius is 0 to prevent wallhacking by NPCs. Easiest method I can come up with for now.

			if(!npc.getWalking() &amp;&amp; !npc.isBusy())
				{
				npc.setWalking(true);
				world.getDelayedEventHandler().add(new WalkMobToMobEvent(affectedMob, owner, 0)
					{
					public void arrived()
						{
						Player player = (Player)affectedMob;
						npc.resetPath();
						if(player.isBusy())
							return;

						player.resetPath();
						player.resetAll();
						player.setStatus(Action.FIGHTING_MOB);
						player.getActionSender().sendMessage(&quot;You are under attack!&quot;);

						npc.setLocation(player.getLocation(), true);
						for(Player p : npc.getViewArea().getPlayersInView())
							p.removeWatchedNpc(npc);

						player.setBusy(true);
						player.setSprite(9);
						player.setOpponent(npc);
						player.setCombatTimer();

						npc.setBusy(true);
						npc.setWalking(false);
						npc.setSprite(8);
						npc.setOpponent(player);
						npc.setCombatTimer();
						FightEvent fighting = new FightEvent(player, npc, true);
						fighting.setLastRun(0);
						world.getDelayedEventHandler().add(fighting);
						}
					});
				}
			}

		int damage = Formulae.calcRangeHit(owner.getCurStat(4), owner.getRangePoints(), affectedMob.getArmourPoints(), arrowID);
		if(!Formulae.looseArrow(damage)) {
			Item arrows = getArrows(arrowID);
			if(arrows == null) {
				world.registerItem(new Item(arrowID, affectedMob.getX(), affectedMob.getY(), 1, owner));
			}
			else {
				arrows.setAmount(arrows.getAmount() + 1);
			}
		}
		if(firstRun) {
			firstRun = false;
			if(affectedMob instanceof Player) {
				((Player)affectedMob).getActionSender().sendMessage(owner.getUsername() + &quot; is shooting at you!&quot;);
			}
		}
		Projectile projectile = new Projectile(owner, affectedMob, 2);
  		affectedMob.setLastDamage(damage);
  		int newHp = affectedMob.getHits() - damage;
  		affectedMob.setHits(newHp);
  		ArrayList&lt;Player&gt; playersToInform = new ArrayList&lt;Player&gt;();
  		playersToInform.addAll(owner.getViewArea().getPlayersInView());
  		playersToInform.addAll(affectedMob.getViewArea().getPlayersInView());
  		for(Player p : playersToInform) {
  			p.informOfProjectile(projectile);
  			p.informOfModifiedHits(affectedMob);
  		}
  		if(affectedMob instanceof Player) {
  			Player affectedPlayer = (Player)affectedMob;
  			affectedPlayer.getActionSender().sendStat(3);
		}
		owner.getActionSender().sendSound(&quot;shoot&quot;);
		owner.setArrowFired();
  		if(newHp &lt;= 0) {
  			affectedMob.killedBy(owner, false);
  			int exp = Formulae.combatExperience(affectedMob);
  			owner.incExp(4, exp, true);
  			owner.getActionSender().sendStat(4);
  			owner.resetRange();
  		}
	}
	private boolean isBlocking(int x, int y, int bit) 
		{
		TileValue t = world.getTileValue(x, y);
		if(bit == SOUTHWEST) 
			{
			TileValue p1 = world.getTileValue(x-1, y-1);
			TileValue p2 = world.getTileValue(x, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)SOUTH)) { return true; }
			p1 = world.getTileValue(x, y-1);
			p2 = world.getTileValue(x-1, y);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p2.mapValue, (byte)WEST)) { return true; }
			p1 = world.getTileValue(x-1, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p1.mapValue, (byte)WEST)) { return true; }
			}
		else if(bit == SOUTHEAST) 
			{
			TileValue p1 = world.getTileValue(x+1, y-1);
			TileValue p2 = world.getTileValue(x, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)SOUTH)) { return true; }
			p1 = world.getTileValue(x, y-1);
			p2 = world.getTileValue(x+1, y);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)EAST)) { return true; }
			p1 = world.getTileValue(x+1, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p1.mapValue, (byte)EAST)) { return true; }
			
			}
		else if(bit == NORTHEAST) 
			{
			TileValue p1 = world.getTileValue(x+1, y-1);
			TileValue p2 = world.getTileValue(x, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)NORTH)) { return true; }
			p1 = world.getTileValue(x, y-1);
			p2 = world.getTileValue(x-1, y);
			if(isBlocking(p1.mapValue, (byte)EAST) &amp;&amp; isBlocking(p2.mapValue, (byte)NORTH)) { return true; }
			p1 = world.getTileValue(x+1, y+1);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p1.mapValue, (byte)EAST)) { return true; }
			}
		else if(bit == NORTHWEST) 
			{
			TileValue p1 = world.getTileValue(x+1, y+1);
			TileValue p2 = world.getTileValue(x, y+1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)NORTH)) { return true; }
			p1 = world.getTileValue(x, y+1);
			p2 = world.getTileValue(x-1, y);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p2.mapValue, (byte)WEST)) { return true; }
			p1 = world.getTileValue(x-1, y+1);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p1.mapValue, (byte)WEST)) { return true; }
			}
		return isBlocking(t.mapValue, (byte)bit);
		}
	public static final int NONE=0, NORTH=1, NORTHEAST=2, EAST=3, 
	SOUTHEAST=4, SOUTH=5, SOUTHWEST=6, WEST=7, NORTHWEST=8;
	private boolean isBlocking(byte val, byte bit) {
		if((val &amp; bit) != 0) { // There is a wall in the way
			return true;
		}
		if((val &amp; 16) != 0) { // There is a diagonal wall here: \
			return true;
		}
		if((val &amp; 32) != 0) { // There is a diagonal wall here: /
			return true;
		}
		if((val &amp; 64) != 0) { // This tile is unwalkable
			return true;
		}
		return false;
	}
	public int getDirection(Point p1, Point p2) 
		{
		//System.out.print(p1.getX() + &quot; - &quot; + p2.getX()  + &quot; | &quot; + p1.getY() + &quot; - &quot; + p2.getY());
		if(p1 == null) { return NONE; }
		int direction = NONE;
		int x1 = p1.getX(), y1 = p1.getY(),
			x2 = p2.getX(), y2 = p2.getY();
		int dX = x2 - x1,
			dY = y2 - y1;
		if(dX == 0 &amp;&amp; dY == -1)
			direction = NORTH;
		else if(dX == -1 &amp;&amp; dY == -1)
			direction = NORTHEAST;
		else if(dX == -1 &amp;&amp; dY == 0)
			direction = EAST;
		else if(dX == -1 &amp;&amp; dY == 1)
			direction = SOUTHEAST;
		else if(dX == 0 &amp;&amp; dY == 1)
			direction = SOUTH;
		else if(dX == 1 &amp;&amp; dY == 1)
			direction = SOUTHWEST;
		else if(dX == 1 &amp;&amp; dY == 0)
			direction = WEST;
		else if(dX == 1 &amp;&amp; dY == -1)
			direction = NORTHWEST;
		//System.out.print(&quot; | &quot; + printDir(direction) + &quot;(&quot; + direction + &quot;)&quot;);
		//System.out.println();
		return direction;
	}

	public static String printDir(int dir) 
		{
		if(dir == 0) { return &quot;NONE&quot;; }
		if(dir == 1) { return &quot;NORTH&quot;; }
		if(dir == 2) { return &quot;NORTHEAST&quot;; }
		if(dir == 3) { return &quot;EAST&quot;; }
		if(dir == 4) { return &quot;SOUTHEAST&quot;; }
		if(dir == 5) { return &quot;SOUTH&quot;; }
		if(dir == 6) { return &quot;SOUTHWEST&quot;; }
		if(dir == 7) { return &quot;WEST&quot;; }
		if(dir == 8) { return &quot;NORTHWEST&quot;; }
		return &quot;NONE&quot;;
		}
	public Mob getAffectedMob() {
		return affectedMob;
	}

	public boolean equals(Object o) {
		if(o instanceof RangeEvent) {
			RangeEvent e = (RangeEvent)o;
			return e.belongsTo(owner);
		}
		return false;
	}
}
[/code]</description>
    
    <lastBuildDate>Tue, 27 Jan 2009 17:28:43 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/ranging-through-walls/258631.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Ranging through walls</title>
        <dc:creator><![CDATA[@Peter Peeter]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/peter">@Peter</a> wrote:</p>
          <blockquote>
              <p>GameObjects and walls are different things. GameObjects basically take over an entire tile, while walls can either take 1 side (N/W/E/S) or the entire tile (diagonally).</p>
<p>With walls, you have to get point a and point b, then calculate the direction from a to b and then check if there is a wall blocking that direction.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ranging-through-walls/258631/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ranging-through-walls/258631/5</link>
        <pubDate>Tue, 27 Jan 2009 17:28:43 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-258631-5</guid>
        <source url="https://forum.moparisthebest.com/t/ranging-through-walls/258631.rss">Ranging through walls</source>
      </item>
      <item>
        <title>Ranging through walls</title>
        <dc:creator><![CDATA[@KO9 KO9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ko9">@KO9</a> wrote:</p>
          <blockquote>
              <p>Meh you should read the code Pets posted xEnt. We developed a way to return each tile from A -&gt; B</p>
<p>But he used isBlocking() code instead of just checking if that tile has a wall on it. Yeah I thought that walls may not be registered as GameObjects but I couldn’t be arsed to read the TileValue code to find out the correct method to use. Was really just an example of what I think should be done.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ranging-through-walls/258631/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ranging-through-walls/258631/4</link>
        <pubDate>Tue, 27 Jan 2009 12:13:47 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-258631-4</guid>
        <source url="https://forum.moparisthebest.com/t/ranging-through-walls/258631.rss">Ranging through walls</source>
      </item>
      <item>
        <title>Ranging through walls</title>
        <dc:creator><![CDATA[@xEnt xEnt]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/xent">@xEnt</a> wrote:</p>
          <blockquote>
              <p>if(object.getID() == wall)</p>
<p>you mean door? as a wall is not an object. I havn’t looked far into the server boundarys etc, but does each tile have somewhere of knowing if theres a wall on it or not? If so maybe you could write a formula… something like this</p>
<p>Ranger = O, Npc = x</p>
<p>x</p>
<hr>
<p>O</p>
<p>obviously there is a wall in the way, now im sure you could write an array with each tile in that line you see right there, the one O is on, the one the fence is on in front, the blank one in front of that and the NPC one, then check each tile if it has a vertical/horizontal wall (depending on the way they are ranging</p>
<p>I understand if situations are something like</p>
<p>x</p>
<hr>
<pre><code>     O
</code></pre>
<p>it will be trickier to get the correct tiles in line, but possible.</p>
<p>I might be talking trash here, it might even make sense who knows.[br][br][size=1]Posted on: January 27, 2009, 05:45:36 am[/size][hr]p.s peter, learn to indent. at least ctrl + i.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ranging-through-walls/258631/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ranging-through-walls/258631/3</link>
        <pubDate>Tue, 27 Jan 2009 11:44:19 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-258631-3</guid>
        <source url="https://forum.moparisthebest.com/t/ranging-through-walls/258631.rss">Ranging through walls</source>
      </item>
      <item>
        <title>Ranging through walls</title>
        <dc:creator><![CDATA[@KO9 KO9]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ko9">@KO9</a> wrote:</p>
          <blockquote>
              <p>GJ, thanks also to EmErgE on securitychat for spending ages explaining the maths behind it ;D[br][br][size=1]Posted on: January 26, 2009, 02:57:00 pm[/size][hr]I still think it’s a better idea to check each tiles value instead of copying the isBlocking() method. I just tested this and if I open a door in the building I’m in I can range through the wall (because I am able to walk there) whereas if you check each tiles object from me to them, it wouldn’t matter.</p>
<pre><code class="lang-auto">if (isRangeable(path[0],path[1])) 

private boolean isRangeable(int x, int y) {
final GameObject object = world.getTile(x, y);
if(object.getID() == wall) { return false; }
else { return true; }
}</code></pre>
<p>Not sure if a wall will return like that though… That would be the best way to do it though imo or the equivilent of that.</p>
<p>Don’t even comment on the indenting Pets, I wrote it in this text box and it wouldn’t let me tab &gt;_&gt;</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ranging-through-walls/258631/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ranging-through-walls/258631/2</link>
        <pubDate>Mon, 26 Jan 2009 19:31:43 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-258631-2</guid>
        <source url="https://forum.moparisthebest.com/t/ranging-through-walls/258631.rss">Ranging through walls</source>
      </item>
      <item>
        <title>Ranging through walls</title>
        <dc:creator><![CDATA[@Peter Peeter]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/peter">@Peter</a> wrote:</p>
          <blockquote>
              <p>A) I’m not a 100% sure this works properly. Going to test on DQ tonightish, so I’ll get back to you on it, but as far as my testing went, it works.<br>
B) Big thanks goes to KO9 for help with the maths formula.</p>
<pre><code class="lang-auto">package org.darkquest.server.event;

import java.util.ArrayList;

import org.darkquest.server.model.InvItem;
import org.darkquest.server.model.Item;
import org.darkquest.server.model.Mob;
import org.darkquest.server.model.Npc;
import org.darkquest.server.model.Player;
import org.darkquest.server.model.Point;
import org.darkquest.server.model.Projectile;
import org.darkquest.server.model.TileValue;
import org.darkquest.server.states.Action;
import org.darkquest.server.util.DataConversions;
import org.darkquest.server.util.Formulae;

public class RangeEvent extends DelayedEvent {
	private Mob affectedMob;
	private boolean firstRun = true;

	public RangeEvent(Player owner, Mob affectedMob) {
		super(owner, 2000);
		this.affectedMob = affectedMob;
	}
	private Item getArrows(int id) {
		for(Item i : world.getTile(affectedMob.getLocation()).getItems()) {
			if(i.getID() == id &amp;&amp; i.visibleTo(owner) &amp;&amp; !i.isRemoved()) {
				return i;
			}
		}
		return null;
	}

	public void run() {
		int bowID = owner.getRangeEquip();
		if(!owner.loggedIn() || (affectedMob instanceof Player &amp;&amp; !((Player)affectedMob).loggedIn()) || affectedMob.getHits() &lt;= 0 || !owner.checkAttack(affectedMob, true) || bowID &lt; 0) {
			owner.resetRange();
			return;
		}
		if(owner.withinRange(affectedMob, 5)) {
			if(owner.isFollowing()) {
				owner.resetFollowing();
			}
			if(!owner.finishedPath()) {
				owner.resetPath();
			}
		}
		else {
			owner.setFollowing(affectedMob);
			return;
		}
		boolean xbow = DataConversions.inArray(Formulae.xbowIDs, bowID);
		int arrowID = -1;
		for(int aID : (xbow ? Formulae.boltIDs : Formulae.arrowIDs)) {
			int slot = owner.getInventory().getLastIndexById(aID);
			if(slot &lt; 0) {
				continue;
			}
			InvItem arrow = owner.getInventory().get(slot);
			if(arrow == null) { // This shouldn't happen
				continue;
			}
			arrowID = aID;
			int newAmount = arrow.getAmount() - 1;
			if(newAmount &lt;= 0) {
				owner.getInventory().remove(slot);
				owner.getActionSender().sendInventory();
			}
			else {
				arrow.setAmount(newAmount);
				owner.getActionSender().sendUpdateItem(slot);
			}
			break;
		}
		if(arrowID &lt; 0) {
			owner.getActionSender().sendMessage("You have run out of " + (xbow ? "bolts" : "arrows"));
			owner.resetRange();
			return;
		}
		int playerAx = owner.getX();
		int playerAy = owner.getY();
		int playerBx = affectedMob.getX();
		int playerBy = affectedMob.getY();
		int[] path = new int[2];
		path[0] = owner.getX();
		path[1] = owner.getY();
		for(int x=(playerAx+1); x &lt; (playerBx+1); x++)
			{
			int y = ((((playerBy - playerAy) * (x - playerAx)) / (playerBx - playerAx)) + playerAy);
			if (isBlocking(x, y, getDirection(new Point(path[0],path[1]),new Point(x,y)))) 
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}
		path[0] = affectedMob.getX();
		path[1] = affectedMob.getY();
		for(int x=(playerBx+1); x &lt; (playerAx+1); x++)
			{
			int y = ((((playerBy - playerAy) * (x - playerAx)) / (playerBx - playerAx)) + playerAy);
			if (isBlocking(x, y, getDirection(new Point(x,y),new Point(path[0],path[1])))) 
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}
		path[0] = owner.getX();
		path[1] = owner.getY();
		for(int y=playerAy+1; y &lt; playerBy+1; y++)
			{
			int x = (((y - playerAy) * (playerBx - playerAx)) / (playerBy - playerAy)) + playerAx;
			if (isBlocking(x, y, getDirection(new Point(path[0],path[1]),new Point(x,y))))
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}
		path[0] = owner.getX();
		path[1] = owner.getY();
		for(int y=playerAy-1; y &gt; playerBy-1; y--)
			{
			int x = (((y - playerAy) * (playerBx - playerAx)) / (playerBy - playerAy)) + playerAx;
			if (isBlocking(x, y, getDirection(new Point(x,y),new Point(path[0],path[1])))) 
				{
				owner.resetRange();
				return;
				}
			path[0] = x;
			path[1] = y;
			}		
		if(affectedMob.isPrayerActivated(13))
			{
			owner.getActionSender().sendMessage("Your missiles are blocked");
			owner.resetRange();
			return;
			}
		if(affectedMob instanceof Npc &amp;&amp; owner instanceof Player) // We're ranging an NPC, so make it chase the player.
			{
			final Npc npc = (Npc)affectedMob;

             //Radius is 0 to prevent wallhacking by NPCs. Easiest method I can come up with for now.

			if(!npc.getWalking() &amp;&amp; !npc.isBusy())
				{
				npc.setWalking(true);
				world.getDelayedEventHandler().add(new WalkMobToMobEvent(affectedMob, owner, 0)
					{
					public void arrived()
						{
						Player player = (Player)affectedMob;
						npc.resetPath();
						if(player.isBusy())
							return;

						player.resetPath();
						player.resetAll();
						player.setStatus(Action.FIGHTING_MOB);
						player.getActionSender().sendMessage("You are under attack!");

						npc.setLocation(player.getLocation(), true);
						for(Player p : npc.getViewArea().getPlayersInView())
							p.removeWatchedNpc(npc);

						player.setBusy(true);
						player.setSprite(9);
						player.setOpponent(npc);
						player.setCombatTimer();

						npc.setBusy(true);
						npc.setWalking(false);
						npc.setSprite(8);
						npc.setOpponent(player);
						npc.setCombatTimer();
						FightEvent fighting = new FightEvent(player, npc, true);
						fighting.setLastRun(0);
						world.getDelayedEventHandler().add(fighting);
						}
					});
				}
			}

		int damage = Formulae.calcRangeHit(owner.getCurStat(4), owner.getRangePoints(), affectedMob.getArmourPoints(), arrowID);
		if(!Formulae.looseArrow(damage)) {
			Item arrows = getArrows(arrowID);
			if(arrows == null) {
				world.registerItem(new Item(arrowID, affectedMob.getX(), affectedMob.getY(), 1, owner));
			}
			else {
				arrows.setAmount(arrows.getAmount() + 1);
			}
		}
		if(firstRun) {
			firstRun = false;
			if(affectedMob instanceof Player) {
				((Player)affectedMob).getActionSender().sendMessage(owner.getUsername() + " is shooting at you!");
			}
		}
		Projectile projectile = new Projectile(owner, affectedMob, 2);
  		affectedMob.setLastDamage(damage);
  		int newHp = affectedMob.getHits() - damage;
  		affectedMob.setHits(newHp);
  		ArrayList&lt;Player&gt; playersToInform = new ArrayList&lt;Player&gt;();
  		playersToInform.addAll(owner.getViewArea().getPlayersInView());
  		playersToInform.addAll(affectedMob.getViewArea().getPlayersInView());
  		for(Player p : playersToInform) {
  			p.informOfProjectile(projectile);
  			p.informOfModifiedHits(affectedMob);
  		}
  		if(affectedMob instanceof Player) {
  			Player affectedPlayer = (Player)affectedMob;
  			affectedPlayer.getActionSender().sendStat(3);
		}
		owner.getActionSender().sendSound("shoot");
		owner.setArrowFired();
  		if(newHp &lt;= 0) {
  			affectedMob.killedBy(owner, false);
  			int exp = Formulae.combatExperience(affectedMob);
  			owner.incExp(4, exp, true);
  			owner.getActionSender().sendStat(4);
  			owner.resetRange();
  		}
	}
	private boolean isBlocking(int x, int y, int bit) 
		{
		TileValue t = world.getTileValue(x, y);
		if(bit == SOUTHWEST) 
			{
			TileValue p1 = world.getTileValue(x-1, y-1);
			TileValue p2 = world.getTileValue(x, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)SOUTH)) { return true; }
			p1 = world.getTileValue(x, y-1);
			p2 = world.getTileValue(x-1, y);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p2.mapValue, (byte)WEST)) { return true; }
			p1 = world.getTileValue(x-1, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p1.mapValue, (byte)WEST)) { return true; }
			}
		else if(bit == SOUTHEAST) 
			{
			TileValue p1 = world.getTileValue(x+1, y-1);
			TileValue p2 = world.getTileValue(x, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)SOUTH)) { return true; }
			p1 = world.getTileValue(x, y-1);
			p2 = world.getTileValue(x+1, y);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)EAST)) { return true; }
			p1 = world.getTileValue(x+1, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p1.mapValue, (byte)EAST)) { return true; }
			
			}
		else if(bit == NORTHEAST) 
			{
			TileValue p1 = world.getTileValue(x+1, y-1);
			TileValue p2 = world.getTileValue(x, y-1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)NORTH)) { return true; }
			p1 = world.getTileValue(x, y-1);
			p2 = world.getTileValue(x-1, y);
			if(isBlocking(p1.mapValue, (byte)EAST) &amp;&amp; isBlocking(p2.mapValue, (byte)NORTH)) { return true; }
			p1 = world.getTileValue(x+1, y+1);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p1.mapValue, (byte)EAST)) { return true; }
			}
		else if(bit == NORTHWEST) 
			{
			TileValue p1 = world.getTileValue(x+1, y+1);
			TileValue p2 = world.getTileValue(x, y+1);
			if(isBlocking(p1.mapValue, (byte)SOUTH) &amp;&amp; isBlocking(p2.mapValue, (byte)NORTH)) { return true; }
			p1 = world.getTileValue(x, y+1);
			p2 = world.getTileValue(x-1, y);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p2.mapValue, (byte)WEST)) { return true; }
			p1 = world.getTileValue(x-1, y+1);
			if(isBlocking(p1.mapValue, (byte)NORTH) &amp;&amp; isBlocking(p1.mapValue, (byte)WEST)) { return true; }
			}
		return isBlocking(t.mapValue, (byte)bit);
		}
	public static final int NONE=0, NORTH=1, NORTHEAST=2, EAST=3, 
	SOUTHEAST=4, SOUTH=5, SOUTHWEST=6, WEST=7, NORTHWEST=8;
	private boolean isBlocking(byte val, byte bit) {
		if((val &amp; bit) != 0) { // There is a wall in the way
			return true;
		}
		if((val &amp; 16) != 0) { // There is a diagonal wall here: \
			return true;
		}
		if((val &amp; 32) != 0) { // There is a diagonal wall here: /
			return true;
		}
		if((val &amp; 64) != 0) { // This tile is unwalkable
			return true;
		}
		return false;
	}
	public int getDirection(Point p1, Point p2) 
		{
		//System.out.print(p1.getX() + " - " + p2.getX()  + " | " + p1.getY() + " - " + p2.getY());
		if(p1 == null) { return NONE; }
		int direction = NONE;
		int x1 = p1.getX(), y1 = p1.getY(),
			x2 = p2.getX(), y2 = p2.getY();
		int dX = x2 - x1,
			dY = y2 - y1;
		if(dX == 0 &amp;&amp; dY == -1)
			direction = NORTH;
		else if(dX == -1 &amp;&amp; dY == -1)
			direction = NORTHEAST;
		else if(dX == -1 &amp;&amp; dY == 0)
			direction = EAST;
		else if(dX == -1 &amp;&amp; dY == 1)
			direction = SOUTHEAST;
		else if(dX == 0 &amp;&amp; dY == 1)
			direction = SOUTH;
		else if(dX == 1 &amp;&amp; dY == 1)
			direction = SOUTHWEST;
		else if(dX == 1 &amp;&amp; dY == 0)
			direction = WEST;
		else if(dX == 1 &amp;&amp; dY == -1)
			direction = NORTHWEST;
		//System.out.print(" | " + printDir(direction) + "(" + direction + ")");
		//System.out.println();
		return direction;
	}

	public static String printDir(int dir) 
		{
		if(dir == 0) { return "NONE"; }
		if(dir == 1) { return "NORTH"; }
		if(dir == 2) { return "NORTHEAST"; }
		if(dir == 3) { return "EAST"; }
		if(dir == 4) { return "SOUTHEAST"; }
		if(dir == 5) { return "SOUTH"; }
		if(dir == 6) { return "SOUTHWEST"; }
		if(dir == 7) { return "WEST"; }
		if(dir == 8) { return "NORTHWEST"; }
		return "NONE";
		}
	public Mob getAffectedMob() {
		return affectedMob;
	}

	public boolean equals(Object o) {
		if(o instanceof RangeEvent) {
			RangeEvent e = (RangeEvent)o;
			return e.belongsTo(owner);
		}
		return false;
	}
}</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/ranging-through-walls/258631/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/ranging-through-walls/258631/1</link>
        <pubDate>Mon, 26 Jan 2009 18:15:16 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-258631-1</guid>
        <source url="https://forum.moparisthebest.com/t/ranging-through-walls/258631.rss">Ranging through walls</source>
      </item>
  </channel>
</rss>
