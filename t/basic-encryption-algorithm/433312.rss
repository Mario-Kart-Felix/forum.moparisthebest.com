<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Basic Encryption Algorithm</title>
    <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312</link>
    <description>I tried making an encryption algorithm for science fair at my school. I just passed it in like a week ago so I don&#39;t know the grade yet but I figured I&#39;d release it here to see what you guys think. It was my first attempt at anything like this from scratch. It randomizes the bytes of the password and then raises those to the number that was used for the index change divided by 2. The decryption method is in there as well. It&#39;s not anything special, I just figured I&#39;d try it.

EDIT: Ooops sorry I posted the original code. I fixed it.

[code=java5]import java.util.ArrayList;
import java.util.Scanner;

public class Encryption {

	//Declare and initailize a scanner for user input
	static Scanner scan = new Scanner(System.in);

	//Declare and initialize array lists for the key and the possible indexes for an index change
	static ArrayList&lt;Double&gt; key = new ArrayList&lt;Double&gt;();
	ArrayList&lt;Integer&gt; possibleIndexes = new ArrayList&lt;Integer&gt;();

	//Declare byte arrays for storing the password in bytes
	byte[] unObPass;
	byte[] obPass;
	byte[] test;
	int[] obPassInts;
	double[] obPassDoubles;

	//Declare the string for holding the password in clear text
	static String pass;

	//Variables for the number of characters in certain cases
	int numberOfUpper = 0;
	int numberOfLower = 0;
	int numberOfSymbols = 0;
	int numberOfNumbers = 0;

	//char[]&#39;s for the specific characters
	char[] upper = new char[200];
	char[] lower = new char[200];
	char[] sym = new char[200];
	char[] num = new char[200];

	//ArrayLists for the end result of the algorithm and the order of the cases
	static ArrayList&lt;String&gt; testing = new ArrayList&lt;String&gt;();
	ArrayList&lt;String&gt; caseOrder = new ArrayList&lt;String&gt;();

	//main method
	public static void main(String[] args) {

		//Make and Encryption object and call the start method
		Encryption t = new Encryption();

		//Get the password from user input
		System.out.print(&quot;Enter the password: &quot;);
		pass = scan.nextLine();

		//encrypt the password
		t.encrypt(pass);

		//decrypt the password
		t.decrypt(testing, key);

	}

	//encrypt method
	public void encrypt(String password) {

		System.out.println(&quot;---START ENCRYPT---&quot;);

		//Populate the unobfuscated array with the bytes of the clear text password
		unObPass = password.getBytes();

		//Set the size of the obfuscated array
		obPass = new byte[unObPass.length];
		obPassInts = new int[obPass.length];
		obPassDoubles = new double[obPass.length];
		test = new byte[obPassInts.length];

		//Copy the contents of the unobfuscated array to the obfuscated array
		System.arraycopy(unObPass, 0, obPass, 0, unObPass.length);

		//Populate the possible index array list
		for(int i = 0; i &lt; unObPass.length; i++) {

			possibleIndexes.add(i);

		}

		//Set the elements of the obfuscated array to random elements from the unobfuscated array
		for(int k = 0; k &lt; unObPass.length; k++) {

			obPass[k] = unObPass[newIndex()];

		}

		//make a dumby int array with the same contents of the byte array
		for(int g = 0; g &lt; obPassInts.length; g++) {

			String temp = Byte.toString(obPass[g]);
			obPassInts[g] = Integer.parseInt(temp);

		}

		String obPassStr = new String(obPass);
		checkCase(obPassStr);

		//Raise the element in of the obfuscated byte array to the value of the key
		for(int j = 0; j &lt; obPassInts.length; j++) {

			obPassDoubles[j] = Math.pow(obPassInts[j], (key.get(j)/2));

		}

		for(int d = 0; d &lt; obPass.length; d++) {

			Double b = new Double(obPassDoubles[d]);
			testing.add(b.toString());
			testing.add(caseOrder.get(d));

		}

		//Print out the encrypted password
		System.out.println(&quot;\nObfuscated Encrypted Password Data:&quot;);

		System.out.println(testing);


		//Print out the key as it would be stored
		System.out.println(&quot;\nKey: &quot;);

		for(int l = 0; l &lt; key.size(); l++) {

			System.out.print(key.get(l) +&quot;, &quot;);

		}

		//For cleanliness
		System.out.println();

		System.out.println(&quot;---END ENCRYPT---&quot;);

	}

	//newIndex method: parameter int
	public int newIndex() {

		//Declare and initialize an int that is a random value between 0 and the length of the unobfuscated array
		double rand = (Math.random() * unObPass.length);
		int index;

		//Infinite loop
		while(true) {

			//If possible index contains the random int generated
			if(possibleIndexes.contains((int)rand)) {

				//Remove that from the possible indexes and add that random int to the key
				Integer t = new Integer((int)rand);
				possibleIndexes.remove(t);
				key.add(rand);

				index = (int) rand;

				//Break from the loop
				break;

			//Otherwise
			} else {

				//Get a new random value for an index
				rand = (Math.random() * unObPass.length);

			}

		}

		//return the index
		return index;

	}

	//checkCase method
	public void checkCase(String str) {

		//make a byte[] of the supplied string
		byte[] temp = str.getBytes();

		//Loop through the array
		for(int i = 0; i &lt; temp.length; i++) {

			//Make a single byte from the current index of the array
			Byte p = new Byte(temp[i]);

			//Test if the value if within the lowercase alphabet
			if(p.intValue() &gt;= 97 &amp;&amp; p.intValue() &lt;= 122) {

				//Increment the number of lower case characters
				//Add the character to an array
				//Add an l to the case order signifying a lowercase character
				numberOfLower++;
				lower[i] = str.charAt(i);
				caseOrder.add(&quot;l&quot;);

			//Test is the value is within the uppercase alphabet
			} else if(p.intValue() &gt;= 65 &amp;&amp; p.intValue() &lt;=90) {

				//Increment the number of upper case characters
				//Add the character to an array
				//Add an U to the case order signifying a uppercase character
				numberOfUpper++;
				upper[i] = str.charAt(i);
				caseOrder.add(&quot;U&quot;);

			//Test if the value is a symbol
			} else if(p.intValue() &gt;= 32 &amp;&amp; p.intValue() != 48 &amp;&amp; p.intValue() != 49 &amp;&amp; p.intValue() != 50 &amp;&amp; p.intValue() != 51 &amp;&amp; p.intValue() != 52 &amp;&amp; p.intValue() != 53 &amp;&amp; p.intValue() != 54 &amp;&amp; p.intValue() != 55 &amp;&amp; p.intValue() != 56 &amp;&amp; p.intValue() != 57 &amp;&amp; p.intValue() &lt;= 126) {

				//Increment the number of symbol characters
				//Add the character to an array
				//Add an s to the case order signifying a symbol character
				numberOfSymbols++;
				sym[i] = str.charAt(i);
				caseOrder.add(&quot;s&quot;);

			//Test is the value is within the numbers
			} else if(p.intValue() &gt;= 48 &amp;&amp; p.intValue() &lt;= 57) {


				//Increment the number of number characters
				//Add the character to an array
				//Add an n to the case order signifying a number character
				numberOfNumbers++;
				num[i] = str.charAt(i);
				caseOrder.add(&quot;n&quot;);

			}

		}
	}

	//Decrypt method
	public void decrypt(ArrayList&lt;String&gt; encryptedPass, ArrayList&lt;Double&gt; key) {

		System.out.println(&quot;\n---START DECRYPT---&quot;);

		//Create two arrays to hold the cases and the bytes
		String[] cases = new String[encryptedPass.size()];
		String[] bytes = new String[encryptedPass.size()];

		//Declare and initialize arrays for holding the decrypted bytes
		byte[] decryptedBytes = new byte[bytes.length/2];
		int[] decryptedBytesInt = new int[bytes.length/2];
		String[] decryptedBytesStr = new String[bytes.length/2];
		byte[] unObBytes = new byte[decryptedBytes.length];

		//Indexing value
		int k = 0;

		//Loop through the password supplied
		for(int i = 0; i &lt; encryptedPass.size(); i+=2) {

			//Set the bytes equal to the value from the array at i
			bytes[k] = encryptedPass.get(i);

			//If the increment + 1 is equal to the size break from the loop
			if(i+1 == encryptedPass.size()) {

				break;

			//Otherwise set the case equal to the vlue from the array at i+1
			} else {

				cases[k] = encryptedPass.get(i+1);

			}

			//Increment k
			k++;

		}

		//Loop through the cases to test what the original byte could be
		for(int j = 0; j &lt; cases.length; j++) {

			//Check to see if the case is null
			if(cases[j] != null) {

				//If the case is lower
				if(cases[j].equals(&quot;l&quot;)) {

					//Make a temporary double value from the bytes array
					Double temp = new Double(bytes[j]);
					double temp2 = temp;

					//Loop through the lower case byte values
					for(int i = 97; i &lt; 122; i++) {

						//Check if the key is 0
						if(key.get(j) != 0) {

							//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
							if(Math.pow((double)i, (double)(key.get(j)/2)) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;lowercase match for byte: &quot; + i + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = i;

							}

						//Otherwise
						} else {

							//Raise the byte to the 0 and check if it equals the byte value from the array
							if(Math.pow(i, 0) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;lowercase match for byte: &quot; + i + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = i;

							}

						}

					}

				}

				//If the case is upper
				if(cases[j].equals(&quot;U&quot;)) {

					//Make a temporary double value from the bytes array
					Double temp = new Double(bytes[j]);
					double temp2 = temp;

					//Loop through the uppercase byte values
					for(int i = 65; i &lt; 90; i++) {

						//Check if the key is 0
						if(key.get(j) != 0) {

							//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
							if(Math.pow((double)i, (double)(key.get(j)/2)) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;uppercase match for byte: &quot; + i + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = i;

							}

						//Otherwise
						} else {

							//Raise the byte to the 0 and check if it equals the byte value from the array
							if(Math.pow(i, 0) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;uppercase match for byte: &quot; + i + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = i;

							}

						}

					}

				}

				//If the case is a symbol
				if(cases[j].equals(&quot;s&quot;)) {

					//Make a temporary double value from the bytes array
					Double temp = new Double(bytes[j]);
					double temp2 = temp;

					//Make an array of the symbol bytes
					int[] symBytes = {96,126,32,33,64,35,36,37,94,38,42,40,41,45,95,61,43,93,91,123,93,125,92,124,59,58,39,34,44,60,46,62,47,63};

					//Loop through the array of bytes
					for(int i = 0; i &lt; symBytes.length; i++) {

						//Check if the key is 0
						if(key.get(j) != 0) {

							//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
							if(Math.pow((double)symBytes[i], (double)(key.get(j)/2)) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;symbol match for byte: &quot; + symBytes[i] + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = symBytes[i];

							}

						//Otherwise
						} else {

							//Raise the byte to the 0 and check if it equals the byte value from the array
							if(Math.pow(symBytes[i], 0) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;symbol match for byte: &quot; + symBytes[i] + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = symBytes[i];

							}

						}

					}

				}

				//If the case is a number
				if(cases[j].equals(&quot;n&quot;)) {

					//Make a temp double of the byte in the array at the index j
					Double temp = new Double(bytes[j]);
					double temp2 = temp;

					//Loop through the number bytes
					for(int i = 48; i &lt; 57; i++) {

						//Check if the key is 0
						if(key.get(j) != 0) {

							//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
							if(Math.pow((double)i, (double)(key.get(j)/2)) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;number match for byte: &quot; + i + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = i;

							}

						//Otherwise
						} else {

							//Raise the byte to the 0 and check if it equals the byte value from the array
							if(Math.pow(i, 0) == temp2) {

								//That byte is a match and is added to the array of decrypted bytes
								System.out.println(&quot;number match for byte: &quot; + i + &quot; and key: &quot; + key.get(j));
								decryptedBytesInt[j] = i;

							}

						}

					}

				}

			}

		}

		System.out.println(&quot;\nDecrypted Bytes: &quot;);

		//Lopp through the arrays and populate the byte array with the bytes from decryption
		for(int x = 0; x &lt; decryptedBytes.length; x++) {

			System.out.print(decryptedBytesInt[x] + &quot;,&quot;);
			decryptedBytesStr[x] = Integer.toString(decryptedBytesInt[x]);
			Byte b = new Byte(decryptedBytesStr[x]);
			decryptedBytes[x] = b;
		}

		System.out.println(&quot;\n&quot;);

		//Make a string of the decrypted bytes and print it out
		String temp = new String (decryptedBytes);
		System.out.println(temp);

		//Loop through the decrypted bytes and reset it back to unobfuscated
		for(int a = 0; a &lt; decryptedBytes.length; a++) {

			Double t = new Double(key.get(a));
			double b = t;

			int q = (int) b;

			unObBytes[q] = decryptedBytes[a];

		}

		//Make another String from the byte array and print it out
		String temp2 = new String (unObBytes);
		System.out.println(temp2);

		System.out.println(&quot;---END DECRYPT---&quot;);

	}

}[/code]

[b]Example Output:[/b]

[code]C:\Users\Mike.Mike-PC\Desktop&gt;java Encryption
Enter the password: teST;&#39;12
---START ENCRYPT---

Obfuscated Encrypted Password Data:
[1.5777821073765885, l, 331.65592682128687, U, 2460819.706237187, n, 2780.380834
707562, U, 378553.17451216606, n, 26.468137053885812, l, 10705.128435969074, s,
16496.70602219724, s]

Key:
0.19186346026728796, 2.6269777897315834, 7.5234757290043595, 3.579630369856204,
6.6005677783788075, 1.4196559427991335, 4.551020475642511, 5.301352586873844,
---END ENCRYPT---

---START DECRYPT---
lowercase match for byte: 116 and key: 0.19186346026728796
uppercase match for byte: 83 and key: 2.6269777897315834
number match for byte: 50 and key: 7.5234757290043595
uppercase match for byte: 84 and key: 3.579630369856204
number match for byte: 49 and key: 6.6005677783788075
lowercase match for byte: 101 and key: 1.4196559427991335
symbol match for byte: 59 and key: 4.551020475642511
symbol match for byte: 39 and key: 5.301352586873844

Decrypted Bytes:
116,83,50,84,49,101,59,39,

tS2T1e;&#39;
teST;&#39;12
---END DECRYPT---
[/code]

[code]C:\Users\Mike.Mike-PC\Desktop&gt;java Encryption
Enter the password: teST;&#39;12
---START ENCRYPT---

Obfuscated Encrypted Password Data:
[6223.0287627417465, U, 700719.0741792471, n, 8.082372667804732, l, 9171.6366747
56111, s, 235.62527389056345, U, 41969.19400264292, s, 22.440525353557845, l, 21
69629.673023986, n]

Key:
3.94329641832398, 6.917000942786805, 0.8792030412475826, 4.475186877509025, 2.47
22515272283383, 5.81111616519857, 1.348120154395125, 7.459090620436449,
---END ENCRYPT---

---START DECRYPT---
uppercase match for byte: 84 and key: 3.94329641832398
number match for byte: 49 and key: 6.917000942786805
lowercase match for byte: 116 and key: 0.8792030412475826
symbol match for byte: 59 and key: 4.475186877509025
uppercase match for byte: 83 and key: 2.4722515272283383
symbol match for byte: 39 and key: 5.81111616519857
lowercase match for byte: 101 and key: 1.348120154395125
number match for byte: 50 and key: 7.459090620436449

Decrypted Bytes:
84,49,116,59,83,39,101,50,

T1t;S&#39;e2
teST;&#39;12
---END DECRYPT---

C:\Users\Mike.Mike-PC\Desktop&gt;[/code]</description>
    
    <lastBuildDate>Sat, 18 Feb 2012 18:45:14 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Basic Encryption Algorithm</title>
        <dc:creator><![CDATA[@sp11k3t3ht3rd sp11k3t3ht3rd]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sp11k3t3ht3rd">@sp11k3t3ht3rd</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="6" data-topic="433312">
<div class="title">
<div class="quote-controls"></div>
 IDONTWANTAFUCKINGACCOUNT:</div>
<blockquote>
<p>You could have used RC4, as it’s incredibly simple, and provides pretty good security (especially when matched with RSA, to protect the key, if you’re doing it in a game, for example).</p>
</blockquote>
</aside>
<p>I wanted to try making my own for a project. Not just use existing standards.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/7</link>
        <pubDate>Sat, 18 Feb 2012 18:45:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-433312-7</guid>
        <source url="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss">Basic Encryption Algorithm</source>
      </item>
      <item>
        <title>Basic Encryption Algorithm</title>
        <dc:creator><![CDATA[@IDONTWANTAFUCKINGACC IDONTWANTAFUCKINGACCOUNT]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/idontwantafuckingacc">@IDONTWANTAFUCKINGACC</a> wrote:</p>
          <blockquote>
              <p>You could have used RC4, as it’s incredibly simple, and provides pretty good security (especially when matched with RSA, to protect the key, if you’re doing it in a game, for example).</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/6</link>
        <pubDate>Sat, 18 Feb 2012 16:52:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-433312-6</guid>
        <source url="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss">Basic Encryption Algorithm</source>
      </item>
      <item>
        <title>Basic Encryption Algorithm</title>
        <dc:creator><![CDATA[@sp11k3t3ht3rd sp11k3t3ht3rd]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sp11k3t3ht3rd">@sp11k3t3ht3rd</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:4, topic:433312”][quote author=zyle1992 link=topic=536031.msg3919272#msg3919272 date=1329535457]<br>
Didn’t you post this like 3 weeks ago?<br>
[/quote]<br>
i think it’s different[/quote]</p>
<p>Yeah sorry, I posted the wrong code. This version changed a little. Also I added example output.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/5</link>
        <pubDate>Sat, 18 Feb 2012 05:19:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-433312-5</guid>
        <source url="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss">Basic Encryption Algorithm</source>
      </item>
      <item>
        <title>Basic Encryption Algorithm</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="3" data-topic="433312">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="https://forum.moparisthebest.com/letter_avatar/zyle1992/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> zyle1992:</div>
<blockquote>
<p>Didn’t you post this like 3 weeks ago?</p>
</blockquote>
</aside>
<p>i think it’s different</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/4</link>
        <pubDate>Sat, 18 Feb 2012 03:24:41 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-433312-4</guid>
        <source url="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss">Basic Encryption Algorithm</source>
      </item>
      <item>
        <title>Basic Encryption Algorithm</title>
        <dc:creator><![CDATA[@zyle1992 Zymus]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/zyle1992">@zyle1992</a> wrote:</p>
          <blockquote>
              <p>Didn’t you post this like 3 weeks ago?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/3</link>
        <pubDate>Sat, 18 Feb 2012 03:24:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-433312-3</guid>
        <source url="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss">Basic Encryption Algorithm</source>
      </item>
      <item>
        <title>Basic Encryption Algorithm</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>could i see some example runs?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/2</link>
        <pubDate>Sat, 18 Feb 2012 01:36:30 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-433312-2</guid>
        <source url="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss">Basic Encryption Algorithm</source>
      </item>
      <item>
        <title>Basic Encryption Algorithm</title>
        <dc:creator><![CDATA[@sp11k3t3ht3rd sp11k3t3ht3rd]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sp11k3t3ht3rd">@sp11k3t3ht3rd</a> wrote:</p>
          <blockquote>
              <p>I tried making an encryption algorithm for science fair at my school. I just passed it in like a week ago so I don’t know the grade yet but I figured I’d release it here to see what you guys think. It was my first attempt at anything like this from scratch. It randomizes the bytes of the password and then raises those to the number that was used for the index change divided by 2. The decryption method is in there as well. It’s not anything special, I just figured I’d try it.</p>
<p>EDIT: Ooops sorry I posted the original code. I fixed it.</p>
<p>[code=java5]import java.util.ArrayList;<br>
import java.util.Scanner;</p>
<p>public class Encryption {</p>
<pre><code>//Declare and initailize a scanner for user input
static Scanner scan = new Scanner(System.in);

//Declare and initialize array lists for the key and the possible indexes for an index change
static ArrayList&lt;Double&gt; key = new ArrayList&lt;Double&gt;();
ArrayList&lt;Integer&gt; possibleIndexes = new ArrayList&lt;Integer&gt;();

//Declare byte arrays for storing the password in bytes
byte[] unObPass;
byte[] obPass;
byte[] test;
int[] obPassInts;
double[] obPassDoubles;

//Declare the string for holding the password in clear text
static String pass;

//Variables for the number of characters in certain cases
int numberOfUpper = 0;
int numberOfLower = 0;
int numberOfSymbols = 0;
int numberOfNumbers = 0;

//char[]'s for the specific characters
char[] upper = new char[200];
char[] lower = new char[200];
char[] sym = new char[200];
char[] num = new char[200];

//ArrayLists for the end result of the algorithm and the order of the cases
static ArrayList&lt;String&gt; testing = new ArrayList&lt;String&gt;();
ArrayList&lt;String&gt; caseOrder = new ArrayList&lt;String&gt;();

//main method
public static void main(String[] args) {

	//Make and Encryption object and call the start method
	Encryption t = new Encryption();

	//Get the password from user input
	System.out.print("Enter the password: ");
	pass = scan.nextLine();

	//encrypt the password
	t.encrypt(pass);

	//decrypt the password
	t.decrypt(testing, key);

}

//encrypt method
public void encrypt(String password) {

	System.out.println("---START ENCRYPT---");

	//Populate the unobfuscated array with the bytes of the clear text password
	unObPass = password.getBytes();

	//Set the size of the obfuscated array
	obPass = new byte[unObPass.length];
	obPassInts = new int[obPass.length];
	obPassDoubles = new double[obPass.length];
	test = new byte[obPassInts.length];

	//Copy the contents of the unobfuscated array to the obfuscated array
	System.arraycopy(unObPass, 0, obPass, 0, unObPass.length);

	//Populate the possible index array list
	for(int i = 0; i &lt; unObPass.length; i++) {

		possibleIndexes.add(i);

	}

	//Set the elements of the obfuscated array to random elements from the unobfuscated array
	for(int k = 0; k &lt; unObPass.length; k++) {

		obPass[k] = unObPass[newIndex()];

	}

	//make a dumby int array with the same contents of the byte array
	for(int g = 0; g &lt; obPassInts.length; g++) {

		String temp = Byte.toString(obPass[g]);
		obPassInts[g] = Integer.parseInt(temp);

	}

	String obPassStr = new String(obPass);
	checkCase(obPassStr);

	//Raise the element in of the obfuscated byte array to the value of the key
	for(int j = 0; j &lt; obPassInts.length; j++) {

		obPassDoubles[j] = Math.pow(obPassInts[j], (key.get(j)/2));

	}

	for(int d = 0; d &lt; obPass.length; d++) {

		Double b = new Double(obPassDoubles[d]);
		testing.add(b.toString());
		testing.add(caseOrder.get(d));

	}

	//Print out the encrypted password
	System.out.println("\nObfuscated Encrypted Password Data:");

	System.out.println(testing);


	//Print out the key as it would be stored
	System.out.println("\nKey: ");

	for(int l = 0; l &lt; key.size(); l++) {

		System.out.print(key.get(l) +", ");

	}

	//For cleanliness
	System.out.println();

	System.out.println("---END ENCRYPT---");

}

//newIndex method: parameter int
public int newIndex() {

	//Declare and initialize an int that is a random value between 0 and the length of the unobfuscated array
	double rand = (Math.random() * unObPass.length);
	int index;

	//Infinite loop
	while(true) {

		//If possible index contains the random int generated
		if(possibleIndexes.contains((int)rand)) {

			//Remove that from the possible indexes and add that random int to the key
			Integer t = new Integer((int)rand);
			possibleIndexes.remove(t);
			key.add(rand);

			index = (int) rand;

			//Break from the loop
			break;

		//Otherwise
		} else {

			//Get a new random value for an index
			rand = (Math.random() * unObPass.length);

		}

	}

	//return the index
	return index;

}

//checkCase method
public void checkCase(String str) {

	//make a byte[] of the supplied string
	byte[] temp = str.getBytes();

	//Loop through the array
	for(int i = 0; i &lt; temp.length; i++) {

		//Make a single byte from the current index of the array
		Byte p = new Byte(temp[i]);

		//Test if the value if within the lowercase alphabet
		if(p.intValue() &gt;= 97 &amp;&amp; p.intValue() &lt;= 122) {

			//Increment the number of lower case characters
			//Add the character to an array
			//Add an l to the case order signifying a lowercase character
			numberOfLower++;
			lower[i] = str.charAt(i);
			caseOrder.add("l");

		//Test is the value is within the uppercase alphabet
		} else if(p.intValue() &gt;= 65 &amp;&amp; p.intValue() &lt;=90) {

			//Increment the number of upper case characters
			//Add the character to an array
			//Add an U to the case order signifying a uppercase character
			numberOfUpper++;
			upper[i] = str.charAt(i);
			caseOrder.add("U");

		//Test if the value is a symbol
		} else if(p.intValue() &gt;= 32 &amp;&amp; p.intValue() != 48 &amp;&amp; p.intValue() != 49 &amp;&amp; p.intValue() != 50 &amp;&amp; p.intValue() != 51 &amp;&amp; p.intValue() != 52 &amp;&amp; p.intValue() != 53 &amp;&amp; p.intValue() != 54 &amp;&amp; p.intValue() != 55 &amp;&amp; p.intValue() != 56 &amp;&amp; p.intValue() != 57 &amp;&amp; p.intValue() &lt;= 126) {

			//Increment the number of symbol characters
			//Add the character to an array
			//Add an s to the case order signifying a symbol character
			numberOfSymbols++;
			sym[i] = str.charAt(i);
			caseOrder.add("s");

		//Test is the value is within the numbers
		} else if(p.intValue() &gt;= 48 &amp;&amp; p.intValue() &lt;= 57) {


			//Increment the number of number characters
			//Add the character to an array
			//Add an n to the case order signifying a number character
			numberOfNumbers++;
			num[i] = str.charAt(i);
			caseOrder.add("n");

		}

	}
}

//Decrypt method
public void decrypt(ArrayList&lt;String&gt; encryptedPass, ArrayList&lt;Double&gt; key) {

	System.out.println("\n---START DECRYPT---");

	//Create two arrays to hold the cases and the bytes
	String[] cases = new String[encryptedPass.size()];
	String[] bytes = new String[encryptedPass.size()];

	//Declare and initialize arrays for holding the decrypted bytes
	byte[] decryptedBytes = new byte[bytes.length/2];
	int[] decryptedBytesInt = new int[bytes.length/2];
	String[] decryptedBytesStr = new String[bytes.length/2];
	byte[] unObBytes = new byte[decryptedBytes.length];

	//Indexing value
	int k = 0;

	//Loop through the password supplied
	for(int i = 0; i &lt; encryptedPass.size(); i+=2) {

		//Set the bytes equal to the value from the array at i
		bytes[k] = encryptedPass.get(i);

		//If the increment + 1 is equal to the size break from the loop
		if(i+1 == encryptedPass.size()) {

			break;

		//Otherwise set the case equal to the vlue from the array at i+1
		} else {

			cases[k] = encryptedPass.get(i+1);

		}

		//Increment k
		k++;

	}

	//Loop through the cases to test what the original byte could be
	for(int j = 0; j &lt; cases.length; j++) {

		//Check to see if the case is null
		if(cases[j] != null) {

			//If the case is lower
			if(cases[j].equals("l")) {

				//Make a temporary double value from the bytes array
				Double temp = new Double(bytes[j]);
				double temp2 = temp;

				//Loop through the lower case byte values
				for(int i = 97; i &lt; 122; i++) {

					//Check if the key is 0
					if(key.get(j) != 0) {

						//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
						if(Math.pow((double)i, (double)(key.get(j)/2)) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("lowercase match for byte: " + i + " and key: " + key.get(j));
							decryptedBytesInt[j] = i;

						}

					//Otherwise
					} else {

						//Raise the byte to the 0 and check if it equals the byte value from the array
						if(Math.pow(i, 0) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("lowercase match for byte: " + i + " and key: " + key.get(j));
							decryptedBytesInt[j] = i;

						}

					}

				}

			}

			//If the case is upper
			if(cases[j].equals("U")) {

				//Make a temporary double value from the bytes array
				Double temp = new Double(bytes[j]);
				double temp2 = temp;

				//Loop through the uppercase byte values
				for(int i = 65; i &lt; 90; i++) {

					//Check if the key is 0
					if(key.get(j) != 0) {

						//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
						if(Math.pow((double)i, (double)(key.get(j)/2)) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("uppercase match for byte: " + i + " and key: " + key.get(j));
							decryptedBytesInt[j] = i;

						}

					//Otherwise
					} else {

						//Raise the byte to the 0 and check if it equals the byte value from the array
						if(Math.pow(i, 0) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("uppercase match for byte: " + i + " and key: " + key.get(j));
							decryptedBytesInt[j] = i;

						}

					}

				}

			}

			//If the case is a symbol
			if(cases[j].equals("s")) {

				//Make a temporary double value from the bytes array
				Double temp = new Double(bytes[j]);
				double temp2 = temp;

				//Make an array of the symbol bytes
				int[] symBytes = {96,126,32,33,64,35,36,37,94,38,42,40,41,45,95,61,43,93,91,123,93,125,92,124,59,58,39,34,44,60,46,62,47,63};

				//Loop through the array of bytes
				for(int i = 0; i &lt; symBytes.length; i++) {

					//Check if the key is 0
					if(key.get(j) != 0) {

						//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
						if(Math.pow((double)symBytes[i], (double)(key.get(j)/2)) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("symbol match for byte: " + symBytes[i] + " and key: " + key.get(j));
							decryptedBytesInt[j] = symBytes[i];

						}

					//Otherwise
					} else {

						//Raise the byte to the 0 and check if it equals the byte value from the array
						if(Math.pow(symBytes[i], 0) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("symbol match for byte: " + symBytes[i] + " and key: " + key.get(j));
							decryptedBytesInt[j] = symBytes[i];

						}

					}

				}

			}

			//If the case is a number
			if(cases[j].equals("n")) {

				//Make a temp double of the byte in the array at the index j
				Double temp = new Double(bytes[j]);
				double temp2 = temp;

				//Loop through the number bytes
				for(int i = 48; i &lt; 57; i++) {

					//Check if the key is 0
					if(key.get(j) != 0) {

						//Raise the increment byte to the key divided by two and check to see if it equals the byte value from the array
						if(Math.pow((double)i, (double)(key.get(j)/2)) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("number match for byte: " + i + " and key: " + key.get(j));
							decryptedBytesInt[j] = i;

						}

					//Otherwise
					} else {

						//Raise the byte to the 0 and check if it equals the byte value from the array
						if(Math.pow(i, 0) == temp2) {

							//That byte is a match and is added to the array of decrypted bytes
							System.out.println("number match for byte: " + i + " and key: " + key.get(j));
							decryptedBytesInt[j] = i;

						}

					}

				}

			}

		}

	}

	System.out.println("\nDecrypted Bytes: ");

	//Lopp through the arrays and populate the byte array with the bytes from decryption
	for(int x = 0; x &lt; decryptedBytes.length; x++) {

		System.out.print(decryptedBytesInt[x] + ",");
		decryptedBytesStr[x] = Integer.toString(decryptedBytesInt[x]);
		Byte b = new Byte(decryptedBytesStr[x]);
		decryptedBytes[x] = b;
	}

	System.out.println("\n");

	//Make a string of the decrypted bytes and print it out
	String temp = new String (decryptedBytes);
	System.out.println(temp);

	//Loop through the decrypted bytes and reset it back to unobfuscated
	for(int a = 0; a &lt; decryptedBytes.length; a++) {

		Double t = new Double(key.get(a));
		double b = t;

		int q = (int) b;

		unObBytes[q] = decryptedBytes[a];

	}

	//Make another String from the byte array and print it out
	String temp2 = new String (unObBytes);
	System.out.println(temp2);

	System.out.println("---END DECRYPT---");

}
</code></pre>
<p>}[/code]</p>
<p><span class="bbcode-b">Example Output:</span></p>
<p>[code]C:\Users\Mike.Mike-PC\Desktop&gt;java Encryption<br>
Enter the password: teST;'12<br>
—START ENCRYPT—</p>
<p>Obfuscated Encrypted Password Data:<br>
[1.5777821073765885, l, 331.65592682128687, U, 2460819.706237187, n, 2780.380834<br>
707562, U, 378553.17451216606, n, 26.468137053885812, l, 10705.128435969074, s,<br>
16496.70602219724, s]</p>
<p>Key:<br>
0.19186346026728796, 2.6269777897315834, 7.5234757290043595, 3.579630369856204,<br>
6.6005677783788075, 1.4196559427991335, 4.551020475642511, 5.301352586873844,<br>
—END ENCRYPT—</p>
<p>—START DECRYPT—<br>
lowercase match for byte: 116 and key: 0.19186346026728796<br>
uppercase match for byte: 83 and key: 2.6269777897315834<br>
number match for byte: 50 and key: 7.5234757290043595<br>
uppercase match for byte: 84 and key: 3.579630369856204<br>
number match for byte: 49 and key: 6.6005677783788075<br>
lowercase match for byte: 101 and key: 1.4196559427991335<br>
symbol match for byte: 59 and key: 4.551020475642511<br>
symbol match for byte: 39 and key: 5.301352586873844</p>
<p>Decrypted Bytes:<br>
116,83,50,84,49,101,59,39,</p>
<p>tS2T1e;’<br>
teST;'12<br>
—END DECRYPT—<br>
[/code]</p>
<p>[code]C:\Users\Mike.Mike-PC\Desktop&gt;java Encryption<br>
Enter the password: teST;'12<br>
—START ENCRYPT—</p>
<p>Obfuscated Encrypted Password Data:<br>
[6223.0287627417465, U, 700719.0741792471, n, 8.082372667804732, l, 9171.6366747<br>
56111, s, 235.62527389056345, U, 41969.19400264292, s, 22.440525353557845, l, 21<br>
69629.673023986, n]</p>
<p>Key:<br>
3.94329641832398, 6.917000942786805, 0.8792030412475826, 4.475186877509025, 2.47<br>
22515272283383, 5.81111616519857, 1.348120154395125, 7.459090620436449,<br>
—END ENCRYPT—</p>
<p>—START DECRYPT—<br>
uppercase match for byte: 84 and key: 3.94329641832398<br>
number match for byte: 49 and key: 6.917000942786805<br>
lowercase match for byte: 116 and key: 0.8792030412475826<br>
symbol match for byte: 59 and key: 4.475186877509025<br>
uppercase match for byte: 83 and key: 2.4722515272283383<br>
symbol match for byte: 39 and key: 5.81111616519857<br>
lowercase match for byte: 101 and key: 1.348120154395125<br>
number match for byte: 50 and key: 7.459090620436449</p>
<p>Decrypted Bytes:<br>
84,49,116,59,83,39,101,50,</p>
<p>T1t;S’e2<br>
teST;'12<br>
—END DECRYPT—</p>
<p>C:\Users\Mike.Mike-PC\Desktop&gt;[/code]</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312/1</link>
        <pubDate>Fri, 17 Feb 2012 23:55:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-433312-1</guid>
        <source url="https://forum.moparisthebest.com/t/basic-encryption-algorithm/433312.rss">Basic Encryption Algorithm</source>
      </item>
  </channel>
</rss>
