<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>A* Pathfinding</title>
    <link>https://forum.moparisthebest.com/t/a-pathfinding/525108</link>
    <description>Wrote this over a year ago. I really hope no one tries to use this.  :|

https://en.wikipedia.org/wiki/A*_search_algorithm

[code]
public class AStarPathFinding implements PathFinding {

	/**
	 * The walking direction to adjacent squares.
	 */
	private static final int[][] DIR = { { -1, 1 }, { 0, 1 }, { 1, 1 },
			{ -1, 0 }, { 1, 0 }, { -1, -1 }, { 0, -1 }, { 1, -1 } };

	private Node[][] openNodes = null;
	private Node[][] closedNodes = null;

	public NodeComparator nodeComparator = new NodeComparator();

	private Queue&lt;Node&gt; openList = null;

	public AStarPathFinding() {}

	public Deque&lt;Node&gt; findPath(Entity entity, final int x, final int y, int z,
			final int destX, final int destY) {

		Node startNode = new Node(x, y, 0, 0, -1, null);
		Node goalNode = new Node(destX, destY, 0, 0, -1, null);
		Node current = new Node(x, y, 0, 0, -1, null);
		Node adj = null;

		int currentArrayX = 150;
		int currentArrayY = 150;

		refresh();

		openList.add(current);
		openNodes[currentArrayX][currentArrayY] = current;

		while (openList.size() &gt; 0) {

			if (Math.abs(current.getX() - goalNode.getX()) &gt; 31
					|| Math.abs(current.getY() - goalNode.getY()) &gt; 31
					|| Math.abs(current.getX() - goalNode.getX()) &lt; -31
					|| Math.abs(current.getY() - goalNode.getY()) &lt; -31) {
				return null;
			}

			current = openList.poll();

			if (current.matches(goalNode)) {
				break;
			}

			currentArrayX = (x - current.getX()) + 150;
			currentArrayY = (y - current.getY()) + 150;

			openNodes[currentArrayX][currentArrayY] = null;
			closedNodes[currentArrayX][currentArrayY] = current;

			for (int i = 0; i &lt; 8; i++) {

				int adjX = current.getX() + DIR[i][0];
				int adjY = current.getY() + DIR[i][1];

				int currentAdjArrayX = (x - adjX) + 150;
				int currentAdjArrayY = (y - adjY) + 150;

				if (closedNodes[currentAdjArrayX][currentAdjArrayY] != null) {
					int g = getG(
							closedNodes[currentAdjArrayX][currentAdjArrayY],
							current);
					if (g &lt; closedNodes[currentAdjArrayX][currentAdjArrayY]
							.getG()) {
						Node node = closedNodes[currentAdjArrayX][currentAdjArrayY];
						node.setG(g);
						node.setH(getH(node, goalNode));
						node.setF(node.getG() + node.getH());
						node.setParent(current);
						node.setI(i);
						closedNodes[currentAdjArrayX][currentAdjArrayY] = null;
						openList.add(node);
					}
					continue;
				}

				if (!walkable(entity, current.getX(), current.getY(), i)) {
					continue;
				}

				if (openNodes[currentAdjArrayX][currentAdjArrayY] != null) {
					int g = getG(openNodes[currentAdjArrayX][currentAdjArrayY],
							current);
					if (g &lt; openNodes[currentAdjArrayX][currentAdjArrayY]
							.getG()) {
						Node node = openNodes[currentAdjArrayX][currentAdjArrayY];
						node.setG(g);
						node.setH(getH(node, goalNode));
						node.setF(node.getG() + node.getH());
						node.setParent(current);
						node.setI(i);
						openNodes[currentAdjArrayX][currentAdjArrayY] = node;
						openList.add(node);
					}
					continue;
				}

				adj = new Node(adjX, adjY, 0, 0, -1, current);
				adj.setG(getG(adj, current));
				adj.setH(getH(adj, goalNode));
				adj.setF(adj.getG() + adj.getH());
				adj.setI(i);
				openList.add(adj);
				openNodes[currentAdjArrayX][currentAdjArrayY] = adj;

			}

		}

		Deque&lt;Node&gt; path = new LinkedList&lt;Node&gt;();

		while (current != null) {
			if (current.matches(startNode)) {
				break;
			}
			path.offerFirst(current);
			current = current.getParent();
		}

		reset();
		return path;
	}

	public void refresh() {
		openNodes = new Node[300][300];
		closedNodes = new Node[300][300];
		openList = new PriorityQueue&lt;Node&gt;(1, nodeComparator);
	}

	public void reset() {
		openNodes = null;
		closedNodes = null;
		openList = null;
	}

	public static boolean walkable(Entity entity, int x, int y, int i) {
		return !entity.getMovementController().directionBlocked(x, y, i);
	}

	public static int getG(Node node, Node current) {
		return ((Math.abs(current.getX() - node.getX()) &gt; 0 &amp;&amp; Math.abs(current
				.getY() - node.getY()) &gt; 0) ? 14 : 10)
				+ current.getG();
	}

	// manhattan distance heuristic
	public static int getH(Node node, Node goalNode) {
		return (Math.abs(goalNode.getX() - node.getX()) + Math.abs(goalNode
				.getY() - node.getY()));
	}

	public class NodeComparator implements Comparator&lt;Node&gt; {

		public int compare(Node node1, Node node2) {
			int f1 = node1.getF();
			int f2 = node2.getF();
			if (f1 == f2) {
				return 0;
			} else if (f1 &gt; f2) {
				return 1;
			} else {
				return -1;
			}
		}

		public boolean equals(Node node) {
			return false;
		}

	}

}
[/code]

[code]
public class Node {
	
	private int x;
	private int y;
	private int z;
	private int g;
	private int h;
	private int f;
	private int i;
	private Node parent;
	
	public Node(int x, int y, int g, int h, int i, Node parent) {
		this.x = x;
		this.y = y;
		this.parent = parent;
		this.g = g;
		this.h = h;
		this.i = i;
		f = g + h;
	}
	
	public boolean matches(Node node) {
		if (x == node.x &amp;&amp; y == node.y) {
			return true;
		}
		return false;
	}
	
	@Override
	public String toString() {
		return &quot;Node [x=&quot; + x + &quot;, y=&quot; + y + &quot;, g=&quot; + g + &quot;, h=&quot; + h
				+ &quot;, f=&quot; + f + &quot;]&quot;;
	}

	/**
	 * @return the x
	 */
	public int getX() {
		return x;
	}

	/**
	 * @param x the x to set
	 */
	public void setX(int x) {
		this.x = x;
	}

	/**
	 * @return the y
	 */
	public int getY() {
		return y;
	}

	/**
	 * @param y the y to set
	 */
	public void setY(int y) {
		this.y = y;
	}

	/**
	 * @return the z
	 */
	public int getZ() {
		return z;
	}

	/**
	 * @param z the z to set
	 */
	public void setZ(int z) {
		this.z = z;
	}

	/**
	 * @return the g
	 */
	public int getG() {
		return g;
	}

	/**
	 * @param g the g to set
	 */
	public void setG(int g) {
		this.g = g;
	}

	/**
	 * @return the h
	 */
	public int getH() {
		return h;
	}

	/**
	 * @param h the h to set
	 */
	public void setH(int h) {
		this.h = h;
	}

	/**
	 * @return the f
	 */
	public int getF() {
		return f;
	}

	/**
	 * @param f the f to set
	 */
	public void setF(int f) {
		this.f = f;
	}
	
	public int getI() {
		return i;
	}
	
	/**
	 * @param i the i to set
	 */
	public void setI(int i) {
		this.i = i;
	}

	/**
	 * @return the parent
	 */
	public Node getParent() {
		return parent;
	}

	/**
	 * @param parent the parent to set
	 */
	public void setParent(Node parent) {
		this.parent = parent;
	}
	
}
[/code]

Enjoy.</description>
    
    <lastBuildDate>Sun, 21 Jul 2013 18:21:08 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@Pwnd Pwnd]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/pwnd">@Pwnd</a> wrote:</p>
          <blockquote>
              <p>[quote=“Clawz fury, post:7, topic:525108”]snippet, but good work i cba to thoroughly read it[/quote]How do you know it’s good work?  LoL</p>
<p>I wouldn’t even call posting the algorithm an explanation though, really.  I knew I couldn’t expect MSCP to grow up and stop stealing shit lol.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/10</link>
        <pubDate>Sun, 21 Jul 2013 18:21:08 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-10</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@davidi2 Davidi2]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/davidi2">@davidi2</a> wrote:</p>
          <blockquote>
              <p>Your code looks almost like a rehashed version of this:<br>
<a href="https://bitbucket.org/kevglass/slick/src/9d7443ec33af80e3cd1d249d99087437d39d5f48/trunk/Slick/src/org/newdawn/slick/util/pathfinding/AStarPathFinder.java?at=default" class="onebox" target="_blank">https://bitbucket.org/kevglass/slick/src/9d7443ec33af80e3cd1d249d99087437d39d5f48/trunk/Slick/src/org/newdawn/slick/util/pathfinding/AStarPathFinder.java?at=default</a></p>
<p>And your explanation is just ripped from this:<br>
<aside class="onebox stackexchange">
  <header class="source">
      <a href="https://stackoverflow.com/questions/13578287/a-a-star-algorithm-clarification" target="_blank" rel="nofollow noopener">stackoverflow.com</a>
  </header>
  <article class="onebox-body">
      <a href="https://stackoverflow.com/users/659057/archenil" target="_blank" rel="nofollow noopener">
    <img alt="archenil" src="https://www.gravatar.com/avatar/8023a4aa1c70f249028e7efe8cd5d31e?s=128&amp;d=identicon&amp;r=PG" class="thumbnail onebox-avatar" width="128" height="128">
  </a>
<h4>
  <a href="https://stackoverflow.com/questions/13578287/a-a-star-algorithm-clarification" target="_blank" rel="nofollow noopener">A* (A Star) Algorithm Clarification</a>
</h4>

<div class="tags">
  <strong>a-star</strong>
</div>

<div class="date">
  asked by
  
  <a href="https://stackoverflow.com/users/659057/archenil" target="_blank" rel="nofollow noopener">
    archenil
  </a>
  on <a href="https://stackoverflow.com/questions/13578287/a-a-star-algorithm-clarification" target="_blank" rel="nofollow noopener">06:06AM - 27 Nov 12</a>
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
</p>
<p>Meh</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/9</link>
        <pubDate>Fri, 19 Jul 2013 02:45:00 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-9</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@jc22493 Jc22493]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/jc22493">@jc22493</a> wrote:</p>
          <blockquote>
              <p>Moved.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/8</link>
        <pubDate>Fri, 19 Jul 2013 01:50:11 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-8</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@Clawz_fury lare69]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/clawz_fury">@Clawz_fury</a> wrote:</p>
          <blockquote>
              <p>snippet, but good work i cba to thoroughly read it</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/7</link>
        <pubDate>Thu, 18 Jul 2013 23:16:11 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-7</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@Mikey_Sasse Mikey Sasse]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mikey_sasse">@Mikey_Sasse</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="5" data-topic="525108">
<div class="title">
<div class="quote-controls"></div>
 Vain_:</div>
<blockquote>
<p>documentation/comments is not sufficient explanation. you have to put effort into the thread itself. or post it as a snippet</p>
</blockquote>
</aside>
<p>It’s already here, if it needs to be moved I’m sure someone will move it.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/6</link>
        <pubDate>Tue, 16 Jul 2013 02:10:32 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-6</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@Vain1 Vain_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/vain1">@Vain1</a> wrote:</p>
          <blockquote>
              <p>documentation/comments is not sufficient explanation. you have to put effort into the thread itself. or post it as a snippet</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/5</link>
        <pubDate>Tue, 16 Jul 2013 02:08:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-5</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@Mikey_Sasse Mikey Sasse]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mikey_sasse">@Mikey_Sasse</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="2" data-topic="525108">
<div class="title">
<div class="quote-controls"></div>
 Vain_:</div>
<blockquote>
<p>not explained = snippet</p>
</blockquote>
</aside>
<pre><code class="lang-auto"> function A*(start,goal)
     closedset := the empty set    // The set of nodes already evaluated.
     openset := {start}    // The set of tentative nodes to be evaluated, initially containing the start node
     came_from := the empty map    // The map of navigated nodes.
 
     g_score[start] := 0    // Cost from start along best known path.
     // Estimated total cost from start to goal through y.
     f_score[start] := g_score[start] + heuristic_cost_estimate(start, goal)
 
     while openset is not empty
         current := the node in openset having the lowest f_score[] value
         if current = goal
             return reconstruct_path(came_from, goal)
 
         remove current from openset
         add current to closedset
         for each neighbor in neighbor_nodes(current)
             tentative_g_score := g_score[current] + dist_between(current,neighbor)
             if neighbor in closedset and tentative_g_score &gt;= g_score[neighbor]
                     continue
 
             if neighbor not in openset or tentative_g_score &lt; g_score[neighbor] 
                 came_from[neighbor] := current
                 g_score[neighbor] := tentative_g_score
                 f_score[neighbor] := g_score[neighbor] + heuristic_cost_estimate(neighbor, goal)
                 if neighbor not in openset
                     add neighbor to openset
 
     return failure
 
 function reconstruct_path(came_from, current_node)
     if current_node in came_from
         p := reconstruct_path(came_from, came_from[current_node])
         return (p + current_node)
     else
         return current_node</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/4</link>
        <pubDate>Tue, 16 Jul 2013 02:05:44 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-4</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@asshole_rule asshole_rule]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/asshole_rule">@asshole_rule</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="1" data-topic="525108">
<div class="title">
<div class="quote-controls"></div>
 Mikey Sasse:</div>
<blockquote>
<p>Wrote this over a year ago. I really hope no one tries to use this.  <img src="https://forum.moparisthebest.com/images/emoji/twitter/expressionless.png?v=5" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
</blockquote>
</aside>
<p>Why?  <img src="https://forum.moparisthebest.com/images/emoji/twitter/confused.png?v=5" title=":confused:" class="emoji" alt=":confused:"></p>
<p>Have you tested this yet? Speed, any glitches, ect?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/3</link>
        <pubDate>Tue, 16 Jul 2013 01:56:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-3</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@Vain1 Vain_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/vain1">@Vain1</a> wrote:</p>
          <blockquote>
              <p>not explained = snippet</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/2</link>
        <pubDate>Tue, 16 Jul 2013 01:52:58 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-2</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
      <item>
        <title>A* Pathfinding</title>
        <dc:creator><![CDATA[@Mikey_Sasse Mikey Sasse]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mikey_sasse">@Mikey_Sasse</a> wrote:</p>
          <blockquote>
              <p>Wrote this over a year ago. I really hope no one tries to use this.  <img src="https://forum.moparisthebest.com/images/emoji/twitter/expressionless.png?v=5" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
<aside class="onebox wikipedia">
  <header class="source">
      <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="nofollow noopener">en.wikipedia.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:220/350;"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/0/0c/SRI_Shakey_with_callouts.jpg/220px-SRI_Shakey_with_callouts.jpg" class="thumbnail"></div>

<h3><a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="nofollow noopener">A* search algorithm</a></h3>

<p>In computer science, A* (pronounced as "A star") is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently directed path between multiple points, called "nodes". It enjoys widespread use due to its performance and accuracy. However, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, although other work has found A* to be superior to other appro Pe...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<pre><code class="lang-auto">public class AStarPathFinding implements PathFinding {

	/**
	 * The walking direction to adjacent squares.
	 */
	private static final int[][] DIR = { { -1, 1 }, { 0, 1 }, { 1, 1 },
			{ -1, 0 }, { 1, 0 }, { -1, -1 }, { 0, -1 }, { 1, -1 } };

	private Node[][] openNodes = null;
	private Node[][] closedNodes = null;

	public NodeComparator nodeComparator = new NodeComparator();

	private Queue&lt;Node&gt; openList = null;

	public AStarPathFinding() {}

	public Deque&lt;Node&gt; findPath(Entity entity, final int x, final int y, int z,
			final int destX, final int destY) {

		Node startNode = new Node(x, y, 0, 0, -1, null);
		Node goalNode = new Node(destX, destY, 0, 0, -1, null);
		Node current = new Node(x, y, 0, 0, -1, null);
		Node adj = null;

		int currentArrayX = 150;
		int currentArrayY = 150;

		refresh();

		openList.add(current);
		openNodes[currentArrayX][currentArrayY] = current;

		while (openList.size() &gt; 0) {

			if (Math.abs(current.getX() - goalNode.getX()) &gt; 31
					|| Math.abs(current.getY() - goalNode.getY()) &gt; 31
					|| Math.abs(current.getX() - goalNode.getX()) &lt; -31
					|| Math.abs(current.getY() - goalNode.getY()) &lt; -31) {
				return null;
			}

			current = openList.poll();

			if (current.matches(goalNode)) {
				break;
			}

			currentArrayX = (x - current.getX()) + 150;
			currentArrayY = (y - current.getY()) + 150;

			openNodes[currentArrayX][currentArrayY] = null;
			closedNodes[currentArrayX][currentArrayY] = current;

			for (int i = 0; i &lt; 8; i++) {

				int adjX = current.getX() + DIR[i][0];
				int adjY = current.getY() + DIR[i][1];

				int currentAdjArrayX = (x - adjX) + 150;
				int currentAdjArrayY = (y - adjY) + 150;

				if (closedNodes[currentAdjArrayX][currentAdjArrayY] != null) {
					int g = getG(
							closedNodes[currentAdjArrayX][currentAdjArrayY],
							current);
					if (g &lt; closedNodes[currentAdjArrayX][currentAdjArrayY]
							.getG()) {
						Node node = closedNodes[currentAdjArrayX][currentAdjArrayY];
						node.setG(g);
						node.setH(getH(node, goalNode));
						node.setF(node.getG() + node.getH());
						node.setParent(current);
						node.setI(i);
						closedNodes[currentAdjArrayX][currentAdjArrayY] = null;
						openList.add(node);
					}
					continue;
				}

				if (!walkable(entity, current.getX(), current.getY(), i)) {
					continue;
				}

				if (openNodes[currentAdjArrayX][currentAdjArrayY] != null) {
					int g = getG(openNodes[currentAdjArrayX][currentAdjArrayY],
							current);
					if (g &lt; openNodes[currentAdjArrayX][currentAdjArrayY]
							.getG()) {
						Node node = openNodes[currentAdjArrayX][currentAdjArrayY];
						node.setG(g);
						node.setH(getH(node, goalNode));
						node.setF(node.getG() + node.getH());
						node.setParent(current);
						node.setI(i);
						openNodes[currentAdjArrayX][currentAdjArrayY] = node;
						openList.add(node);
					}
					continue;
				}

				adj = new Node(adjX, adjY, 0, 0, -1, current);
				adj.setG(getG(adj, current));
				adj.setH(getH(adj, goalNode));
				adj.setF(adj.getG() + adj.getH());
				adj.setI(i);
				openList.add(adj);
				openNodes[currentAdjArrayX][currentAdjArrayY] = adj;

			}

		}

		Deque&lt;Node&gt; path = new LinkedList&lt;Node&gt;();

		while (current != null) {
			if (current.matches(startNode)) {
				break;
			}
			path.offerFirst(current);
			current = current.getParent();
		}

		reset();
		return path;
	}

	public void refresh() {
		openNodes = new Node[300][300];
		closedNodes = new Node[300][300];
		openList = new PriorityQueue&lt;Node&gt;(1, nodeComparator);
	}

	public void reset() {
		openNodes = null;
		closedNodes = null;
		openList = null;
	}

	public static boolean walkable(Entity entity, int x, int y, int i) {
		return !entity.getMovementController().directionBlocked(x, y, i);
	}

	public static int getG(Node node, Node current) {
		return ((Math.abs(current.getX() - node.getX()) &gt; 0 &amp;&amp; Math.abs(current
				.getY() - node.getY()) &gt; 0) ? 14 : 10)
				+ current.getG();
	}

	// manhattan distance heuristic
	public static int getH(Node node, Node goalNode) {
		return (Math.abs(goalNode.getX() - node.getX()) + Math.abs(goalNode
				.getY() - node.getY()));
	}

	public class NodeComparator implements Comparator&lt;Node&gt; {

		public int compare(Node node1, Node node2) {
			int f1 = node1.getF();
			int f2 = node2.getF();
			if (f1 == f2) {
				return 0;
			} else if (f1 &gt; f2) {
				return 1;
			} else {
				return -1;
			}
		}

		public boolean equals(Node node) {
			return false;
		}

	}

}</code></pre>
<pre><code class="lang-auto">public class Node {
	
	private int x;
	private int y;
	private int z;
	private int g;
	private int h;
	private int f;
	private int i;
	private Node parent;
	
	public Node(int x, int y, int g, int h, int i, Node parent) {
		this.x = x;
		this.y = y;
		this.parent = parent;
		this.g = g;
		this.h = h;
		this.i = i;
		f = g + h;
	}
	
	public boolean matches(Node node) {
		if (x == node.x &amp;&amp; y == node.y) {
			return true;
		}
		return false;
	}
	
	@Override
	public String toString() {
		return "Node [x=" + x + ", y=" + y + ", g=" + g + ", h=" + h
				+ ", f=" + f + "]";
	}

	/**
	 * @return the x
	 */
	public int getX() {
		return x;
	}

	/**
	 * @param x the x to set
	 */
	public void setX(int x) {
		this.x = x;
	}

	/**
	 * @return the y
	 */
	public int getY() {
		return y;
	}

	/**
	 * @param y the y to set
	 */
	public void setY(int y) {
		this.y = y;
	}

	/**
	 * @return the z
	 */
	public int getZ() {
		return z;
	}

	/**
	 * @param z the z to set
	 */
	public void setZ(int z) {
		this.z = z;
	}

	/**
	 * @return the g
	 */
	public int getG() {
		return g;
	}

	/**
	 * @param g the g to set
	 */
	public void setG(int g) {
		this.g = g;
	}

	/**
	 * @return the h
	 */
	public int getH() {
		return h;
	}

	/**
	 * @param h the h to set
	 */
	public void setH(int h) {
		this.h = h;
	}

	/**
	 * @return the f
	 */
	public int getF() {
		return f;
	}

	/**
	 * @param f the f to set
	 */
	public void setF(int f) {
		this.f = f;
	}
	
	public int getI() {
		return i;
	}
	
	/**
	 * @param i the i to set
	 */
	public void setI(int i) {
		this.i = i;
	}

	/**
	 * @return the parent
	 */
	public Node getParent() {
		return parent;
	}

	/**
	 * @param parent the parent to set
	 */
	public void setParent(Node parent) {
		this.parent = parent;
	}
	
}</code></pre>
<p>Enjoy.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/a-pathfinding/525108/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/a-pathfinding/525108/1</link>
        <pubDate>Tue, 16 Jul 2013 01:44:50 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-525108-1</guid>
        <source url="https://forum.moparisthebest.com/t/a-pathfinding/525108.rss">A* Pathfinding</source>
      </item>
  </channel>
</rss>
