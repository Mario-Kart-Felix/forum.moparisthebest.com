<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Client-sided Pathfinding</title>
    <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270</link>
    <description>Before I start, the server-sided stuff is going to require a lot of work on your part. It&#39;s C# code and written specifically for my and my friend&#39;s server.

This is something I implemented into my server after not wanting to calculate my own paths since it involved cache work and possibly impacted performance. So, I experimented a little and came up with this. I wrote it mainly for combat purposes, so I&#39;m not sure if it&#39;ll keep up with things like right-click following well.

Anyway, this is mainly a client edit, but also involves some server work. I&#39;m using a non-renamed client for this, but it&#39;s easy to convert since I used a renamed one to figure everything out.

[b]Client-sided[/b]
First, in Class31, change packet 2&#39;s size to 3. It&#39;s called anIntArray553 and you&#39;re looking for the 3rd number. Next, in the Client class, under the packet parsing method method145 after it&#39;s acquired the packet size and is ready to start parsing packets, add this code:

[code]			//Begin custom packets
			if(anInt1008 == 2) //Force walk
			{
				int pathType = aClass30_Sub2_Sub2_1083.method408();
				int entityID = aClass30_Sub2_Sub2_1083.method410();
				
				if(pathType == 0) //Move to player
				{
					Class30_Sub2_Sub4_Sub1_Sub2 class30_sub2_sub4_sub1_sub2_2 = aClass30_Sub2_Sub4_Sub1_Sub2Array890[entityID];
					if(class30_sub2_sub4_sub1_sub2_2 != null)
					{
						method85(2, 0, 1, -11308, 0, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1501[0], 1, 0, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub2_2)).anIntArray1501[0], ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1500[0], false, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub2_2)).anIntArray1500[0]);
					}
				}
				else if(pathType == 1) //Move to NPC
				{
					Class30_Sub2_Sub4_Sub1_Sub1 class30_sub2_sub4_sub1_sub1_6 = aClass30_Sub2_Sub4_Sub1_Sub1Array835[entityID];
					if(class30_sub2_sub4_sub1_sub1_6 != null)
					{
						method85(2, 0, 1, -11308, 0, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1501[0], 1, 0, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1501[0], ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1500[0], false, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1500[0]);
					}
				}
				else if(pathType == 2) //Request path for NPC
				{
					Class30_Sub2_Sub4_Sub1_Sub1 class30_sub2_sub4_sub1_sub1_6 = aClass30_Sub2_Sub4_Sub1_Sub1Array835[entityID];
					if(class30_sub2_sub4_sub1_sub1_6 != null)
					{
						customWalkPacket(0, 1, -11308, 0, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1501[0], 1, 0, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1501[0], ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1500[0], false, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1500[0], entityID);
					}
				}
				
				anInt1008 = -1;
				return true;
			}
			//End custom packets[/code]

I&#39;ll explain it in a bit. Next, add this method anywhere in the Client class:

[code]	public final boolean customWalkPacket(int j, int k, int l, int i1, int j1, int k1, 
            int l1, int i2, int j2, boolean flag, int k2, int entityID)
    {
        byte byte0 = 104;
        byte byte1 = 104;
        for(int l2 = 0; l2 &lt; byte0; l2++)
        {
            for(int i3 = 0; i3 &lt; byte1; i3++)
            {
                anIntArrayArray901[l2][i3] = 0;
                anIntArrayArray825[l2][i3] = 0x5f5e0ff;
            }

        }

        int j3 = j2;
        int k3 = j1;
        anIntArrayArray901[j2][j1] = 99;
        anIntArrayArray825[j2][j1] = 0;
        int l3 = 0;
        int i4 = 0;
        anIntArray1280[l3] = j2;
        anIntArray1281[l3++] = j1;
        boolean flag1 = false;
        int j4 = anIntArray1280.length;
        int ai[][] = aClass11Array1230[anInt918].anIntArrayArray294;
        while(i4 != l3) 
        {
            j3 = anIntArray1280[i4];
            k3 = anIntArray1281[i4];
            i4 = (i4 + 1) % j4;
            if(j3 == k2 &amp;&amp; k3 == i2)
            {
                flag1 = true;
                break;
            }
            if(i1 != 0)
            {
                if((i1 &lt; 5 || i1 == 10) &amp;&amp; aClass11Array1230[anInt918].method219(k2, j3, k3, 0, j, i1 - 1, i2))
                {
                    flag1 = true;
                    break;
                }
                if(i1 &lt; 10 &amp;&amp; aClass11Array1230[anInt918].method220(k2, i2, k3, i1 - 1, j, j3, 0))
                {
                    flag1 = true;
                    break;
                }
            }
            if(k1 != 0 &amp;&amp; k != 0 &amp;&amp; aClass11Array1230[anInt918].method221((byte)1, i2, k2, j3, k, l1, k1, k3))
            {
                flag1 = true;
                break;
            }
            int l4 = anIntArrayArray825[j3][k3] + 1;
            if(j3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 - 1][k3] == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0)
            {
                anIntArray1280[l3] = j3 - 1;
                anIntArray1281[l3] = k3;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3 - 1][k3] = 2;
                anIntArrayArray825[j3 - 1][k3] = l4;
            }
            if(j3 &lt; byte0 - 1 &amp;&amp; anIntArrayArray901[j3 + 1][k3] == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0)
            {
                anIntArray1280[l3] = j3 + 1;
                anIntArray1281[l3] = k3;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3 + 1][k3] = 8;
                anIntArrayArray825[j3 + 1][k3] = l4;
            }
            if(k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3][k3 - 1] == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0)
            {
                anIntArray1280[l3] = j3;
                anIntArray1281[l3] = k3 - 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3][k3 - 1] = 1;
                anIntArrayArray825[j3][k3 - 1] = l4;
            }
            if(k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3][k3 + 1] == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
            {
                anIntArray1280[l3] = j3;
                anIntArray1281[l3] = k3 + 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3][k3 + 1] = 4;
                anIntArrayArray825[j3][k3 + 1] = l4;
            }
            if(j3 &gt; 0 &amp;&amp; k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 - 1][k3 - 1] == 0 &amp;&amp; (ai[j3 - 1][k3 - 1] &amp; 0x128010e) == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0)
            {
                anIntArray1280[l3] = j3 - 1;
                anIntArray1281[l3] = k3 - 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3 - 1][k3 - 1] = 3;
                anIntArrayArray825[j3 - 1][k3 - 1] = l4;
            }
            if(j3 &lt; byte0 - 1 &amp;&amp; k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 + 1][k3 - 1] == 0 &amp;&amp; (ai[j3 + 1][k3 - 1] &amp; 0x1280183) == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0)
            {
                anIntArray1280[l3] = j3 + 1;
                anIntArray1281[l3] = k3 - 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3 + 1][k3 - 1] = 9;
                anIntArrayArray825[j3 + 1][k3 - 1] = l4;
            }
            if(j3 &gt; 0 &amp;&amp; k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3 - 1][k3 + 1] == 0 &amp;&amp; (ai[j3 - 1][k3 + 1] &amp; 0x1280138) == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
            {
                anIntArray1280[l3] = j3 - 1;
                anIntArray1281[l3] = k3 + 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3 - 1][k3 + 1] = 6;
                anIntArrayArray825[j3 - 1][k3 + 1] = l4;
            }
            if(j3 &lt; byte0 - 1 &amp;&amp; k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3 + 1][k3 + 1] == 0 &amp;&amp; (ai[j3 + 1][k3 + 1] &amp; 0x12801e0) == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
            {
                anIntArray1280[l3] = j3 + 1;
                anIntArray1281[l3] = k3 + 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[j3 + 1][k3 + 1] = 12;
                anIntArrayArray825[j3 + 1][k3 + 1] = l4;
            }
        }
        anInt1264 = 0;
        if(!flag1)
        {
            if(flag)
            {
                int i5 = 100;
                for(int k5 = 1; k5 &lt; 2; k5++)
                {
                    for(int i6 = k2 - k5; i6 &lt;= k2 + k5; i6++)
                    {
                        for(int l6 = i2 - k5; l6 &lt;= i2 + k5; l6++)
                            if(i6 &gt;= 0 &amp;&amp; l6 &gt;= 0 &amp;&amp; i6 &lt; 104 &amp;&amp; l6 &lt; 104 &amp;&amp; anIntArrayArray825[i6][l6] &lt; i5)
                            {
                                i5 = anIntArrayArray825[i6][l6];
                                j3 = i6;
                                k3 = l6;
                                anInt1264 = 1;
                                flag1 = true;
                            }

                    }

                    if(flag1)
                        break;
                }

            }
            if(!flag1)
                return false;
        }
        i4 = 0;
        anIntArray1280[i4] = j3;
        anIntArray1281[i4++] = k3;
        if(l != -11308)
        {
            for(int j6 = 1; j6 &gt; 0; j6++);
        }
        int l5;
        for(int j5 = l5 = anIntArrayArray901[j3][k3]; j3 != j2 || k3 != j1; j5 = anIntArrayArray901[j3][k3])
        {
            if(j5 != l5)
            {
                l5 = j5;
                anIntArray1280[i4] = j3;
                anIntArray1281[i4++] = k3;
            }
            if((j5 &amp; 2) != 0)
                j3++;
            else
            if((j5 &amp; 8) != 0)
                j3--;
            if((j5 &amp; 1) != 0)
                k3++;
            else
            if((j5 &amp; 4) != 0)
                k3--;
        }

        if(i4 &gt; 0)
        {
            int k4 = i4;
            if(k4 &gt; 25)
                k4 = 25;
            i4--;
            int k6 = anIntArray1280[i4];
            int i7 = anIntArray1281[i4];
            anInt1288 += k4;
            if(anInt1288 &gt;= 92)
            {
                aClass30_Sub2_Sub2_1192.method397((byte)6, 36);
                aClass30_Sub2_Sub2_1192.method402(0);
                anInt1288 = 0;
            }
			
            aClass30_Sub2_Sub2_1192.method397((byte)6, 2);
            aClass30_Sub2_Sub2_1192.method398(k4 + k4 + 5);
			
			aClass30_Sub2_Sub2_1192.method399(entityID);
			
            aClass30_Sub2_Sub2_1192.method433(0, k6 + anInt1034);
			//Disable marker
            //anInt1261 = anIntArray1280[0];
            //anInt1262 = anIntArray1281[0];
            for(int j7 = 1; j7 &lt; k4; j7++)
            {
                i4--;
                aClass30_Sub2_Sub2_1192.method398(anIntArray1280[i4] - k6);
                aClass30_Sub2_Sub2_1192.method398(anIntArray1281[i4] - i7);
            }

            aClass30_Sub2_Sub2_1192.method431(true, i7 + anInt1035);
            aClass30_Sub2_Sub2_1192.method424(super.anIntArray30[5] != 1 ? 0 : 1, 0);
            return true;
        }
        return true;
    }[/code]

Alright, so the first part you added is the handling of the new packet, packet [b]2[/b]. Its made up of 3 bytes - the path request type (one byte) and the entity ID to move to (two bytes). It&#39;s pretty much a reverse of the &quot;attack/trade/follow&quot; menu actions. Type 0 is &quot;Move to Player&quot;, 1 is &quot;Move to NPC&quot;, and 2 is &quot;Move NPC to Player&quot;. Type 2 is what uses the second block of code you added, which just sends a modified version of the regular walk-to packet. Except, before the first step, is the NPC ID for the server to handle, and the path is reversed (in the calling anyway). Here&#39;s an example of how you&#39;d use each type

[code]			if (command.StartsWith(&quot;movetoplayer&quot;))
			{
				try
				{
					Player forcewalk = Main.Server.PlayerHandler.PlayerForName(parts[1].ToLower());
					if (forcewalk != null)
					{
						if (MathOperations.InUpdateRange(p.X, p.Y, forcewalk.X, forcewalk.Y))
							Engine.ForceWalk(forcewalk, 0, p.PlayerIndex);
						else
							Engine.SendMessage(p, forcewalk.UserName + &quot; is out of the update range.&quot;);
					}
					else
						Engine.SendMessage(p, &quot;Player &quot; + parts[1] + &quot; not found.&quot;);
				}
				catch (Exception)
				{
					Engine.SendMessage(p, &quot;Bad command input.&quot;);
				}
				return;
			}
			if (command.StartsWith(&quot;movetonpc&quot;))
			{
				try
				{
					NPC forcewalk = Main.Server.NPCHandler.NPCs[int.Parse(parts[1])];
					if (forcewalk != null)
					{
						if (MathOperations.InUpdateRange(p.X, p.Y, forcewalk.X, forcewalk.Y))
							Engine.ForceWalk(p, 1, forcewalk.NPCIndex);
						else
							Engine.SendMessage(p, forcewalk.NPCIndex + &quot; is out of the update range.&quot;);
					}
					else
						Engine.SendMessage(p, &quot;NPC &quot; + parts[1] + &quot; not found.&quot;);
				}
				catch (Exception)
				{
					Engine.SendMessage(p, &quot;Bad command input.&quot;);
				}
				return;
			}
			if (command.StartsWith(&quot;movenpc&quot;))
			{
				try
				{
					NPC forcewalk = Main.Server.NPCHandler.NPCs[int.Parse(parts[1])];
					if (forcewalk != null)
					{
						forcewalk.FaceEntity(p.PlayerIndex + 0x7FFF);
						p.FaceEntity(forcewalk.NPCIndex + 0x8000);
						Engine.ForceWalk(p, 2, forcewalk.NPCIndex);
					}
					else
						Engine.SendMessage(p, &quot;NPC &quot; + parts[1] + &quot; not found.&quot;);
				}
				catch (Exception)
				{
					Engine.SendMessage(p, &quot;Bad command input.&quot;);
				}
				return;
			}[/code]

Note that&#39;s all server-sided code. Mine, in fact. Made just for testing. I&#39;m sure you guys could modify it to fit your servers if you wished.

[b]Server-sided[/b]
This stuff is rather easy, although winterLove-based servers like DeltaScape, PI, etc... aren&#39;t going to have fun with this one. First off, you&#39;re going to want to find your packet size array and changed packet 2 (the 3rd number) to -1. This signifies the packet size will be included in the packet header. Anyway, upon handling it, you&#39;re going to going to want to add this code (change it to fit your server, obviously). The code was mainly based on Hyperion&#39;s code to handle walking, so if you&#39;re using Hyperion you&#39;re in luck.

[code]		public static void HandlePacket(Player p, int id, int size)
		{
			ushort entity = p.InStream.ReadWord();
			size -= 2;

			if (Server.NPCHandler.NPCs[entity] != null)
			{
				NPC n = Server.NPCHandler.NPCs[entity];
				//if (n.Teleported)
				//	return;

				n.WalkingQueue.Reset();
				int steps = (size - 5) / 2;
				int[,] path = new int[steps, 2];
				int firstX, firstY;
				firstX = p.InStream.ReadSignedWordLittleEndianA();

				for (int i = 0; i &lt; steps; i++)
				{
					path[i, 0] = p.InStream.ReadSignedByte();
					path[i, 1] = p.InStream.ReadSignedByte();
				}
				firstY = p.InStream.ReadSignedWordLittleEndian();
				p.InStream.ReadByteC();
				//p.WalkingQueue.SetRunningQueue(runSteps);
				n.WalkingQueue.AddStep(firstX, firstY);

				for (int i = 0; i &lt; steps; i++)
				{
					path[i, 0] += firstX;
					path[i, 1] += firstY;
					n.WalkingQueue.AddStep(path[i, 0], path[i, 1]);
				}
				n.WalkingQueue.Finish();
			}
		}[/code]

Here&#39;s some code to actually send the request packet.

[code]		public static void ForceWalk(Player p, byte type, int id)
		{
			p.CreatePacket(2);
			p.OutStream.WriteByte(type);
			p.OutStream.WriteWord((ushort)id);
		}[/code]

So that&#39;s all, unless I missed something. Here&#39;s a video of it in action (notice the delay - you can probably tweak some server stuff to decrease this but this is how it turned out).

[youtube]http://www.youtube.com/watch?v=38P6p4kNJLM[/youtube]

Enjoy.

~Lin</description>
    
    <lastBuildDate>Sun, 15 Apr 2012 01:58:58 +0000</lastBuildDate>
    <category>Runescape</category>
    <atom:link href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@Lin Lin]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lin">@Lin</a> wrote:</p>
          <blockquote>
              <p>[quote=“dain bramage, post:10, topic:439270”]Bad idea. You should just let the server do it (with the cache). You’ll need the cache for the update server so you will have to do cache work anyway (which is your reason for doing it like this?). This by the looks of it requires much more work then downloading the refactored cache utilities made by Jagex and decompressor by Apache. Interesting though.[/quote]I’m sorry but you’re… dumb…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/11</link>
        <pubDate>Sun, 15 Apr 2012 01:58:58 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-11</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@dain_bramage dain bramage]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/dain_bramage">@dain_bramage</a> wrote:</p>
          <blockquote>
              <p>Bad idea. You should just let the server do it (with the cache). You’ll need the cache for the update server so you will have to do cache work anyway (which is your reason for doing it like this?). This by the looks of it requires much more work then downloading the refactored cache utilities made by Jagex and decompressor by Apache. Interesting though.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/10</link>
        <pubDate>Sat, 14 Apr 2012 17:28:58 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-10</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“Method, post:8, topic:439270”][quote author=t4 link=topic=541973.msg3971154#msg3971154 date=1334172040]</p>
<pre><code class="lang-auto"></code></pre>
<p>yeah? the client does an A* search on the region where each tile has a true/false value of 0xffffff / 0x1000000. you could just dump the 2D array of tiles into some sort of region-database-esque structure and perform the same algorithm. the aforementioned seems like a lot better solution than relying on the client to do the work.<br>
[/quote]</p>
<p>Where does the client do an A* search? The code you posted just does a breadth-first search with some extra approximation at the end if a path can’t be found.[/quote]<br>
Well A* is a BFS w/ heuristics, but upon looking at my snippet again there is no use of heuristics; touche.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/9</link>
        <pubDate>Thu, 12 Apr 2012 20:15:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-9</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@Metho_D Method]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/metho_d">@Metho_D</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:4, topic:439270”]<code>snipped</code></p>
<p>yeah? the client does an A* search on the region where each tile has a true/false value of 0xffffff / 0x1000000. you could just dump the 2D array of tiles into some sort of region-database-esque structure and perform the same algorithm. the aforementioned seems like a lot better solution than relying on the client to do the work.[/quote]</p>
<p>Where does the client do an A* search? The code you posted just does a breadth-first search with some extra approximation at the end if a path can’t be found.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/8</link>
        <pubDate>Thu, 12 Apr 2012 19:13:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-8</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@Lin Lin]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lin">@Lin</a> wrote:</p>
          <blockquote>
              <p>I had players locked facing an NPC after making NPCs move towards them. Not a bug or anything. It was just me forgetting to reset their facing entity.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/7</link>
        <pubDate>Thu, 12 Apr 2012 01:38:03 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-7</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@the_elve_age the elve age]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_elve_age">@the_elve_age</a> wrote:</p>
          <blockquote>
              <p>I noticed player facing toward an object was a problem. When you clicked the wall/door/dummy whatever you clicked from the bank, you will see what I mean.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/6</link>
        <pubDate>Thu, 12 Apr 2012 01:00:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-6</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@Lin Lin]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lin">@Lin</a> wrote:</p>
          <blockquote>
              <p>I thought about doing that, but I disliked the idea of having to take door rotations into account manually. It was just a lot more work that way and it’s not like this is for anything extremely major. Just a simple alternative.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/5</link>
        <pubDate>Wed, 11 Apr 2012 22:00:53 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-5</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <pre><code class="lang-auto">    private boolean doWalkTo(int minimap, int const_zero1, int const_zero2, int const_zero3, int start_y, int const_zero4,
                             int const_zero5, int dest_y, int starturkish idiot, boolean flag, int desturkish idiot)
    {
  	  System.out.println("findWalkPath(minimap " + minimap + ", const " + const_zero1 + ", const " + const_zero2 + ", const " + const_zero3 + ", start_y "
  			  							+ start_y + ", const " + const_zero4 + ", const " + const_zero5 + ", dest_y " + dest_y + ", starturkish idiot " + starturkish idiot + ", const " + flag + ", desturkish idiot " + desturkish idiot + ")");

  	  System.out.println("baseX: " + baseX + " baseY: " + baseY + " plane: " + plane);
        byte byte0 = 104;
        byte byte1 = 104;
        for(int l2 = 0; l2 &lt; byte0; l2++)
        {
            for(int i3 = 0; i3 &lt; byte1; i3++)
            {
                anIntArrayArray901[l2][i3] = 0;
                anIntArrayArray825[l2][i3] = 0x5f5e0ff;
            }

        }

        int starturkish idiot_j3 = starturkish idiot;
        int start_y_k3 = start_y;
        anIntArrayArray901[starturkish idiot][start_y] = 99;
        anIntArrayArray825[starturkish idiot][start_y] = 0;
        int l3 = 0;
        int i4 = 0;
        bigX[l3] = starturkish idiot;
        bigY[l3++] = start_y;
        boolean flag1 = false;
        int j4 = bigX.length;
        
        int ai[][] = aClass11Array1230[plane].anIntArrayArray294;
        System.out.println(ai.hashCode());
        //aClass11Array1230[plane].print();
        
        while(i4 != l3) 
        {
            starturkish idiot_j3 = bigX[i4];
            start_y_k3 = bigY[i4];
            i4 = (i4 + 1) % j4;
            if(starturkish idiot_j3 == desturkish idiot &amp;&amp; start_y_k3 == dest_y)
            {
                flag1 = true;
                break;
            }
            if(const_zero3 != 0)
            {
                if((const_zero3 &lt; 5 || const_zero3 == 10) &amp;&amp; aClass11Array1230[plane].method219(desturkish idiot, starturkish idiot_j3, start_y_k3, const_zero1, const_zero3 - 1, dest_y))
                {
                    flag1 = true;
                    break;
                }
                if(const_zero3 &lt; 10 &amp;&amp; aClass11Array1230[plane].method220(desturkish idiot, dest_y, start_y_k3, const_zero3 - 1, const_zero1, starturkish idiot_j3))
                {
                    flag1 = true;
                    break;
                }
            }
            if(const_zero4 != 0 &amp;&amp; const_zero2 != 0 &amp;&amp; aClass11Array1230[plane].method221(dest_y, desturkish idiot, starturkish idiot_j3, const_zero2, const_zero5, const_zero4, start_y_k3))
            {
                flag1 = true;
                break;
            }
            int l4 = anIntArrayArray825[starturkish idiot_j3][start_y_k3] + 1;
            if(starturkish idiot_j3 &gt; 0 &amp;&amp; anIntArrayArray901[starturkish idiot_j3 - 1][start_y_k3] == 0 &amp;&amp; (ai[starturkish idiot_j3 - 1][start_y_k3] &amp; 0x1280108) == 0)
            {
                bigX[l3] = starturkish idiot_j3 - 1;
                bigY[l3] = start_y_k3;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3 - 1][start_y_k3] = 2;
                anIntArrayArray825[starturkish idiot_j3 - 1][start_y_k3] = l4;
            }
            if(starturkish idiot_j3 &lt; byte0 - 1 &amp;&amp; anIntArrayArray901[starturkish idiot_j3 + 1][start_y_k3] == 0 &amp;&amp; (ai[starturkish idiot_j3 + 1][start_y_k3] &amp; 0x1280180) == 0)
            {
                bigX[l3] = starturkish idiot_j3 + 1;
                bigY[l3] = start_y_k3;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3 + 1][start_y_k3] = 8;
                anIntArrayArray825[starturkish idiot_j3 + 1][start_y_k3] = l4;
            }
            if(start_y_k3 &gt; 0 &amp;&amp; anIntArrayArray901[starturkish idiot_j3][start_y_k3 - 1] == 0 &amp;&amp; (ai[starturkish idiot_j3][start_y_k3 - 1] &amp; 0x1280102) == 0)
            {
                bigX[l3] = starturkish idiot_j3;
                bigY[l3] = start_y_k3 - 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3][start_y_k3 - 1] = 1;
                anIntArrayArray825[starturkish idiot_j3][start_y_k3 - 1] = l4;
            }
            if(start_y_k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[starturkish idiot_j3][start_y_k3 + 1] == 0 &amp;&amp; (ai[starturkish idiot_j3][start_y_k3 + 1] &amp; 0x1280120) == 0)
            {
                bigX[l3] = starturkish idiot_j3;
                bigY[l3] = start_y_k3 + 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3][start_y_k3 + 1] = 4;
                anIntArrayArray825[starturkish idiot_j3][start_y_k3 + 1] = l4;
            }
            if(starturkish idiot_j3 &gt; 0 &amp;&amp; start_y_k3 &gt; 0 &amp;&amp; anIntArrayArray901[starturkish idiot_j3 - 1][start_y_k3 - 1] == 0 &amp;&amp; (ai[starturkish idiot_j3 - 1][start_y_k3 - 1] &amp; 0x128010e) == 0 &amp;&amp; (ai[starturkish idiot_j3 - 1][start_y_k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[starturkish idiot_j3][start_y_k3 - 1] &amp; 0x1280102) == 0)
            {
                bigX[l3] = starturkish idiot_j3 - 1;
                bigY[l3] = start_y_k3 - 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3 - 1][start_y_k3 - 1] = 3;
                anIntArrayArray825[starturkish idiot_j3 - 1][start_y_k3 - 1] = l4;
            }
            if(starturkish idiot_j3 &lt; byte0 - 1 &amp;&amp; start_y_k3 &gt; 0 &amp;&amp; anIntArrayArray901[starturkish idiot_j3 + 1][start_y_k3 - 1] == 0 &amp;&amp; (ai[starturkish idiot_j3 + 1][start_y_k3 - 1] &amp; 0x1280183) == 0 &amp;&amp; (ai[starturkish idiot_j3 + 1][start_y_k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[starturkish idiot_j3][start_y_k3 - 1] &amp; 0x1280102) == 0)
            {
                bigX[l3] = starturkish idiot_j3 + 1;
                bigY[l3] = start_y_k3 - 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3 + 1][start_y_k3 - 1] = 9;
                anIntArrayArray825[starturkish idiot_j3 + 1][start_y_k3 - 1] = l4;
            }
            if(starturkish idiot_j3 &gt; 0 &amp;&amp; start_y_k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[starturkish idiot_j3 - 1][start_y_k3 + 1] == 0 &amp;&amp; (ai[starturkish idiot_j3 - 1][start_y_k3 + 1] &amp; 0x1280138) == 0 &amp;&amp; (ai[starturkish idiot_j3 - 1][start_y_k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[starturkish idiot_j3][start_y_k3 + 1] &amp; 0x1280120) == 0)
            {
                bigX[l3] = starturkish idiot_j3 - 1;
                bigY[l3] = start_y_k3 + 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3 - 1][start_y_k3 + 1] = 6;
                anIntArrayArray825[starturkish idiot_j3 - 1][start_y_k3 + 1] = l4;
            }
            if(starturkish idiot_j3 &lt; byte0 - 1 &amp;&amp; start_y_k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[starturkish idiot_j3 + 1][start_y_k3 + 1] == 0 &amp;&amp; (ai[starturkish idiot_j3 + 1][start_y_k3 + 1] &amp; 0x12801e0) == 0 &amp;&amp; (ai[starturkish idiot_j3 + 1][start_y_k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[starturkish idiot_j3][start_y_k3 + 1] &amp; 0x1280120) == 0)
            {
                bigX[l3] = starturkish idiot_j3 + 1;
                bigY[l3] = start_y_k3 + 1;
                l3 = (l3 + 1) % j4;
                anIntArrayArray901[starturkish idiot_j3 + 1][start_y_k3 + 1] = 12;
                anIntArrayArray825[starturkish idiot_j3 + 1][start_y_k3 + 1] = l4;
            }
        }
        anInt1264 = 0;
        if(!flag1)
        {
            if(flag)
            {
                int i5 = 100;
                for(int k5 = 1; k5 &lt; 2; k5++)
                {
                    for(int i6 = desturkish idiot - k5; i6 &lt;= desturkish idiot + k5; i6++)
                    {
                        for(int l6 = dest_y - k5; l6 &lt;= dest_y + k5; l6++)
                            if(i6 &gt;= 0 &amp;&amp; l6 &gt;= 0 &amp;&amp; i6 &lt; 104 &amp;&amp; l6 &lt; 104 &amp;&amp; anIntArrayArray825[i6][l6] &lt; i5)
                            {
                                i5 = anIntArrayArray825[i6][l6];
                                starturkish idiot_j3 = i6;
                                start_y_k3 = l6;
                                anInt1264 = 1;
                                flag1 = true;
                            }

                    }

                    if(flag1)
                        break;
                }

            }
            if(!flag1)
                return false;
        }
        i4 = 0;
        bigX[i4] = starturkish idiot_j3;
        bigY[i4++] = start_y_k3;
        int l5;
        for(int j5 = l5 = anIntArrayArray901[starturkish idiot_j3][start_y_k3]; starturkish idiot_j3 != starturkish idiot || start_y_k3 != start_y; j5 = anIntArrayArray901[starturkish idiot_j3][start_y_k3])
        {
            if(j5 != l5)
            {
                l5 = j5;
                bigX[i4] = starturkish idiot_j3;
                bigY[i4++] = start_y_k3;
            }
            if((j5 &amp; 2) != 0)
                starturkish idiot_j3++;
            else
            if((j5 &amp; 8) != 0)
                starturkish idiot_j3--;
            if((j5 &amp; 1) != 0)
                start_y_k3++;
            else
            if((j5 &amp; 4) != 0)
                start_y_k3--;
        }
//	if(cancelWalk) { return i4 &gt; 0; }
	

        if(i4 &gt; 0)
        {
            int k4 = i4;
            if(k4 &gt; 25)
                k4 = 25;
            i4--;
            int k6 = bigX[i4];
            int i7 = bigY[i4];
            anInt1288 += k4;
            if(anInt1288 &gt;= 92)
            {
                stream.createFrame(36);
                stream.writeDWord(0);
                anInt1288 = 0;
            }
            if(minimap == 0)
            {
                stream.createFrame(164);
                stream.writeWordBigEndian(k4 + k4 + 3);
            }
            if(minimap == 1)
            {
                stream.createFrame(248);
                stream.writeWordBigEndian(k4 + k4 + 3 + 14);
            }
            if(minimap == 2)
            {
                stream.createFrame(98);
                stream.writeWordBigEndian(k4 + k4 + 3);
            }
            stream.method433(k6 + baseX);
            destX = bigX[0];
            destY = bigY[0];
            for(int j7 = 1; j7 &lt; k4; j7++)
            {
                i4--;
                stream.writeWordBigEndian(bigX[i4] - k6);
                stream.writeWordBigEndian(bigY[i4] - i7);
            }

            stream.method431(i7 + baseY);
            stream.method424(super.keyArray[5] != 1 ? 0 : 1);
            return true;
        }
        return minimap != 1;
    }
</code></pre>
<p>yeah? the client does an A* search on the region where each tile has a true/false value of 0xffffff / 0x1000000. you could just dump the 2D array of tiles into some sort of region-database-esque structure and perform the same algorithm. the aforementioned seems like a lot better solution than relying on the client to do the work.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/4</link>
        <pubDate>Wed, 11 Apr 2012 19:20:40 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-4</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@Lin Lin]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lin">@Lin</a> wrote:</p>
          <blockquote>
              <p>Yep. I understood it 100% before even starting it. However, walking is done completely from the client in nearly every server nowadays and this is no different. Therefore, I decided if I’m going to use client-sided walking I’d use its pathfinding too.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/3</link>
        <pubDate>Wed, 11 Apr 2012 17:54:44 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-3</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@moparisthebest Moparisthebest]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/moparisthebest">@moparisthebest</a> wrote:</p>
          <blockquote>
              <p>I didn’t read through all the code and such, but you realize this is a REALLY bad idea and that is why Jagex moved away from it?  When you are writing ANY client-server code, you can NEVER trust anything the client sends you on the server.  This would be doubly so for private server clients, since the source is out there for anyone to download, and anyone can say to the server “I’m going to walk through that wall over there”.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/2</link>
        <pubDate>Wed, 11 Apr 2012 17:36:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-2</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
      <item>
        <title>Client-sided Pathfinding</title>
        <dc:creator><![CDATA[@Lin Lin]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/lin">@Lin</a> wrote:</p>
          <blockquote>
              <p>Before I start, the server-sided stuff is going to require a lot of work on your part. It’s C# code and written specifically for my and my friend’s server.</p>
<p>This is something I implemented into my server after not wanting to calculate my own paths since it involved cache work and possibly impacted performance. So, I experimented a little and came up with this. I wrote it mainly for combat purposes, so I’m not sure if it’ll keep up with things like right-click following well.</p>
<p>Anyway, this is mainly a client edit, but also involves some server work. I’m using a non-renamed client for this, but it’s easy to convert since I used a renamed one to figure everything out.</p>
<p><span class="bbcode-b">Client-sided</span><br>
First, in Class31, change packet 2’s size to 3. It’s called anIntArray553 and you’re looking for the 3rd number. Next, in the Client class, under the packet parsing method method145 after it’s acquired the packet size and is ready to start parsing packets, add this code:</p>
<p>[code]			//Begin custom packets<br>
if(anInt1008 == 2) //Force walk<br>
{<br>
int pathType = aClass30_Sub2_Sub2_1083.method408();<br>
int entityID = aClass30_Sub2_Sub2_1083.method410();</p>
<pre><code>			if(pathType == 0) //Move to player
			{
				Class30_Sub2_Sub4_Sub1_Sub2 class30_sub2_sub4_sub1_sub2_2 = aClass30_Sub2_Sub4_Sub1_Sub2Array890[entityID];
				if(class30_sub2_sub4_sub1_sub2_2 != null)
				{
					method85(2, 0, 1, -11308, 0, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1501[0], 1, 0, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub2_2)).anIntArray1501[0], ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1500[0], false, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub2_2)).anIntArray1500[0]);
				}
			}
			else if(pathType == 1) //Move to NPC
			{
				Class30_Sub2_Sub4_Sub1_Sub1 class30_sub2_sub4_sub1_sub1_6 = aClass30_Sub2_Sub4_Sub1_Sub1Array835[entityID];
				if(class30_sub2_sub4_sub1_sub1_6 != null)
				{
					method85(2, 0, 1, -11308, 0, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1501[0], 1, 0, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1501[0], ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1500[0], false, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1500[0]);
				}
			}
			else if(pathType == 2) //Request path for NPC
			{
				Class30_Sub2_Sub4_Sub1_Sub1 class30_sub2_sub4_sub1_sub1_6 = aClass30_Sub2_Sub4_Sub1_Sub1Array835[entityID];
				if(class30_sub2_sub4_sub1_sub1_6 != null)
				{
					customWalkPacket(0, 1, -11308, 0, ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1501[0], 1, 0, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1501[0], ((Class30_Sub2_Sub4_Sub1) (class30_sub2_sub4_sub1_sub1_6)).anIntArray1500[0], false, ((Class30_Sub2_Sub4_Sub1) (aClass30_Sub2_Sub4_Sub1_Sub2_1126)).anIntArray1500[0], entityID);
				}
			}
			
			anInt1008 = -1;
			return true;
		}
		//End custom packets[/code]
</code></pre>
<p>I’ll explain it in a bit. Next, add this method anywhere in the Client class:</p>
<p>[code]	public final boolean customWalkPacket(int j, int k, int l, int i1, int j1, int k1,<br>
int l1, int i2, int j2, boolean flag, int k2, int entityID)<br>
{<br>
byte byte0 = 104;<br>
byte byte1 = 104;<br>
for(int l2 = 0; l2 &lt; byte0; l2++)<br>
{<br>
for(int i3 = 0; i3 &lt; byte1; i3++)<br>
{<br>
anIntArrayArray901[l2][i3] = 0;<br>
anIntArrayArray825[l2][i3] = 0x5f5e0ff;<br>
}</p>
<pre><code>    }

    int j3 = j2;
    int k3 = j1;
    anIntArrayArray901[j2][j1] = 99;
    anIntArrayArray825[j2][j1] = 0;
    int l3 = 0;
    int i4 = 0;
    anIntArray1280[l3] = j2;
    anIntArray1281[l3++] = j1;
    boolean flag1 = false;
    int j4 = anIntArray1280.length;
    int ai[][] = aClass11Array1230[anInt918].anIntArrayArray294;
    while(i4 != l3) 
    {
        j3 = anIntArray1280[i4];
        k3 = anIntArray1281[i4];
        i4 = (i4 + 1) % j4;
        if(j3 == k2 &amp;&amp; k3 == i2)
        {
            flag1 = true;
            break;
        }
        if(i1 != 0)
        {
            if((i1 &lt; 5 || i1 == 10) &amp;&amp; aClass11Array1230[anInt918].method219(k2, j3, k3, 0, j, i1 - 1, i2))
            {
                flag1 = true;
                break;
            }
            if(i1 &lt; 10 &amp;&amp; aClass11Array1230[anInt918].method220(k2, i2, k3, i1 - 1, j, j3, 0))
            {
                flag1 = true;
                break;
            }
        }
        if(k1 != 0 &amp;&amp; k != 0 &amp;&amp; aClass11Array1230[anInt918].method221((byte)1, i2, k2, j3, k, l1, k1, k3))
        {
            flag1 = true;
            break;
        }
        int l4 = anIntArrayArray825[j3][k3] + 1;
        if(j3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 - 1][k3] == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0)
        {
            anIntArray1280[l3] = j3 - 1;
            anIntArray1281[l3] = k3;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 - 1][k3] = 2;
            anIntArrayArray825[j3 - 1][k3] = l4;
        }
        if(j3 &lt; byte0 - 1 &amp;&amp; anIntArrayArray901[j3 + 1][k3] == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0)
        {
            anIntArray1280[l3] = j3 + 1;
            anIntArray1281[l3] = k3;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 + 1][k3] = 8;
            anIntArrayArray825[j3 + 1][k3] = l4;
        }
        if(k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3][k3 - 1] == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0)
        {
            anIntArray1280[l3] = j3;
            anIntArray1281[l3] = k3 - 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3][k3 - 1] = 1;
            anIntArrayArray825[j3][k3 - 1] = l4;
        }
        if(k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3][k3 + 1] == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
        {
            anIntArray1280[l3] = j3;
            anIntArray1281[l3] = k3 + 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3][k3 + 1] = 4;
            anIntArrayArray825[j3][k3 + 1] = l4;
        }
        if(j3 &gt; 0 &amp;&amp; k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 - 1][k3 - 1] == 0 &amp;&amp; (ai[j3 - 1][k3 - 1] &amp; 0x128010e) == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0)
        {
            anIntArray1280[l3] = j3 - 1;
            anIntArray1281[l3] = k3 - 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 - 1][k3 - 1] = 3;
            anIntArrayArray825[j3 - 1][k3 - 1] = l4;
        }
        if(j3 &lt; byte0 - 1 &amp;&amp; k3 &gt; 0 &amp;&amp; anIntArrayArray901[j3 + 1][k3 - 1] == 0 &amp;&amp; (ai[j3 + 1][k3 - 1] &amp; 0x1280183) == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[j3][k3 - 1] &amp; 0x1280102) == 0)
        {
            anIntArray1280[l3] = j3 + 1;
            anIntArray1281[l3] = k3 - 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 + 1][k3 - 1] = 9;
            anIntArrayArray825[j3 + 1][k3 - 1] = l4;
        }
        if(j3 &gt; 0 &amp;&amp; k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3 - 1][k3 + 1] == 0 &amp;&amp; (ai[j3 - 1][k3 + 1] &amp; 0x1280138) == 0 &amp;&amp; (ai[j3 - 1][k3] &amp; 0x1280108) == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
        {
            anIntArray1280[l3] = j3 - 1;
            anIntArray1281[l3] = k3 + 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 - 1][k3 + 1] = 6;
            anIntArrayArray825[j3 - 1][k3 + 1] = l4;
        }
        if(j3 &lt; byte0 - 1 &amp;&amp; k3 &lt; byte1 - 1 &amp;&amp; anIntArrayArray901[j3 + 1][k3 + 1] == 0 &amp;&amp; (ai[j3 + 1][k3 + 1] &amp; 0x12801e0) == 0 &amp;&amp; (ai[j3 + 1][k3] &amp; 0x1280180) == 0 &amp;&amp; (ai[j3][k3 + 1] &amp; 0x1280120) == 0)
        {
            anIntArray1280[l3] = j3 + 1;
            anIntArray1281[l3] = k3 + 1;
            l3 = (l3 + 1) % j4;
            anIntArrayArray901[j3 + 1][k3 + 1] = 12;
            anIntArrayArray825[j3 + 1][k3 + 1] = l4;
        }
    }
    anInt1264 = 0;
    if(!flag1)
    {
        if(flag)
        {
            int i5 = 100;
            for(int k5 = 1; k5 &lt; 2; k5++)
            {
                for(int i6 = k2 - k5; i6 &lt;= k2 + k5; i6++)
                {
                    for(int l6 = i2 - k5; l6 &lt;= i2 + k5; l6++)
                        if(i6 &gt;= 0 &amp;&amp; l6 &gt;= 0 &amp;&amp; i6 &lt; 104 &amp;&amp; l6 &lt; 104 &amp;&amp; anIntArrayArray825[i6][l6] &lt; i5)
                        {
                            i5 = anIntArrayArray825[i6][l6];
                            j3 = i6;
                            k3 = l6;
                            anInt1264 = 1;
                            flag1 = true;
                        }

                }

                if(flag1)
                    break;
            }

        }
        if(!flag1)
            return false;
    }
    i4 = 0;
    anIntArray1280[i4] = j3;
    anIntArray1281[i4++] = k3;
    if(l != -11308)
    {
        for(int j6 = 1; j6 &gt; 0; j6++);
    }
    int l5;
    for(int j5 = l5 = anIntArrayArray901[j3][k3]; j3 != j2 || k3 != j1; j5 = anIntArrayArray901[j3][k3])
    {
        if(j5 != l5)
        {
            l5 = j5;
            anIntArray1280[i4] = j3;
            anIntArray1281[i4++] = k3;
        }
        if((j5 &amp; 2) != 0)
            j3++;
        else
        if((j5 &amp; 8) != 0)
            j3--;
        if((j5 &amp; 1) != 0)
            k3++;
        else
        if((j5 &amp; 4) != 0)
            k3--;
    }

    if(i4 &gt; 0)
    {
        int k4 = i4;
        if(k4 &gt; 25)
            k4 = 25;
        i4--;
        int k6 = anIntArray1280[i4];
        int i7 = anIntArray1281[i4];
        anInt1288 += k4;
        if(anInt1288 &gt;= 92)
        {
            aClass30_Sub2_Sub2_1192.method397((byte)6, 36);
            aClass30_Sub2_Sub2_1192.method402(0);
            anInt1288 = 0;
        }
		
        aClass30_Sub2_Sub2_1192.method397((byte)6, 2);
        aClass30_Sub2_Sub2_1192.method398(k4 + k4 + 5);
		
		aClass30_Sub2_Sub2_1192.method399(entityID);
		
        aClass30_Sub2_Sub2_1192.method433(0, k6 + anInt1034);
		//Disable marker
        //anInt1261 = anIntArray1280[0];
        //anInt1262 = anIntArray1281[0];
        for(int j7 = 1; j7 &lt; k4; j7++)
        {
            i4--;
            aClass30_Sub2_Sub2_1192.method398(anIntArray1280[i4] - k6);
            aClass30_Sub2_Sub2_1192.method398(anIntArray1281[i4] - i7);
        }

        aClass30_Sub2_Sub2_1192.method431(true, i7 + anInt1035);
        aClass30_Sub2_Sub2_1192.method424(super.anIntArray30[5] != 1 ? 0 : 1, 0);
        return true;
    }
    return true;
}[/code]
</code></pre>
<p>Alright, so the first part you added is the handling of the new packet, packet <span class="bbcode-b">2</span>. Its made up of 3 bytes - the path request type (one byte) and the entity ID to move to (two bytes). It’s pretty much a reverse of the “attack/trade/follow” menu actions. Type 0 is “Move to Player”, 1 is “Move to NPC”, and 2 is “Move NPC to Player”. Type 2 is what uses the second block of code you added, which just sends a modified version of the regular walk-to packet. Except, before the first step, is the NPC ID for the server to handle, and the path is reversed (in the calling anyway). Here’s an example of how you’d use each type</p>
<p><code>			if (command.StartsWith("movetoplayer"))
			{
				try
				{
					Player forcewalk = Main.Server.PlayerHandler.PlayerForName(parts[1].ToLower());
					if (forcewalk != null)
					{
						if (MathOperations.InUpdateRange(p.X, p.Y, forcewalk.X, forcewalk.Y))
							Engine.ForceWalk(forcewalk, 0, p.PlayerIndex);
						else
							Engine.SendMessage(p, forcewalk.UserName + " is out of the update range.");
					}
					else
						Engine.SendMessage(p, "Player " + parts[1] + " not found.");
				}
				catch (Exception)
				{
					Engine.SendMessage(p, "Bad command input.");
				}
				return;
			}
			if (command.StartsWith("movetonpc"))
			{
				try
				{
					NPC forcewalk = Main.Server.NPCHandler.NPCs[int.Parse(parts[1])];
					if (forcewalk != null)
					{
						if (MathOperations.InUpdateRange(p.X, p.Y, forcewalk.X, forcewalk.Y))
							Engine.ForceWalk(p, 1, forcewalk.NPCIndex);
						else
							Engine.SendMessage(p, forcewalk.NPCIndex + " is out of the update range.");
					}
					else
						Engine.SendMessage(p, "NPC " + parts[1] + " not found.");
				}
				catch (Exception)
				{
					Engine.SendMessage(p, "Bad command input.");
				}
				return;
			}
			if (command.StartsWith("movenpc"))
			{
				try
				{
					NPC forcewalk = Main.Server.NPCHandler.NPCs[int.Parse(parts[1])];
					if (forcewalk != null)
					{
						forcewalk.FaceEntity(p.PlayerIndex + 0x7FFF);
						p.FaceEntity(forcewalk.NPCIndex + 0x8000);
						Engine.ForceWalk(p, 2, forcewalk.NPCIndex);
					}
					else
						Engine.SendMessage(p, "NPC " + parts[1] + " not found.");
				}
				catch (Exception)
				{
					Engine.SendMessage(p, "Bad command input.");
				}
				return;
			}</code></p>
<p>Note that’s all server-sided code. Mine, in fact. Made just for testing. I’m sure you guys could modify it to fit your servers if you wished.</p>
<p><span class="bbcode-b">Server-sided</span><br>
This stuff is rather easy, although winterLove-based servers like DeltaScape, PI, etc… aren’t going to have fun with this one. First off, you’re going to want to find your packet size array and changed packet 2 (the 3rd number) to -1. This signifies the packet size will be included in the packet header. Anyway, upon handling it, you’re going to going to want to add this code (change it to fit your server, obviously). The code was mainly based on Hyperion’s code to handle walking, so if you’re using Hyperion you’re in luck.</p>
<p>[code]		public static void HandlePacket(Player p, int id, int size)<br>
{<br>
ushort entity = p.InStream.ReadWord();<br>
size -= 2;</p>
<pre><code>		if (Server.NPCHandler.NPCs[entity] != null)
		{
			NPC n = Server.NPCHandler.NPCs[entity];
			//if (n.Teleported)
			//	return;

			n.WalkingQueue.Reset();
			int steps = (size - 5) / 2;
			int[,] path = new int[steps, 2];
			int firstX, firstY;
			firstX = p.InStream.ReadSignedWordLittleEndianA();

			for (int i = 0; i &lt; steps; i++)
			{
				path[i, 0] = p.InStream.ReadSignedByte();
				path[i, 1] = p.InStream.ReadSignedByte();
			}
			firstY = p.InStream.ReadSignedWordLittleEndian();
			p.InStream.ReadByteC();
			//p.WalkingQueue.SetRunningQueue(runSteps);
			n.WalkingQueue.AddStep(firstX, firstY);

			for (int i = 0; i &lt; steps; i++)
			{
				path[i, 0] += firstX;
				path[i, 1] += firstY;
				n.WalkingQueue.AddStep(path[i, 0], path[i, 1]);
			}
			n.WalkingQueue.Finish();
		}
	}[/code]
</code></pre>
<p>Here’s some code to actually send the request packet.</p>
<p><code>		public static void ForceWalk(Player p, byte type, int id)
		{
			p.CreatePacket(2);
			p.OutStream.WriteByte(type);
			p.OutStream.WriteWord((ushort)id);
		}</code></p>
<p>So that’s all, unless I missed something. Here’s a video of it in action (notice the delay - you can probably tweak some server stuff to decrease this but this is how it turned out).</p>
<p>[youtube]<a href="http://www.youtube.com/watch?v=38P6p4kNJLM%5B/youtube%5D" rel="nofollow noopener">http://www.youtube.com/watch?v=38P6p4kNJLM[/youtube]</a></p>
<p>Enjoy.</p>
<p>~Lin</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/client-sided-pathfinding/439270/1</link>
        <pubDate>Wed, 11 Apr 2012 04:14:19 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-439270-1</guid>
        <source url="https://forum.moparisthebest.com/t/client-sided-pathfinding/439270.rss">Client-sided Pathfinding</source>
      </item>
  </channel>
</rss>
