<!DOCTYPE html>
<html lang="en-US">
  
<!-- Mirrored from forum.moparisthebest.com/t/a-new-scalable-region-system/543041 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 04 Aug 2019 02:23:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>A new scalable region system - Runescape - moparisthebest.com</title>
    <meta name="description" content="EDIT: Aaaaaaand scratch that, I&amp;#39;ve got some of the arithmetic wrong. Sorry to get your hopes up. If you see a way to fix the bug though then by all means. :stuck_out_tongue: 

Hi guys. It&amp;#39;s been a while since I&amp;#39;ve contri&amp;hellip;">
    <meta name="generator" content="Discourse 2.3.2 - https://github.com/discourse/discourse version c587df7e2a03c2962f4c8cefd6f03969bb87d525">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/1/1f0dc167bcf798bdbd70b03bf0fd1bc836e54e1a_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff_2_180x180.png">
<meta name="theme-color" content="#0088cc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="543041.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.moparisthebest.com","potentialAction":{"@type":"SearchAction","target":"https://forum.moparisthebest.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="moparisthebest.com Search">

      <link href="../../stylesheets/desktop_1_ec9f75e3d0b2a904642ce53663991837b70cda3334fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="../../stylesheets/desktop_theme_2_6707e7ee46ac9f2f0510c29ddd10e8f6ce21c1ae34fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;A new scalable region system&#39;" href="543041.rss" />
  <meta property="og:site_name" content="moparisthebest.com" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:url" content="https://forum.moparisthebest.com/t/a-new-scalable-region-system/543041" />
<meta name="twitter:url" content="https://forum.moparisthebest.com/t/a-new-scalable-region-system/543041" />
<meta property="og:title" content="A new scalable region system" />
<meta name="twitter:title" content="A new scalable region system" />
<meta property="og:description" content="EDIT: Aaaaaaand scratch that, Iâ€™ve got some of the arithmetic wrong. Sorry to get your hopes up. If you see a way to fix the bug though then by all means. ðŸ˜›  Hi guys. Itâ€™s been a while since Iâ€™ve contributed anything, so hereâ€™s a region manager that should scale quite well and is algorithmically simpler than previous implementations.  Note that this implementation is not thread-safe.  Currently untested. The idea behind this is sound though. It relies on range searches provided ..." />
<meta name="twitter:description" content="EDIT: Aaaaaaand scratch that, Iâ€™ve got some of the arithmetic wrong. Sorry to get your hopes up. If you see a way to fix the bug though then by all means. ðŸ˜›  Hi guys. Itâ€™s been a while since Iâ€™ve contributed anything, so hereâ€™s a region manager that should scale quite well and is algorithmically simpler than previous implementations.  Note that this implementation is not thread-safe.  Currently untested. The idea behind this is sound though. It relies on range searches provided ..." />
<meta property="article:published_time" content="2014-05-13T11:40:17+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html">
          <img src="../../uploads/default/original/2X/3/37bba8fb3bd06c372ab54fa72ec38bf9f8f40b37.gif" alt="moparisthebest.com" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1 class="crawler-topic-title">
  <a href="543041.html">A new scalable region system</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
        itemref="breadcrumb-1"
      >
      <a href="../../c/games.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>Games</span>
      </a>
    </div>
    <div id="breadcrumb-1" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/games/runescape.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>Runescape</span>
      </a>
    </div>
</div>





  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/lothy.html'><span itemprop='name'>lothy</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-05-13T11:40:17Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:07:54Z' class='post-time'>
              August 4, 2016,  1:07pm
            </time>
        <span itemprop='position'>#1</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p><span class="bbcode-b">EDIT: Aaaaaaand scratch that, Iâ€™ve got some of the arithmetic wrong. Sorry to get your hopes up. If you see a way to fix the bug though then by all means. <img src="../../images/emoji/twitter/stuck_out_tongueae52.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></span></p>
<p>Hi guys. Itâ€™s been a while since Iâ€™ve contributed anything, so hereâ€™s a region manager that should scale quite well and is algorithmically simpler than previous implementations.</p>
<p>Note that this implementation is not thread-safe.</p>
<p>Currently untested. The idea behind this is sound though. It relies on range searches provided by concrete implementations of NavigableMap.</p>
<p>For those who want to move away from having large numbers of tiles in memory, you could choose to have a tile check if itâ€™s empty on any given remove operation. If it is empty, have it remove itself using the RegionManager.</p>
<p>You could also implement things like sweeps. Add a lastUsed field to the ActiveTile, write a comparator that orders by this field (least recently used first). Add all tiles to a collection, sort the collection, loop through and remove tiles from the region. Break out of the loop when you hit the first tile that has been used more recently than the specified maximum unused period.</p>
<pre><code class="lang-auto">import java.util.LinkedList;
import java.util.List;
import java.util.NavigableMap;
import java.util.TreeMap;

/**
 * Region manager for obtaining tiles within view.
 * This class is NOT THREAD-SAFE.
 *
 * @author Lothy
 */
public final class RegionManager {

    private static final NavigableMap&lt;Integer, ActiveTile&gt; tileMap =
            new TreeMap&lt;Integer, ActiveTile&gt;();

    private static final NavigableMap&lt;Integer, GameObject&gt; objectMap =
            new TreeMap&lt;Integer, GameObject&gt;();

    private static int hash(int x, int y) {
        return x &lt;&lt; 16 | y;
    }

    private static ActiveTile tile(int x, int y) {
        int hash = hash(x, y);
        ActiveTile t = tileMap.get(hash);

        if (t == null) {
            t = new ActiveTile(x, y);
            tileMap.put(hash, t);
        }

        return t;
    }

    private static int getMinHash(int x, int y, int range) {
        int minX = x - range &lt; 0 ? 0 : x - range;
        int minY = y - range &lt; 0 ? 0 : y - range;
        return hash(minX, minY);
    }

    private static int getMaxHash(int x, int y, int range) {
        int maxX = x + range &gt;= Short.MAX_VALUE ? Short.MAX_VALUE - 1 : x + range;
        int maxY = y + range &gt;= Short.MAX_VALUE ? Short.MAX_VALUE - 1 : y + range;
        return hash(maxX, maxY);
    }

    /**
     * Returns a list of all tiles that fall within the specified range
     * of the specified cartesian point.
     *
     * @param x The cartesian x-ordinate
     * @param y The cartesian y-ordinate
     * @param range The range to search within
     * @return All tiles that fall within the range, inclusive
     */
    public static List&lt;ActiveTile&gt; getTilesInRange(int x, int y, int range) {
        if (x &lt; 0 || x &gt;= Short.MAX_VALUE) {
            throw new IllegalArgumentException(String.format("Invalid x: %d\n", x));
        }

        if (y &lt; 0 || y &gt;= Short.MAX_VALUE) {
            throw new IllegalArgumentException(String.format("Invalid y: %d\n", y));
        }

        if (range &lt; 0) {
            throw new IllegalArgumentException("negative range");
        }

        int minHash = getMinHash(x, y, range);
        int maxHash = getMaxHash(x, y, range);

        List&lt;ActiveTile&gt; results = new LinkedList&lt;ActiveTile&gt;();
        results.addAll(tileMap.subMap(minHash, true, maxHash, true).values());

        return results;
    }

    /**
     * Returns a list of all game objects that fall within the specified range
     * of the specified cartesian point.
     *
     * @param x The cartesian x-ordinate
     * @param y The cartesian y-ordinate
     * @param range The range to search within
     * @return All game objects that fall within the range, inclusive
     */
    public static List&lt;GameObject&gt; getGameObjectsInRange(int x, int y, int range) {
        if (x &lt; 0 || x &gt;= Short.MAX_VALUE) {
            throw new IllegalArgumentException(String.format("Invalid x: %d\n", x));
        }

        if (y &lt; 0 || y &gt;= Short.MAX_VALUE) {
            throw new IllegalArgumentException(String.format("Invalid y: %d\n", y));
        }

        if (range &lt; 0) {
            throw new IllegalArgumentException("negative range");
        }

        int minHash = getMinHash(x, y, range);
        int maxHash = getMaxHash(x, y, range);

        List&lt;GameObject&gt; results = new LinkedList&lt;GameObject&gt;();
        results.addAll(objectMap.subMap(minHash, true, maxHash, true).values());


        return results;
    }


    public static void addPlayer(Player player) {
        if (player == null) {
            throw new NullPointerException("player");
        }


        ActiveTile t = tile(player.getX(), player.getY());
        t.addPlayer(player);
    }


    public static void addNpc(Npc npc) {
        if (npc == null) {
            throw new NullPointerException("npc");
        }


        ActiveTile t = tile(npc.getX(), npc.getY());
        t.addNpc(npc);
    }


    public static void addItem(Item item) {
        if (item == null) {
            throw new NullPointerException("item");
        }


        ActiveTile t = tile(item.getX(), item.getY());
        t.addItem(item);
    }


    public static void removePlayer(Player player) {
        if (player == null) {
            throw new NullPointerException("player");
        }


        ActiveTile t = tile(player.getX(), player.getY());
        t.removePlayer(player);
    }


    public static void removeNpc(Npc npc) {
        if (npc == null) {
            throw new NullPointerException("npc");
        }


        ActiveTile t = tile(npc.getX(), npc.getY());
        t.removeNpc(npc);
    }


    public static void removeItem(Item item) {
        if (item == null) {
            throw new NullPointerException("item");
        }


        ActiveTile t = tile(item.getX(), item.getY());
        t.removeItem(item);
    }


    public static void addEntity(Entity entity) {
        if (entity == null) {
            throw new NullPointerException("entity");
        }


        ActiveTile t = tile(entity.getX(), entity.getY());
        entity.addToTile(t);
    }


    public static void removeEntity(Entity entity) {
        if (entity == null) {
            throw new NullPointerException("entity");
        }


        ActiveTile t = tile(entity.getX(), entity.getY());
        entity.removeFromTile(t);
    }
}</code></pre>
<pre><code class="lang-auto">import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

/**
 * Bog standard ActiveTile.
 * This implementation is NOT THREAD-SAFE.
 *
 * @author Lothy
 */
public final class ActiveTile implements Comparable&lt;ActiveTile&gt; {

    private final int x;
    private final int y;
    private final int hash;

    private List&lt;Player&gt; players = null;
    private List&lt;Npc&gt; npcs = null;
    private List&lt;Item&gt; items = null;

    public ActiveTile(int x, int y) {
        if (x &lt; 0 || x &gt;= Short.MAX_VALUE) {
            throw new IllegalArgumentException(String.format("Invalid x: %d\n", x));
        }

        if (y &lt; 0 || y &gt;= Short.MAX_VALUE) {
            throw new IllegalArgumentException(String.format("Invalid y: %d\n", y));
        }

        this.x = x;
        this.y = y;
        this.hash = x &lt;&lt; 16 | y;
    }

    private List&lt;Player&gt; players() {
        if (players == null) {
            players = new LinkedList&lt;Player&gt;();
        }

        return players;
    }

    private List&lt;Npc&gt; npcs() {
        if (npcs == null) {
            npcs = new LinkedList&lt;Npc&gt;();
        }

        return npcs;
    }

    private List&lt;Item&gt; items() {
        if (items == null) {
            items = new LinkedList&lt;Item&gt;();
        }

        return items;
    }

    public List&lt;Player&gt; getPlayers() {
        return players != null ? players : Collections.&lt;Player&gt;emptyList();
    }

    public List&lt;Npc&gt; getNpcs() {
        return npcs != null ? npcs : Collections.&lt;Npc&gt;emptyList();
    }

    public List&lt;Item&gt; getItems() {
        return items != null ? items : Collections.&lt;Item&gt;emptyList();
    }

    public boolean hasPlayers() {
        return players != null &amp;&amp; players.size() &gt; 0;
    }

    public boolean hasNpcs() {
        return npcs != null &amp;&amp; npcs.size() &gt; 0;
    }

    public boolean hasItems() {
        return items != null &amp;&amp; items.size() &gt; 0;
    }

    public void addPlayer(Player player) {
        if (player == null) {
            throw new NullPointerException("player");
        }

        List&lt;Player&gt; players = players();
        players.add(player);
    }

    public void addNpc(Npc npc) {
        if (npc == null) {
            throw new NullPointerException("npc");
        }

        List&lt;Npc&gt; npcs = npcs();
        npcs.add(npc);
    }

    public void addItem(Item item) {
        if (item == null) {
            throw new NullPointerException("item");
        }

        List&lt;Item&gt; items = items();
        items.add(item);
    }

    public void addEntity(Entity entity) {
        if (entity == null) {
            throw new NullPointerException("entity");
        }

        entity.addToTile(this);
    }

    public void removePlayer(Player player) {
        if (player == null) {
            throw new NullPointerException("player");
        }

        List&lt;Player&gt; players = players();
        players.remove(player);
    }

    public void removeNpc(Npc npc) {
        if (npc == null) {
            throw new NullPointerException("npc");
        }

        List&lt;Npc&gt; npcs = npcs();
        npcs.remove(npc);
    }

    public void removeItem(Item item) {
        if (item == null) {
            throw new NullPointerException("item");
        }

        List&lt;Item&gt; items = items();
        items.remove(item);
    }

    public void removeEntity(Entity entity) {
        if (entity == null) {
            throw new NullPointerException("entity");
        }

        entity.removeFromTile(this);
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    public int hashCode() {
        return hash;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }

        if (o == this) {
            return true;
        }

        if (!(o instanceof ActiveTile)) {
            return false;
        }

        ActiveTile other = (ActiveTile) o;
        return hash == other.hash;
    }

    @Override
    public int compareTo(ActiveTile other) {
        return compare(this, other);
    }

    public static int compare(ActiveTile x, ActiveTile y) {
        return (x.hash &lt; y.hash) ? -1 : ((x.hash == y.hash) ? 0 : 1);
    }
}</code></pre>
<p>Functions that need to go in concrete implementations of the Entity class.</p>
<pre><code class="lang-auto">    public void addToTile(ActiveTile tile) {
        throw new UnsupportedOperationException();
        // Sample implementations for subclasses:
        // Npc: tile.addNpc(this);
        // Player: tile.addPlayer(this);
        // etc
    }

    public void removeFromTile(ActiveTile tile) {
        throw new UnsupportedOperationException();
        // Sample implementations for subclasses:
        // Npc: tile.removeNpc(this);
        // Player: tile.removePlayer(this);
        // etc
    }</code></pre>
      </div>

      <meta itemprop='headline' content='A new scalable region system'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/CodeForFame.html'><span itemprop='name'>CodeForFame</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-05-13T12:08:15Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:07:54Z' class='post-time'>
              August 4, 2016,  1:07pm
            </time>
        <span itemprop='position'>#2</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Bare minimum, you need to have TileValues in memory, for path finding. Though, I guess you could remove all tiles that donâ€™t cause blocking.</p>
<p>Also, just putting ActiveTiles in a normal collection that has them removed when there is nothing in them would save a lot of memory.</p>
      </div>

      <meta itemprop='headline' content='A new scalable region system'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/Nothing1.html'><span itemprop='name'>Nothing1</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-05-13T23:14:16Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:08:00Z' class='post-time'>
              August 4, 2016,  1:08pm
            </time>
        <span itemprop='position'>#3</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>ActiveTiles are useless. Why are you still using them? You could just make a list of every entity in that specific region and it would save more memory and wouldnâ€™t be so error prone. Tile values have to be saved for path finding like CodeForFame said, but ActiveTiles serve no purpose if you are splitting world down into sectors.</p>
      </div>

      <meta itemprop='headline' content='A new scalable region system'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/lothy.html'><span itemprop='name'>lothy</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2014-05-14T08:08:21Z'>
            <time itemprop='dateModified' datetime='2016-08-04T13:08:13Z' class='post-time'>
              August 4, 2016,  1:08pm
            </time>
        <span itemprop='position'>#4</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>You need a container object of some sort (i.e., ActiveTile is the popular name in RSC servers) because any given cartesian point can hold zero to many NPCs/players/items.<br>
As you can see in the example, game objects donâ€™t need to be contained within an ActiveTile. This is because precisely zero or one objects are situated on any given cartesian point, and the mapping can be direct as a result.</p>
<p>The error-proneness is mostly an issue with object life-cycle. Specifically, people are storing references to things in too many locations and consequently the garbage cleaner isnâ€™t getting itâ€™s moment to shine.</p>
<p>If you read the code youâ€™ll see that there are no sectors/regions/etc. This implementation relies on the properties of tree data structures to efficiently obtain the relevant tiles.</p>
<p><span class="bbcode-b">EDIT: By the way guys, this doesnâ€™t work.</span><br>
I was under the impression yesterday that I could fix it by mapping a cartesian point (instead of just a hash) to the tile. And then I figured my implementation of compareTo was poor, and responsible for the algorithm failing.<br>
Anyway, I canâ€™t think of a way to make this work using the above solution while still performing well.</p>
<p>Perhaps a grid solution is the best approach. I might try my hand at implementing a quadtree solution over the weekend though, if I have time. Apparently grid solutions are better when entities are dispersed in a uniform manner, but quadtrees are better when that dispersal is less uniform (i.e., players and npcs more often than not form clusters).</p>
<p>So yeah, ignore this and chalk it up to a naive attempt.</p>
      </div>

      <meta itemprop='headline' content='A new scalable region system'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav' itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <ul>
        <li itemprop="name"><a href='../../index.html' itemprop="url">Home </a></li>
        <li itemprop="name"><a href='../../categories.html' itemprop="url">Categories </a></li>
        <li itemprop="name"><a href='../../guidelines.html' itemprop="url">FAQ/Guidelines </a></li>
        <li itemprop="name"><a href='../../tos.html' itemprop="url">Terms of Service </a></li>
        <li itemprop="name"><a href='../../privacy.html' itemprop="url">Privacy Policy </a></li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
  </body>
  

<!-- Mirrored from forum.moparisthebest.com/t/a-new-scalable-region-system/543041 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 04 Aug 2019 02:23:05 GMT -->
</html>
