<!DOCTYPE html>
<html lang="en-US">
  
<!-- Mirrored from forum.moparisthebest.com/t/c-2d-isometric-2-1-a-pathfinding-problem/478245 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:11:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>[C#] 2D Isometric (2:1) A* pathfinding problem - General Programming - moparisthebest.com</title>
    <meta name="description" content="Hello everyone 

I&amp;#39;m currently working on a 2D Isometric game in C# and I&amp;#39;m trying to implement A* pathfinding to make the character move to his destination point without hitting any obstacle, this is working except for &amp;hellip;">
    <meta name="generator" content="Discourse 2.3.2 - https://github.com/discourse/discourse version c587df7e2a03c2962f4c8cefd6f03969bb87d525">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/1/1f0dc167bcf798bdbd70b03bf0fd1bc836e54e1a_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff_2_180x180.png">
<meta name="theme-color" content="#0088cc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="478245.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.moparisthebest.com","potentialAction":{"@type":"SearchAction","target":"https://forum.moparisthebest.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="moparisthebest.com Search">

      <link href="../../stylesheets/desktop_1_ec9f75e3d0b2a904642ce53663991837b70cda3334fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="../../stylesheets/desktop_theme_2_6707e7ee46ac9f2f0510c29ddd10e8f6ce21c1ae34fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;[C#] 2D Isometric (2:1) A* pathfinding problem&#39;" href="478245.rss" />
  <meta property="og:site_name" content="moparisthebest.com" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="http://i.imgur.com/xpr2N.png" />
<meta property="og:image" content="http://i.imgur.com/xpr2N.png" />
<meta property="og:url" content="https://forum.moparisthebest.com/t/c-2d-isometric-2-1-a-pathfinding-problem/478245" />
<meta name="twitter:url" content="https://forum.moparisthebest.com/t/c-2d-isometric-2-1-a-pathfinding-problem/478245" />
<meta property="og:title" content="[C#] 2D Isometric (2:1) A* pathfinding problem" />
<meta name="twitter:title" content="[C#] 2D Isometric (2:1) A* pathfinding problem" />
<meta property="og:description" content="Hello everyone  I’m currently working on a 2D Isometric game in C# and I’m trying to implement A* pathfinding to make the character move to his destination point without hitting any obstacle, this is working except for the part where he just goes in an infinit loop when there is obstacle between him like this:    Here is a basic example how the world gets rendered  for (int y = 0; y &lt; worldHeight; y++) {     for (int x = 0; x &lt; worldWidth; x++)     {         world[x, y].Render(g);     } } The Re..." />
<meta name="twitter:description" content="Hello everyone  I’m currently working on a 2D Isometric game in C# and I’m trying to implement A* pathfinding to make the character move to his destination point without hitting any obstacle, this is working except for the part where he just goes in an infinit loop when there is obstacle between him like this:    Here is a basic example how the world gets rendered  for (int y = 0; y &lt; worldHeight; y++) {     for (int x = 0; x &lt; worldWidth; x++)     {         world[x, y].Render(g);     } } The Re..." />
<meta property="article:published_time" content="2013-01-12T13:01:58+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html">
          <img src="../../uploads/default/original/2X/3/37bba8fb3bd06c372ab54fa72ec38bf9f8f40b37.gif" alt="moparisthebest.com" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1 class="crawler-topic-title">
  <a href="478245.html">[C#] 2D Isometric (2:1) A* pathfinding problem</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/general-programming.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>General Programming</span>
      </a>
    </div>
</div>





  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/DefLegende.html'><span itemprop='name'>DefLegende</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2013-01-12T13:01:58Z'>
            <time itemprop='dateModified' datetime='2016-08-04T02:08:39Z' class='post-time'>
              August 4, 2016,  2:08am
            </time>
        <span itemprop='position'>#1</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Hello everyone</p>
<p>I’m currently working on a 2D Isometric game in C# and I’m trying to implement A* pathfinding to make the character move to his destination point without hitting any obstacle, this is working except for the part where he just goes in an infinit loop when there is obstacle between him like this:<br>
<div class="lightbox-wrapper"><a class="lightbox" href="http://i.imgur.com/xpr2N.png" title="xpr2N.png" rel="nofollow noopener"><img src="http://i.imgur.com/xpr2N.png" alt width="690" height="430"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">xpr2N.png</span><span class="informations">993×619</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>Here is a basic example how the world gets rendered</p>
<pre><code class="lang-auto">for (int y = 0; y &lt; worldHeight; y++)
{
    for (int x = 0; x &lt; worldWidth; x++)
    {
        world[x, y].Render(g);
    }
}</code></pre>
<p>The Render(g); Method</p>
<pre><code class="lang-auto">public void Render(Graphics g)
{
    Int32 yOffset = 0;
    Int32 xOffset = 0;
    Int32 tileX = 0;
    Int32 tileY = 0;

    if (Image.Height &gt; 32)
        yOffset = Image.Height - 32;

    if ((Y % 2) != 0)
        xOffset = 32;

    tileX = (X + (64 * X) + xOffset);
    tileY = (Y + (15 * Y) - yOffset);

    g.DrawImageUnscaled(Image, tileX, tileY);
}</code></pre>
<p>Now the pathfinding</p>
<pre><code class="lang-auto">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace IsoTest
{
    public class PathFinding
    {
        private bool _calculated = false;
        private TileInfo[,] world;

        private Node startNode;
        private Node lastNode;

        Int32 width;
        Int32 height;

        public PathFinding(TileInfo[,] worldInstance)
        {
            world = worldInstance;
            width = world.GetLength(0);
            height = world.Length / width;
        }

        public void Reset(TileInfo[,] worldInstance)
        {
            _calculated = false;
            OpenList = new List&lt;Node&gt;();
            ClosedList = new List&lt;Node&gt;();
            world = worldInstance;
            width = world.GetLength(0);
            height = world.Length / width;
        }

        public Node[] GetSurroundingNodes(Node parent)
        {
            Int32 xx = parent.Location.X; // unchangable
            Int32 yy = parent.Location.Y; // unchangable
            List&lt;Node&gt; surroundedNodes = new List&lt;Node&gt;();
            Boolean allow = false;
			
            if ((yy % 2) != 0)
                allow = true;

            for (Int32 x = xx - 1; x &lt; xx + 2; x++)
            {
                Int32 y = 0;

                if (x == (xx - 1))
                {
                    for (y = yy - 1; y &lt; yy + 2; y++)
                    {
                        Add(x, y, allow, surroundedNodes, xx, yy);
                    }
                }
                else if (x == (xx))
                {
                    for (y = yy - 2; y &lt; yy + 3; y++)
                    {
                        Add(x, y, allow, surroundedNodes, xx, yy);
                    }
                }
                else if (x == (xx + 1))
                {
                    y = yy;
                    Add(x, y, allow, surroundedNodes, xx, yy);
                }
            }

            return surroundedNodes.ToArray();
        }

        private void Add(Int32 x, Int32 y, bool allow, List&lt;Node&gt; lst, Int32 xx, Int32 yy)
        {
            if (allow)
                if ((y % 2) == 0)
                    x +=1;

            if (x &gt; -1 &amp;&amp; x &lt; width &amp;&amp; y &gt; -1 &amp;&amp; y &lt; height)
            {
                Node n = world[x, y].ToNode();
                if (n.Walkable)
                {
                    world[x, y].Image = new Bitmap(64, 32);
                    lst.Add(n);
                }
            }
        }

        public void Calculate(Point startingPt, Point endPt)
        {
            Node currentNode = world[startingPt.X, startingPt.Y].ToNode();
            Node endNode = world[endPt.X, endPt.Y].ToNode();
            Node[] surroundedNodes;

            startNode = currentNode;

            Node parentBackup = currentNode;

            while (!_calculated)
            {
                surroundedNodes = GetSurroundingNodes(currentNode);
                parentBackup = currentNode;

                foreach (Node n in surroundedNodes)
                {
                    Point distanceDifference = new Point(
                        Math.Abs((n.Location.X - endNode.Location.X)), Math.Abs((n.Location.Y - endNode.Location.Y)));

                    if ((distanceDifference.X != 0) &amp;&amp; (distanceDifference.Y != 0))
                        n.MovingCost = 14;
                    else
                        n.MovingCost = 10;

                    n.HeuristicDistance = (distanceDifference.Y + distanceDifference.X) * 10;

                    n.Used = true;
                }

                Node lowestCostNode = null;
                Int32 lowestCost = Int32.MaxValue;
                foreach (Node n in surroundedNodes)
                {
                    Int32 currentCost = (n.MovingCost + n.HeuristicDistance);
                    if (currentCost &lt; lowestCost)
                    {
                        lowestCost = currentCost;
                        lowestCostNode = n;
                    }
                }

                currentNode = lowestCostNode;
                lastNode = currentNode;

                currentNode.Parent = parentBackup;

                if (Node.Equals(currentNode, endNode))
                    _calculated = true;


            }
        }

        public Point[] ToWayPoint()
        {
            List&lt;Point&gt; waypoints = new List&lt;Point&gt;();

            if (_calculated)
            {
                Node ln = lastNode;
                while (!Node.Equals(ln,startNode))
                {
                    waypoints.Add(ln.Location);
                    ln = ln.Parent;
                    
                }

                List&lt;Point&gt; orderedWayPoints = new List&lt;Point&gt;();
                for (Int32 i = waypoints.Count - 1; i &gt; -1; i--)
                {
                    orderedWayPoints.Add(waypoints[i]);
                }

                waypoints = orderedWayPoints;
            }

            return waypoints.ToArray();
        }
    }
}</code></pre>
<p>The player class:</p>
<pre><code class="lang-auto">public class Player
{
	public PathFinding path = null;
	public float x = 1;
	public float y = 1;
	private Int32 pathIndex = 0;
	private Point[] pathArray = new Point[] { new Point(0, 0) };
	Bitmap image = null;

	private Point PrevDestination = new Point(6, 5);
	public Point Destination = new Point(6, 5);

	public Player(float xx, float yy, Bitmap bmp, PathFinding pathInstance)
	{
		x = xx;
		y = yy;
		image = bmp;
		path = pathInstance;
	}
	
	public void Tick()
	{
		if (Destination != PrevDestination)
		{
			path.Calculate(new Point((Int32)this.x, (Int32)this.y), Destination);

			pathIndex = 0;
			pathArray = path.ToWayPoint();

			PrevDestination = Destination;
		}

		Point loc = pathArray[pathIndex];
		float moveX = 0;
		float moveY = 0;

		if (Destination.X &gt; x)
			moveX = 0.125f;
		else if (Destination.X &lt; x)
			moveX = -0.125f;

		if (Destination.Y &gt; y)
			moveY = 0.125f;
		else if (Destination.Y &lt; y)
			moveY = -0.125f;

		if (moveX == 0 &amp;&amp; moveY == 0 &amp;&amp; pathIndex &lt; pathArray.Length - 1)
			pathIndex++;

		x += moveX;
		y += moveY;
	}

	public void Render(Graphics g)
	{
		Int32 yOffset = 0;
		Int32 xOffset = 0;
		float tileX = 0;
		float tileY = 0;

		if (image.Height &gt; 32)
			yOffset = image.Height - 32;

		if ((y % 2) != 0)
			xOffset = 32;

		tileX = (x + (64 * x) + xOffset);
		tileY = (y + (15 * y) - yOffset);

		g.DrawImage(image, tileX, tileY, image.Width, image.Height);
	}
}
</code></pre>
<p><span class="bbcode-i">btw: If you have any remarks on my code, things that I could improve or should change don’t wait to tell them.</span></p>
<p>Thanks alot!</p>
      </div>

      <meta itemprop='headline' content='[C#] 2D Isometric (2:1) A* pathfinding problem'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>

          <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
          </div>

  </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav' itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <ul>
        <li itemprop="name"><a href='../../index.html' itemprop="url">Home </a></li>
        <li itemprop="name"><a href='../../categories.html' itemprop="url">Categories </a></li>
        <li itemprop="name"><a href='../../guidelines.html' itemprop="url">FAQ/Guidelines </a></li>
        <li itemprop="name"><a href='../../tos.html' itemprop="url">Terms of Service </a></li>
        <li itemprop="name"><a href='../../privacy.html' itemprop="url">Privacy Policy </a></li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
  </body>
  

<!-- Mirrored from forum.moparisthebest.com/t/c-2d-isometric-2-1-a-pathfinding-problem/478245 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 03 Aug 2019 20:11:27 GMT -->
</html>
