<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Edge Detection - First Order Linear Extraction</title>
    <link>https://forum.moparisthebest.com/t/edge-detection-first-order-linear-extraction/295885</link>
    <description>Hey, so I know of a few people doing a bit of image work atm (including myself), so I thought it&#39;d be cool to paste something image related. Anyway, the code by itself is pretty fucking pointless. However, it provides a good solid bases to start from and despite only being a few lines long, shows in principal, one method of &#39;detecting edges&#39;.

[code]public static int[] firstOrderLinearExtraction(int[] pixels, int width, int height) {
        int[] extractedPixelBuffer = new int[pixels.length];
        for(int x = 0; x &lt; width-2; x++) {
            for(int y = 0; y &lt; height-2; y++) {
                extractedPixelBuffer[y*width+x] = 2*pixels[y*width+x]
                                                              - pixels[y*width+x+1]
                                                              - pixels[(y+1)*width+x];
            }
        }
        return extractedPixelBuffer;
    }[/code]
The above requires an input of an image&#39;s pixels. It also requires the width and height of the rectangle of the area you would like to manipulate. (The offset is 0, you could add in your own parameters and modify the code to allow an offset too, that way you could place the rectangle anywhere). It then returns the modified pixel array.

The above is a Linear type of extraction, that averages the extracted pixel with it&#39;s neighbors. Again, this is a pointless method on it&#39;s own, but it might be useful for something else.

For anyone that wants to understand why this works and how it is derived, the following may be appropriate:
Exx,y = |Px,y – Px+1,y| ∀x ∈ 1, N – 1; y ∈ 1, N - To find a vertical edge, we difference to horizontally adjacent points, the change in intensity should then give us the edge. The same applies for the opposite way round: Eyx,y = |Px,y – Px,y+1| ∀x ∈ 1, N; y ∈ 1, N – 1 only this detects horizontal edges by differencing 2 vertically adjacent points.
The formula in my code detects both horizontal and vertical edges in one sweep. This is done by convolving the two functions. Of which gives: Ex,y = |Px,y – Px+1,y + Px,y – Px,y+1| ∀x, y ∈ 1, N – 1 and I think you&#39;ll agree that it simplifies to: Ex,y = |2 × Px,y – Px+1,y – Px,y+1| ∀x, y ∈ 1, N – 1.

This is very basic and the code is very basic. But this type of linear differencing is the bases of alot more complex differencing/extraction. Anyway, no doubt this thread will die, but I hadn&#39;t posted anything in a while..

Credits to &#39;Feature Extraction in Computer Vision and Image Processing - Mark S. Nixon&#39;.

Heres a horribly ugly demo to testcase this with:
[code]import javax.swing.*;
import java.awt.image.PixelGrabber;
import java.awt.image.MemoryImageSource;
import java.awt.*;

public class Application {
    public static void main(String[] args) {
        if(args.length != 1) {
            System.out.println(&quot;Usage: Application &lt;image_name&gt;&quot;);
            System.exit(0);
        }

        ImageIcon ic = new ImageIcon(args[0]);
        PixelGrabber pg = new PixelGrabber(ic.getImage(), 0, 0, ic.getIconWidth(), ic.getIconHeight(), true);

        try {
            pg.grabPixels();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int[] pixels = (int[]) pg.getPixels();
        int[] extractedPixelBuffer = firstOrderLinearExtraction(pixels, ic.getIconWidth(), ic.getIconHeight());


        JFrame frame = new JFrame(&quot;Image Test Work&quot;);
        Image extractedImage = frame.createImage(new MemoryImageSource(ic.getIconWidth(),
                                                                       ic.getIconHeight(),
                                                                       extractedPixelBuffer,
                                                                       0, ic.getIconWidth()));

        ImageIcon extractedIc = new ImageIcon(extractedImage);
        JLabel jl = new JLabel(ic);
        JLabel extractedJl = new JLabel(extractedIc);
        JPanel jp = new JPanel();
        jp.add(jl); jp.add(extractedJl);
        frame.add(jp); frame.pack(); frame.show();
    }

    public static int[] firstOrderLinearExtraction(int[] pixels, int width, int height) {
        int[] extractedPixelBuffer = new int[pixels.length];
        for(int x = 0; x &lt; width-2; x++) {
            for(int y = 0; y &lt; height-2; y++) {
                extractedPixelBuffer[y*width+x] = 2*pixels[y*width+x]
                                                              - pixels[y*width+x+1]
                                                              - pixels[(y+1)*width+x];
            }
        }
        return extractedPixelBuffer;
    }
}[/code]

If I don&#39;t get too badly flamed I might post up a similar thread on Guassion Smoothing and/or some more complex extraction techniques.

Edit: Apologies for some of the indenting being wierd.</description>
    
    <lastBuildDate>Tue, 18 Aug 2009 05:05:28 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/edge-detection-first-order-linear-extraction/295885.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Edge Detection - First Order Linear Extraction</title>
        <dc:creator><![CDATA[@ownagesbot ownagesbot]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/ownagesbot">@ownagesbot</a> wrote:</p>
          <blockquote>
              <p>Hey, so I know of a few people doing a bit of image work atm (including myself), so I thought it’d be cool to paste something image related. Anyway, the code by itself is pretty fucking pointless. However, it provides a good solid bases to start from and despite only being a few lines long, shows in principal, one method of ‘detecting edges’.</p>
<p><code>public static int[] firstOrderLinearExtraction(int[] pixels, int width, int height) {
        int[] extractedPixelBuffer = new int[pixels.length];
        for(int x = 0; x &lt; width-2; x++) {
            for(int y = 0; y &lt; height-2; y++) {
                extractedPixelBuffer[y*width+x] = 2*pixels[y*width+x]
                                                              - pixels[y*width+x+1]
                                                              - pixels[(y+1)*width+x];
            }
        }
        return extractedPixelBuffer;
    }</code><br>
The above requires an input of an image’s pixels. It also requires the width and height of the rectangle of the area you would like to manipulate. (The offset is 0, you could add in your own parameters and modify the code to allow an offset too, that way you could place the rectangle anywhere). It then returns the modified pixel array.</p>
<p>The above is a Linear type of extraction, that averages the extracted pixel with it’s neighbors. Again, this is a pointless method on it’s own, but it might be useful for something else.</p>
<p>For anyone that wants to understand why this works and how it is derived, the following may be appropriate:<br>
Exx,y = |Px,y – Px+1,y| ∀x ∈ 1, N – 1; y ∈ 1, N - To find a vertical edge, we difference to horizontally adjacent points, the change in intensity should then give us the edge. The same applies for the opposite way round: Eyx,y = |Px,y – Px,y+1| ∀x ∈ 1, N; y ∈ 1, N – 1 only this detects horizontal edges by differencing 2 vertically adjacent points.<br>
The formula in my code detects both horizontal and vertical edges in one sweep. This is done by convolving the two functions. Of which gives: Ex,y = |Px,y – Px+1,y + Px,y – Px,y+1| ∀x, y ∈ 1, N – 1 and I think you’ll agree that it simplifies to: Ex,y = |2 × Px,y – Px+1,y – Px,y+1| ∀x, y ∈ 1, N – 1.</p>
<p>This is very basic and the code is very basic. But this type of linear differencing is the bases of alot more complex differencing/extraction. Anyway, no doubt this thread will die, but I hadn’t posted anything in a while…</p>
<p>Credits to ‘Feature Extraction in Computer Vision and Image Processing - Mark S. Nixon’.</p>
<p>Heres a horribly ugly demo to testcase this with:</p>
<p>[code]import javax.swing.<em>;<br>
import java.awt.image.PixelGrabber;<br>
import java.awt.image.MemoryImageSource;<br>
import java.awt.</em>;</p>
<p>public class Application {<br>
public static void main(String[] args) {<br>
if(args.length != 1) {<br>
System.out.println(“Usage: Application &lt;image_name&gt;”);<br>
System.exit(0);<br>
}</p>
<pre><code>    ImageIcon ic = new ImageIcon(args[0]);
    PixelGrabber pg = new PixelGrabber(ic.getImage(), 0, 0, ic.getIconWidth(), ic.getIconHeight(), true);

    try {
        pg.grabPixels();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    int[] pixels = (int[]) pg.getPixels();
    int[] extractedPixelBuffer = firstOrderLinearExtraction(pixels, ic.getIconWidth(), ic.getIconHeight());


    JFrame frame = new JFrame("Image Test Work");
    Image extractedImage = frame.createImage(new MemoryImageSource(ic.getIconWidth(),
                                                                   ic.getIconHeight(),
                                                                   extractedPixelBuffer,
                                                                   0, ic.getIconWidth()));

    ImageIcon extractedIc = new ImageIcon(extractedImage);
    JLabel jl = new JLabel(ic);
    JLabel extractedJl = new JLabel(extractedIc);
    JPanel jp = new JPanel();
    jp.add(jl); jp.add(extractedJl);
    frame.add(jp); frame.pack(); frame.show();
}

public static int[] firstOrderLinearExtraction(int[] pixels, int width, int height) {
    int[] extractedPixelBuffer = new int[pixels.length];
    for(int x = 0; x &lt; width-2; x++) {
        for(int y = 0; y &lt; height-2; y++) {
            extractedPixelBuffer[y*width+x] = 2*pixels[y*width+x]
                                                          - pixels[y*width+x+1]
                                                          - pixels[(y+1)*width+x];
        }
    }
    return extractedPixelBuffer;
}
</code></pre>
<p>}[/code]</p>
<p>If I don’t get too badly flamed I might post up a similar thread on Guassion Smoothing and/or some more complex extraction techniques.</p>
<p>Edit: Apologies for some of the indenting being wierd.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/edge-detection-first-order-linear-extraction/295885/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/edge-detection-first-order-linear-extraction/295885/1</link>
        <pubDate>Tue, 18 Aug 2009 05:05:28 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-295885-1</guid>
        <source url="https://forum.moparisthebest.com/t/edge-detection-first-order-linear-extraction/295885.rss">Edge Detection - First Order Linear Extraction</source>
      </item>
  </channel>
</rss>
