<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Extending JavaScript using sweet.js</title>
    <link>https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977</link>
    <description>Frequent updates posted here: [url=http://anthony-calandra.com/posts/Implementing-ES6-Features-in-ES5-using-Macros-2]Implementing ES6 Features in ES5 using Macros[/url]. Due to the topic size restriction, only classes are covered in this topic.
[HR]
This post will cover how to implement the newest ECMAScript 6 syntactic and functionality changes in ECMAScript 5 using Mozilla&#39;s macro library, sweet.js.

Here is a current list of features:

[ul][li]Arrow functions (covered in blog)[/li]
[li]Classes[/li]
[li]Default parameters (covered in blog)[/li]
[li]Rest parameters (covered in blog)[/li][/ul]


[SIZE=4]Classes[/SIZE]

One of the most significant (and arguably controversial) changes to the language is the new class-based object oriented programming syntax. ECMAScript has exclusively followed a prototypal solution to object design, and as such, the new class-based syntax will require our macro to use those prototypal ideas to generate code that conforms to class-based syntax.

An example of a class in ES6 is as follows:

[CODE=&quot;text&quot;]
class Shape {
  constructor() {
    this.x = 0;
    this.y = 0;
  }

  move(x, y) {
    this.x += x;
    this.y += y;
  }

  static defaultShape() {
    return new Shape();
  }
}
[/code]
As you can see, a class is composed of a class name, a couple braces, and methods. The class name and braces are easy to include in the pattern for our `class` rule, but the form of methods are more complicated. To simplify the rule, let us define our own pattern classes for determining if a given token is a method:

[CODE=&quot;javascript&quot;]
macro is_method {
  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    };
  }

  rule { 
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    }
  }
}
[/code]

As you can tell by the ruleset, a method has a name, optional parameters delimited by commas, and a method body. Optionally, methods in a class can also end in a semicolon. Now that we have a pattern class for denoting methods, we can now begin our `class` macro:

[CODE=&quot;javascript&quot;]
let class = macro {
  rule { $className { $method:is_method ... } } =&gt; {
    methods $className, $method ...
  }
  rule {} =&gt; { class }
}
[/code]

Before I go any further, I want to point your attention to this macro in particular. Notice that I bound the macro to a name, `class`. The second rule is the cause for this: by the pattern and template given in the second rule, it is possible for infinite recursion to occur. But why, you ask? Well, our pattern is empty, which means it matches anything, and our template contains a forward to only the name of the macro which it&#39;s output in. Since we have a macro that forwards to itself indefinitely, how can we prevent infinite recursion? Sweet.js already accounts for infinite recursion and provides the `let` form as shown above, which prevents infinite recursion from happening. The reason for this extra rule is that `class` is a reserved keyword in JavaScript, so any future changes to ECMAScript&#39;s class definition won&#39;t break your code if the macro fails.

Since that&#39;s cleared up, let&#39;s move on to the first rule. The template specifies that we forward our `$className` and `$method` tokens to another macro named `methods`. There are two reasons why I chose to create another macro for iterating a set of methods: the first reason is for separation of concerns, and the second will become more apparent later, when we implement different kinds of methods.

[CODE=&quot;javascript&quot;]
macro methods {
  rule { $className, $method:is_method ... } =&gt; {
    $(method $className, $method) ...
  }
}
[/code]

This is most likely what first comes to mind, however, there is one slight problem... ES6 classes, like most other class-based OO languages, allow you to omit the constructor. Creating a default constructor is easy:

[CODE=&quot;javascript&quot;]
macro defaultconstructor {
  rule { $className } =&gt; {
    function $className() {}
  }
}
[/code]

Now we can improve `methods`:

[CODE=&quot;javascript&quot;]
// Iterate through the list of methods.
macro methods {
  rule { $className, $method:is_method ... } =&gt; {
    defaultconstructor $className
    $(method $className, $method) ...
  }
}
[/code]

Next we need a macro for every type of method. This is the most complicated macro that we are going to define, so pay close attention!

In order to transform our classical methods into prototypal methods, we need the class name and method token. There are two reasons why we need the class name:

[ul][li][b]Constructor functions.[/b] Even though ES6 defines the constructor to be named `constructor`, prototypal constructors define a constructor to be the name of a function which we use the `new` operator on. Our code generation would look something like:[/li][/ul]
[CODE=&quot;javascript&quot;]
function $className( /* params */) {
  /* body */
}
[/code]

[ul][li][b]Adding methods to the object&#39;s prototype.[/b] In order to add a method to an object&#39;s prototype, we need the name of the class to reference its prototype from:[/li][/ul]


[CODE=&quot;javascript&quot;]
$className.prototype.$methodName = function( /* params */ ) {
  /* body /*
};
[/code]

The two above reasons, as you might have noticed, are strictly for code generation. Another important thing to note is that we need to retrieve the method&#39;s name from its respective token. Using sweet.js, we can use the `unwrapSyntax()` function to achieve this. Now that we have all the necessary pieces, we can build our `method` macro:

[CODE=&quot;javascript&quot;]
macro method {
  case { _ $className, $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
    var methodName = unwrapSyntax(#{$methodName});
    // Is it the constructor?
    if (methodName === &quot;constructor&quot;) {
      return #{
        function $className($methodParam (,) ...) {
          $methodBody ...
        }
      }
    } else {
      return #{
        $className.prototype.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      }
    }
  }
}
[/code]

Now we&#39;ve implemented basic ES6 classes! However, there is still more to do: static methods. The prototypal difference between a regular method and a static one is that the former is a method of the object&#39;s prototype and the latter becomes a method of the object. 

[CODE=&quot;javascript&quot;]
$className.$methodName = function( /* params */ ) {
  /* body /*
};
[/code]

Therefore, there are only two changes we need to make: our pattern class which defines the form of a valid method, and a new rule in `method` that generates the actual static method.

Let&#39;s start with the first change:

[CODE=&quot;javascript&quot;]
macro is_method {
  // ES6 allows semicolon at the end of method definitions.
  rule {
    static $methodName($param:ident (,) ...) {
        $methodBody ...
    };
  }

  rule {
    static $methodName($param:ident (,) ...) {
        $methodBody ...
    }
  }

  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ...
    };
  }

  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ...
    }
  }
}
[/code]

That wasn&#39;t too bad! Really, the only change that needed to be done was including the `static` keyword to each method&#39;s signature. Adding the rule to `method` also isn&#39;t very complicated either, just follow the form of the regular methods. The only difference is that we include the access modifier in the rule&#39;s pattern and change the output of the code:

[CODE=&quot;javascript&quot;]
case { _ $className, $accessModifier $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
  var accessModifier = unwrapSyntax(#{$accessModifier});
  // Is it a static method?
  if (accessModifier === &quot;static&quot;) {
    return #{
      $className.$methodName = function($methodParam (,) ...) {
        $methodBody ...
      };
    }
  }
}
[/code]

Now we have static methods! But here comes the most difficult part: inheritance. ES6 classes accomplish inheritance using two new keywords.

The first keyword is `extends` and a class which extends another takes the following form:

[CODE=&quot;javascript&quot;]
class Child extends Parent {
  
  constructor() {
    // Call parent constructor
    super();
  }

  // Other methods ...

}
[/code]

The syntax gives us the necessary (and only) information we need to perform prototypal inheritance; we now have the parent&#39;s name. Since this is a valid form for declaring a class, we need to add a new rule to the `class` macro:

[CODE=&quot;javascript&quot;]
rule { $className extends $extends { $method:is_method ... } } =&gt; {
  methods $className, $extends, $method ...
}
[/code]

You&#39;ll notice that I forwarded `$extends` to the methods macro; this will become clear in a moment.

Next, we add a new rule to the `methods` macro:

[CODE=&quot;javascript&quot;]
rule { $className, $parentName, $method:is_method ... } =&gt; {
  $className.prototype = Object.create($parentName.prototype);
  $className.prototype.constructor = $className;
  $(method $className, $method) ...
}
[/code]

Recall that in JavaScript, we use `Object.create()` to create a new object given a prototype object (in this case we want the parent&#39;s prototype) then we set the child&#39;s constructor function. But what happens if the constructor is omitted? When this occurs, we need to call the parent&#39;s constructor function to properly define any class fields the child class may use. Thus, we need to add a new rule to the `defaultconstructor` macro for omitted constructors of child classes:

[CODE=&quot;javascript&quot;]
rule { $className, $parentName } =&gt; {
  function $className() {
    super();
  }
}
[/code]

Fixing up our new rule in `methods`:

[CODE=&quot;javascript&quot;]
rule { $className, $parentName, $method:is_method ... } =&gt; {
  defaultconstructor $className, $parentName
  $className.prototype = Object.create($parentName.prototype);
  $className.prototype.constructor = $className;
  $(method $className, $method) ...
}
[/code]

Where did `super` come from? Is it defined already? The answer is no, but now that the first half of getting inheritance support is complete, we can move on to `super`.

`super`, like in most other classical OO languages, is a keyword which refers to a parent (or in more correct terms: a pointer or a reference -- depending on the language). This special keyword can occur in any method, including the constructor. Somehow, we need to have a reference to the parent in order to call methods on its prototype object. Here are a few possibilities:

[ul][li][b]Create a new field in the object which refers to the parent&#39;s name.[/b] The problem with this approach is that it creates a new field for our object; it seems like a bit of a hack. Also, you would need to make this field read-only, probably using `Object.defineProperty()`. Can we do better?[/li]
[li][b]Use `$parentName` and forward it to the `super` macro.[/b] At first this might seem like the obvious solution, since we have the parent name already, but this will greatly increase the complexity of our `method` macro. Remember that `super` can occur anywhere in the body of a method, so we need to be able to select only the code that contains `super` and perform some special operations on it.[/li]
[li][b]Use the child object to traverse up the prototype chain.[/b] We can use `Object.getPrototypeOf()` to get the child object&#39;s prototype, then call it on the child&#39;s prototype object to get the parent&#39;s prototype object. Confusing? Perhaps, but think of the prototype chain as a linked list: where the child object is at the tail, and the base object is at the head. You can move backwards from the child to the parent to the base, by following pointers to previously stored nodes. In the context of JavaScript, this &quot;pointer&quot; would be the `__proto__` field.[/li][/ul]

The solution we will employ is the third option. Turns out this is very easy to do because we don&#39;t need any information about the parent -- just that it exists. Thus, our macro looks like:

[CODE=&quot;javascript&quot;]
let super = macro {
  rule { ($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).constructor.apply(this, [$arg (,) ...])
  }

  rule { .$methodName($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$methodName.apply(this, [$arg (,) ...])
  }

  rule { .$prop } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$prop
  }

  // Prevents unexpected side-effects due to exporting a reserved keyword.
  rule {} =&gt; { super }
}
[/code]

Ugly? Yes, but it gets the job done nicely. `Object.getPrototypeOf(Object.getPrototypeOf(this))` moves up the prototype chain from the child to the parent, without the need for any reference or name to the parent! Also, since this is a reserved keyword, I also added a rule in case there comes a time when the rest of the rules don&#39;t apply (future-proofing).

At this point, we have full support for ES6 classes. Note: I also added support for getter and setter modifiers.

[CODE=&quot;javascript&quot;]
macro is_method {
  // ES6 allows semicolon at the end of method definitions.
  rule { 
    static $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }; 
  }

  rule { 
    static $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }
  }

  rule { 
    get $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }; 
  }

  rule { 
    get $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }
  }  

  rule { 
    set $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }; 
  }

  rule { 
    set $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }
  }

  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    };
  }

  rule { 
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    }
  }
}

// All these ugly Object.getPrototypeOf(Object.getPrototypeOf(this)) calls
// are great for macros since they don&#39;t require defining object properties just
// for accessing the parent.
let super = macro {
  rule { ($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).constructor.apply(this, [$arg (,) ...])
  }

  rule { .$methodName($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$methodName.apply(this, [$arg (,) ...])
  }

  rule { .$prop } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$prop
  }

  rule {} =&gt; { super }
}

macro defaultconstructor {
  rule { $className, $parentName } =&gt; {
    function $className() {
      super();
    }
  }

  rule { $className } =&gt; {
    function $className() {}
  }
}

macro class {
  rule { $className extends $extends { $method:is_method ... } } =&gt; {
    methods $className, $extends, $method ...
  }

  rule { $className { $method:is_method ... } } =&gt; {
    methods $className, $method ...
  }
}

// Iterate through the list of methods.
macro methods {
  rule { $className, $parentName, $method:is_method ... } =&gt; {
    // This is required for omitted constructors.
    defaultconstructor $className, $parentName
    $className.prototype = Object.create($parentName.prototype);
    $className.prototype.constructor = $className;
    $(method $className, $method) ...
  }

  rule { $className, $method:is_method ... } =&gt; {
    // This is required for omitted constructors.
    defaultconstructor $className
    $(method $className, $method) ...
  }
}

macro method {
  case { _ $className, $accessModifier $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
    var accessModifier = unwrapSyntax(#{$accessModifier});
    // Is it a static method?
    if (accessModifier === &quot;static&quot;) {
      return #{
        $className.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      };
    } else { // &#39;get&#39; and &#39;set&#39;
      return #{
        $className.prototype.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      };
    }
  }

  case { _ $className, $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
    var methodName = unwrapSyntax(#{$methodName});
    // Is it the constructor?
    if (methodName === &quot;constructor&quot;) {
      return #{
        function $className($methodParam (,) ...) {
          $methodBody ...
        }
      };
    } else {
      return #{
        $className.prototype.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      };
    }
  }
}
[/code]</description>
    
    <lastBuildDate>Sat, 17 Oct 2015 00:54:30 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Extending JavaScript using sweet.js</title>
        <dc:creator><![CDATA[@sinisoul sini]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/sinisoul">@sinisoul</a> wrote:</p>
          <blockquote>
              <p>ECMA 6 gives me a hard on</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/5</link>
        <pubDate>Sat, 17 Oct 2015 00:54:30 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551977-5</guid>
        <source url="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977.rss">Extending JavaScript using sweet.js</source>
      </item>
      <item>
        <title>Extending JavaScript using sweet.js</title>
        <dc:creator><![CDATA[@pure2ownage Pure_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/pure2ownage">@pure2ownage</a> wrote:</p>
          <blockquote>
              <p>[quote=“justaguy, post:3, topic:551977”][quote author=Pure_ link=topic=670894.msg4486322#msg4486322 date=1434159570]<br>
I’ll read this in full later on but could you enable the syntax highlighing for the code please, thank you <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"><br>
[/quote]</p>
<p>I would but SMF doesn’t seem to have JavaScript syntax highlighting. My site has full JS highlighting though (linked at the top of the post)![/quote]I see, that sucks. I will feature this in the next news article so you have until Monday to iron out anything <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/4</link>
        <pubDate>Sat, 13 Jun 2015 01:50:37 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551977-4</guid>
        <source url="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977.rss">Extending JavaScript using sweet.js</source>
      </item>
      <item>
        <title>Extending JavaScript using sweet.js</title>
        <dc:creator><![CDATA[@justaguy justaguy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/justaguy">@justaguy</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="2" data-topic="551977">
<div class="title">
<div class="quote-controls"></div>
 Pure_:</div>
<blockquote>
<p>I’ll read this in full later on but could you enable the syntax highlighing for the code please, thank you <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
</blockquote>
</aside>
<p>I would but SMF doesn’t seem to have JavaScript syntax highlighting. My site has full JS highlighting though (linked at the top of the post)!</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/3</link>
        <pubDate>Sat, 13 Jun 2015 01:48:33 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551977-3</guid>
        <source url="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977.rss">Extending JavaScript using sweet.js</source>
      </item>
      <item>
        <title>Extending JavaScript using sweet.js</title>
        <dc:creator><![CDATA[@pure2ownage Pure_]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/pure2ownage">@pure2ownage</a> wrote:</p>
          <blockquote>
              <p>I’ll read this in full later on but could you enable the syntax highlighing for the code please, thank you <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/2</link>
        <pubDate>Sat, 13 Jun 2015 01:39:30 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551977-2</guid>
        <source url="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977.rss">Extending JavaScript using sweet.js</source>
      </item>
      <item>
        <title>Extending JavaScript using sweet.js</title>
        <dc:creator><![CDATA[@justaguy justaguy]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/justaguy">@justaguy</a> wrote:</p>
          <blockquote>
              <p>Frequent updates posted here: <a href="http://anthony-calandra.com/posts/Implementing-ES6-Features-in-ES5-using-Macros-2" data-bbcode="true" rel="nofollow noopener">Implementing ES6 Features in ES5 using Macros</a>. Due to the topic size restriction, only classes are covered in this topic.<br>
[HR]<br>
This post will cover how to implement the newest ECMAScript 6 syntactic and functionality changes in ECMAScript 5 using Mozilla’s macro library, sweet.js.</p>
<p>Here is a current list of features:</p>
<p>[ul][li]Arrow functions (covered in blog)[/li]<br>
[li]Classes[/li]<br>
[li]Default parameters (covered in blog)[/li]<br>
[li]Rest parameters (covered in blog)[/li][/ul]</p>
<p>[SIZE=4]Classes[/SIZE]</p>
<p>One of the most significant (and arguably controversial) changes to the language is the new class-based object oriented programming syntax. ECMAScript has exclusively followed a prototypal solution to object design, and as such, the new class-based syntax will require our macro to use those prototypal ideas to generate code that conforms to class-based syntax.</p>
<p>An example of a class in ES6 is as follows:</p>
<pre><code class="lang-auto">class Shape {
  constructor() {
    this.x = 0;
    this.y = 0;
  }

  move(x, y) {
    this.x += x;
    this.y += y;
  }

  static defaultShape() {
    return new Shape();
  }
}</code></pre>
<p>As you can see, a class is composed of a class name, a couple braces, and methods. The class name and braces are easy to include in the pattern for our <code>class</code> rule, but the form of methods are more complicated. To simplify the rule, let us define our own pattern classes for determining if a given token is a method:</p>
<pre><code class="lang-auto">macro is_method {
  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    };
  }

  rule { 
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    }
  }
}</code></pre>
<p>As you can tell by the ruleset, a method has a name, optional parameters delimited by commas, and a method body. Optionally, methods in a class can also end in a semicolon. Now that we have a pattern class for denoting methods, we can now begin our <code>class</code> macro:</p>
<pre><code class="lang-auto">let class = macro {
  rule { $className { $method:is_method ... } } =&gt; {
    methods $className, $method ...
  }
  rule {} =&gt; { class }
}</code></pre>
<p>Before I go any further, I want to point your attention to this macro in particular. Notice that I bound the macro to a name, <code>class</code>. The second rule is the cause for this: by the pattern and template given in the second rule, it is possible for infinite recursion to occur. But why, you ask? Well, our pattern is empty, which means it matches anything, and our template contains a forward to only the name of the macro which it’s output in. Since we have a macro that forwards to itself indefinitely, how can we prevent infinite recursion? Sweet.js already accounts for infinite recursion and provides the <code>let</code> form as shown above, which prevents infinite recursion from happening. The reason for this extra rule is that <code>class</code> is a reserved keyword in JavaScript, so any future changes to ECMAScript’s class definition won’t break your code if the macro fails.</p>
<p>Since that’s cleared up, let’s move on to the first rule. The template specifies that we forward our <code>$className</code> and <code>$method</code> tokens to another macro named <code>methods</code>. There are two reasons why I chose to create another macro for iterating a set of methods: the first reason is for separation of concerns, and the second will become more apparent later, when we implement different kinds of methods.</p>
<pre><code class="lang-auto">macro methods {
  rule { $className, $method:is_method ... } =&gt; {
    $(method $className, $method) ...
  }
}</code></pre>
<p>This is most likely what first comes to mind, however, there is one slight problem… ES6 classes, like most other class-based OO languages, allow you to omit the constructor. Creating a default constructor is easy:</p>
<pre><code class="lang-auto">macro defaultconstructor {
  rule { $className } =&gt; {
    function $className() {}
  }
}</code></pre>
<p>Now we can improve <code>methods</code>:</p>
<pre><code class="lang-auto">// Iterate through the list of methods.
macro methods {
  rule { $className, $method:is_method ... } =&gt; {
    defaultconstructor $className
    $(method $className, $method) ...
  }
}</code></pre>
<p>Next we need a macro for every type of method. This is the most complicated macro that we are going to define, so pay close attention!</p>
<p>In order to transform our classical methods into prototypal methods, we need the class name and method token. There are two reasons why we need the class name:</p>
<p>[ul][li]<span class="bbcode-b">Constructor functions.</span> Even though ES6 defines the constructor to be named <code>constructor</code>, prototypal constructors define a constructor to be the name of a function which we use the <code>new</code> operator on. Our code generation would look something like:[/li][/ul]</p>
<pre><code class="lang-auto">function $className( /* params */) {
  /* body */
}</code></pre>
<p>[ul][li]<span class="bbcode-b">Adding methods to the object’s prototype.</span> In order to add a method to an object’s prototype, we need the name of the class to reference its prototype from:[/li][/ul]</p>
<pre><code class="lang-auto">$className.prototype.$methodName = function( /* params */ ) {
  /* body /*
};</code></pre>
<p>The two above reasons, as you might have noticed, are strictly for code generation. Another important thing to note is that we need to retrieve the method’s name from its respective token. Using sweet.js, we can use the <code>unwrapSyntax()</code> function to achieve this. Now that we have all the necessary pieces, we can build our <code>method</code> macro:</p>
<pre><code class="lang-auto">macro method {
  case { _ $className, $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
    var methodName = unwrapSyntax(#{$methodName});
    // Is it the constructor?
    if (methodName === "constructor") {
      return #{
        function $className($methodParam (,) ...) {
          $methodBody ...
        }
      }
    } else {
      return #{
        $className.prototype.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      }
    }
  }
}</code></pre>
<p>Now we’ve implemented basic ES6 classes! However, there is still more to do: static methods. The prototypal difference between a regular method and a static one is that the former is a method of the object’s prototype and the latter becomes a method of the object.</p>
<pre><code class="lang-auto">$className.$methodName = function( /* params */ ) {
  /* body /*
};</code></pre>
<p>Therefore, there are only two changes we need to make: our pattern class which defines the form of a valid method, and a new rule in <code>method</code> that generates the actual static method.</p>
<p>Let’s start with the first change:</p>
<pre><code class="lang-auto">macro is_method {
  // ES6 allows semicolon at the end of method definitions.
  rule {
    static $methodName($param:ident (,) ...) {
        $methodBody ...
    };
  }

  rule {
    static $methodName($param:ident (,) ...) {
        $methodBody ...
    }
  }

  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ...
    };
  }

  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ...
    }
  }
}</code></pre>
<p>That wasn’t too bad! Really, the only change that needed to be done was including the <code>static</code> keyword to each method’s signature. Adding the rule to <code>method</code> also isn’t very complicated either, just follow the form of the regular methods. The only difference is that we include the access modifier in the rule’s pattern and change the output of the code:</p>
<pre><code class="lang-auto">case { _ $className, $accessModifier $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
  var accessModifier = unwrapSyntax(#{$accessModifier});
  // Is it a static method?
  if (accessModifier === "static") {
    return #{
      $className.$methodName = function($methodParam (,) ...) {
        $methodBody ...
      };
    }
  }
}</code></pre>
<p>Now we have static methods! But here comes the most difficult part: inheritance. ES6 classes accomplish inheritance using two new keywords.</p>
<p>The first keyword is <code>extends</code> and a class which extends another takes the following form:</p>
<pre><code class="lang-auto">class Child extends Parent {
  
  constructor() {
    // Call parent constructor
    super();
  }

  // Other methods ...

}</code></pre>
<p>The syntax gives us the necessary (and only) information we need to perform prototypal inheritance; we now have the parent’s name. Since this is a valid form for declaring a class, we need to add a new rule to the <code>class</code> macro:</p>
<pre><code class="lang-auto">rule { $className extends $extends { $method:is_method ... } } =&gt; {
  methods $className, $extends, $method ...
}</code></pre>
<p>You’ll notice that I forwarded <code>$extends</code> to the methods macro; this will become clear in a moment.</p>
<p>Next, we add a new rule to the <code>methods</code> macro:</p>
<pre><code class="lang-auto">rule { $className, $parentName, $method:is_method ... } =&gt; {
  $className.prototype = Object.create($parentName.prototype);
  $className.prototype.constructor = $className;
  $(method $className, $method) ...
}</code></pre>
<p>Recall that in JavaScript, we use <code>Object.create()</code> to create a new object given a prototype object (in this case we want the parent’s prototype) then we set the child’s constructor function. But what happens if the constructor is omitted? When this occurs, we need to call the parent’s constructor function to properly define any class fields the child class may use. Thus, we need to add a new rule to the <code>defaultconstructor</code> macro for omitted constructors of child classes:</p>
<pre><code class="lang-auto">rule { $className, $parentName } =&gt; {
  function $className() {
    super();
  }
}</code></pre>
<p>Fixing up our new rule in <code>methods</code>:</p>
<pre><code class="lang-auto">rule { $className, $parentName, $method:is_method ... } =&gt; {
  defaultconstructor $className, $parentName
  $className.prototype = Object.create($parentName.prototype);
  $className.prototype.constructor = $className;
  $(method $className, $method) ...
}</code></pre>
<p>Where did <code>super</code> come from? Is it defined already? The answer is no, but now that the first half of getting inheritance support is complete, we can move on to <code>super</code>.</p>
<p><code>super</code>, like in most other classical OO languages, is a keyword which refers to a parent (or in more correct terms: a pointer or a reference – depending on the language). This special keyword can occur in any method, including the constructor. Somehow, we need to have a reference to the parent in order to call methods on its prototype object. Here are a few possibilities:</p>
<p>[ul][li]<span class="bbcode-b">Create a new field in the object which refers to the parent’s name.</span> The problem with this approach is that it creates a new field for our object; it seems like a bit of a hack. Also, you would need to make this field read-only, probably using <code>Object.defineProperty()</code>. Can we do better?[/li]<br>
[li]<span class="bbcode-b">Use <code>$parentName</code> and forward it to the <code>super</code> macro.</span> At first this might seem like the obvious solution, since we have the parent name already, but this will greatly increase the complexity of our <code>method</code> macro. Remember that <code>super</code> can occur anywhere in the body of a method, so we need to be able to select only the code that contains <code>super</code> and perform some special operations on it.[/li]<br>
[li]<span class="bbcode-b">Use the child object to traverse up the prototype chain.</span> We can use <code>Object.getPrototypeOf()</code> to get the child object’s prototype, then call it on the child’s prototype object to get the parent’s prototype object. Confusing? Perhaps, but think of the prototype chain as a linked list: where the child object is at the tail, and the base object is at the head. You can move backwards from the child to the parent to the base, by following pointers to previously stored nodes. In the context of JavaScript, this “pointer” would be the <code>__proto__</code> field.[/li][/ul]</p>
<p>The solution we will employ is the third option. Turns out this is very easy to do because we don’t need any information about the parent – just that it exists. Thus, our macro looks like:</p>
<pre><code class="lang-auto">let super = macro {
  rule { ($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).constructor.apply(this, [$arg (,) ...])
  }

  rule { .$methodName($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$methodName.apply(this, [$arg (,) ...])
  }

  rule { .$prop } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$prop
  }

  // Prevents unexpected side-effects due to exporting a reserved keyword.
  rule {} =&gt; { super }
}</code></pre>
<p>Ugly? Yes, but it gets the job done nicely. <code>Object.getPrototypeOf(Object.getPrototypeOf(this))</code> moves up the prototype chain from the child to the parent, without the need for any reference or name to the parent! Also, since this is a reserved keyword, I also added a rule in case there comes a time when the rest of the rules don’t apply (future-proofing).</p>
<p>At this point, we have full support for ES6 classes. Note: I also added support for getter and setter modifiers.</p>
<pre><code class="lang-auto">macro is_method {
  // ES6 allows semicolon at the end of method definitions.
  rule { 
    static $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }; 
  }

  rule { 
    static $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }
  }

  rule { 
    get $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }; 
  }

  rule { 
    get $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }
  }  

  rule { 
    set $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }; 
  }

  rule { 
    set $methodName($param:ident (,) ...) { 
        $methodBody ... 
    }
  }

  rule {
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    };
  }

  rule { 
    $methodName($param:ident (,) ...) {
        $methodBody ... 
    }
  }
}

// All these ugly Object.getPrototypeOf(Object.getPrototypeOf(this)) calls
// are great for macros since they don't require defining object properties just
// for accessing the parent.
let super = macro {
  rule { ($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).constructor.apply(this, [$arg (,) ...])
  }

  rule { .$methodName($arg (,) ...) } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$methodName.apply(this, [$arg (,) ...])
  }

  rule { .$prop } =&gt; {
    Object.getPrototypeOf(Object.getPrototypeOf(this)).$prop
  }

  rule {} =&gt; { super }
}

macro defaultconstructor {
  rule { $className, $parentName } =&gt; {
    function $className() {
      super();
    }
  }

  rule { $className } =&gt; {
    function $className() {}
  }
}

macro class {
  rule { $className extends $extends { $method:is_method ... } } =&gt; {
    methods $className, $extends, $method ...
  }

  rule { $className { $method:is_method ... } } =&gt; {
    methods $className, $method ...
  }
}

// Iterate through the list of methods.
macro methods {
  rule { $className, $parentName, $method:is_method ... } =&gt; {
    // This is required for omitted constructors.
    defaultconstructor $className, $parentName
    $className.prototype = Object.create($parentName.prototype);
    $className.prototype.constructor = $className;
    $(method $className, $method) ...
  }

  rule { $className, $method:is_method ... } =&gt; {
    // This is required for omitted constructors.
    defaultconstructor $className
    $(method $className, $method) ...
  }
}

macro method {
  case { _ $className, $accessModifier $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
    var accessModifier = unwrapSyntax(#{$accessModifier});
    // Is it a static method?
    if (accessModifier === "static") {
      return #{
        $className.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      };
    } else { // 'get' and 'set'
      return #{
        $className.prototype.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      };
    }
  }

  case { _ $className, $methodName($methodParam:ident (,) ...) { $methodBody ... } } =&gt; {
    var methodName = unwrapSyntax(#{$methodName});
    // Is it the constructor?
    if (methodName === "constructor") {
      return #{
        function $className($methodParam (,) ...) {
          $methodBody ...
        }
      };
    } else {
      return #{
        $className.prototype.$methodName = function($methodParam (,) ...) {
          $methodBody ...
        };
      };
    }
  }
}</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977/1</link>
        <pubDate>Sat, 13 Jun 2015 01:30:57 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-551977-1</guid>
        <source url="https://forum.moparisthebest.com/t/extending-javascript-using-sweet-js/551977.rss">Extending JavaScript using sweet.js</source>
      </item>
  </channel>
</rss>
