<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>[c#] Displaying [Pre-order] Binary Search Tree data</title>
    <link>https://forum.moparisthebest.com/t/c-displaying-pre-order-binary-search-tree-data/540878</link>
    <description>Hi,

I have a binary search tree that I would like to print the data in the correct order.

So, each node has two children, the left and right of it where another node is placed. My problem is when two nodes are placed below the parent. I need them to be print in the correct order i.e.

                         root
             firstlvl             firstlvl
          seclvl    seclvl      seclvl   seclvl
        3rdlvl 3rdlvl and so on.. 

Right now it&#39;ll prioritize the left hand side I believe.

[CODE]Node dataTempNode, depthNode;
        private int depth = 0;
        string printData = &quot;&quot;;
        public void PrintTransverse()
        {
            if (depth == 0)
            {
                dataTempNode = root;
                printData = &quot;root \t &quot; + dataTempNode.value.ToString();
                depth++;
            }
            if (dataTempNode.right == null &amp;&amp; dataTempNode.left != null)
            {
                dataTempNode = dataTempNode.left;
                printData += &quot; \n Left \t &quot; + dataTempNode.value.ToString();
                depth++;
                if (depthNode == null || depthNode.depth == 0 || dataTempNode.left != null || dataTempNode.right != null)
                {
                    PrintTransverse(); 
                    return;
                }
                return;

            }
            if (dataTempNode.left == null &amp;&amp; dataTempNode.right != null)
            {
                dataTempNode = dataTempNode.right;
                printData += &quot; \n Right \t &quot; + dataTempNode.value.ToString();
                depth++;
                if (depthNode == null || depthNode.depth == 0 || dataTempNode.left != null || dataTempNode.right != null)
                {
                    PrintTransverse();
                    return;
                }
                return;
            }
            if (dataTempNode.left != null &amp;&amp; dataTempNode.right != null &amp;&amp; dataTempNode.depth == 0)
            {
                depthNode = dataTempNode;
                depthNode.depth = depth;
                printData += &quot;\n below two lines = same level&quot;;
                dataTempNode = dataTempNode.left;
                PrintTransverse();
                if (printData.Contains(&quot;end&quot;))
                {
                    return;
                }
                dataTempNode = depthNode;
                dataTempNode.depth = 0;
                depthNode.depth = 0;

                //right

                dataTempNode = depthNode.right;
                PrintTransverse();
                if (printData.Contains(&quot;end&quot;))
                {
                    return;
                }
                dataTempNode = depthNode;
                dataTempNode.depth = 0;
                depthNode.depth = 0;


                depth++;
                if (dataTempNode.left == null &amp;&amp; dataTempNode.right == null)
                {
                    return;
                }

            }
            if (dataTempNode.left == null &amp;&amp; dataTempNode.right == null)
            {

                Console.WriteLine(printData);
                printData += &quot;end&quot;;
                return;
            }
            else
            {
                PrintTransverse();
            }
        }[/CODE]
Example of the issue in action (the code used in the working program in regards to this section is a cluster fudge so I used an earlier revision of it):
[IMG]http://i57.tinypic.com/148i5v4.png[/img] 
I&#39;m aware the above is ugly, I have code elsewhere that makes it nice and pretty but I&#39;m not going to bother adding it in until it works.

Whole tree class (including the clusterfudge code): http://pastebin.com/fz6nTLWR

Any help/advice is appreciated.</description>
    
    <lastBuildDate>Tue, 04 Mar 2014 17:09:37 +0000</lastBuildDate>
    <category>General Discussion</category>
    <atom:link href="https://forum.moparisthebest.com/t/c-displaying-pre-order-binary-search-tree-data/540878.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>[c#] Displaying [Pre-order] Binary Search Tree data</title>
        <dc:creator><![CDATA[@Kidpaparoach Kidpaparoach]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/kidpaparoach">@Kidpaparoach</a> wrote:</p>
          <blockquote>
              <p>Hi,</p>
<p>I have a binary search tree that I would like to print the data in the correct order.</p>
<p>So, each node has two children, the left and right of it where another node is placed. My problem is when two nodes are placed below the parent. I need them to be print in the correct order i.e.</p>
<pre><code>                     root
         firstlvl             firstlvl
      seclvl    seclvl      seclvl   seclvl
    3rdlvl 3rdlvl and so on.. 
</code></pre>
<p>Right now it’ll prioritize the left hand side I believe.</p>
<p>[CODE]Node dataTempNode, depthNode;<br>
private int depth = 0;<br>
string printData = “”;<br>
public void PrintTransverse()<br>
{<br>
if (depth == 0)<br>
{<br>
dataTempNode = root;<br>
printData = "root \t " + dataTempNode.value.ToString();<br>
depth++;<br>
}<br>
if (dataTempNode.right == null &amp;&amp; dataTempNode.left != null)<br>
{<br>
dataTempNode = dataTempNode.left;<br>
printData += " \n Left \t " + dataTempNode.value.ToString();<br>
depth++;<br>
if (depthNode == null || depthNode.depth == 0 || dataTempNode.left != null || dataTempNode.right != null)<br>
{<br>
PrintTransverse();<br>
return;<br>
}<br>
return;</p>
<pre><code>        }
        if (dataTempNode.left == null &amp;&amp; dataTempNode.right != null)
        {
            dataTempNode = dataTempNode.right;
            printData += " \n Right \t " + dataTempNode.value.ToString();
            depth++;
            if (depthNode == null || depthNode.depth == 0 || dataTempNode.left != null || dataTempNode.right != null)
            {
                PrintTransverse();
                return;
            }
            return;
        }
        if (dataTempNode.left != null &amp;&amp; dataTempNode.right != null &amp;&amp; dataTempNode.depth == 0)
        {
            depthNode = dataTempNode;
            depthNode.depth = depth;
            printData += "\n below two lines = same level";
            dataTempNode = dataTempNode.left;
            PrintTransverse();
            if (printData.Contains("end"))
            {
                return;
            }
            dataTempNode = depthNode;
            dataTempNode.depth = 0;
            depthNode.depth = 0;

            //right

            dataTempNode = depthNode.right;
            PrintTransverse();
            if (printData.Contains("end"))
            {
                return;
            }
            dataTempNode = depthNode;
            dataTempNode.depth = 0;
            depthNode.depth = 0;


            depth++;
            if (dataTempNode.left == null &amp;&amp; dataTempNode.right == null)
            {
                return;
            }

        }
        if (dataTempNode.left == null &amp;&amp; dataTempNode.right == null)
        {

            Console.WriteLine(printData);
            printData += "end";
            return;
        }
        else
        {
            PrintTransverse();
        }
    }[/CODE]
</code></pre>
<p>Example of the issue in action (the code used in the working program in regards to this section is a cluster fudge so I used an earlier revision of it):<br>
<img src="http://i57.tinypic.com/148i5v4.png" alt width="" height=""><br>
I’m aware the above is ugly, I have code elsewhere that makes it nice and pretty but I’m not going to bother adding it in until it works.</p>
<p>Whole tree class (including the clusterfudge code): <a href="http://pastebin.com/fz6nTLWR" rel="nofollow noopener">http://pastebin.com/fz6nTLWR</a></p>
<p>Any help/advice is appreciated.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-displaying-pre-order-binary-search-tree-data/540878/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-displaying-pre-order-binary-search-tree-data/540878/1</link>
        <pubDate>Tue, 04 Mar 2014 17:09:37 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-540878-1</guid>
        <source url="https://forum.moparisthebest.com/t/c-displaying-pre-order-binary-search-tree-data/540878.rss">[c#] Displaying [Pre-order] Binary Search Tree data</source>
      </item>
  </channel>
</rss>
