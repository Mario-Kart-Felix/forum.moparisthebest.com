<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Creating a grid using linked nodes</title>
    <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587</link>
    <description>I have an assignment where the objective is to create a grid composed of 10 rows and 6 columns, where each cell can hold a String or Double.  Operations will be provided which display the grid, assign values to the cells, do arithmetic on cells, do arithmetic on rows and columns, fill cells with values, insert, delete, and move rows and columns. The default value for all cells is an empty string. 
The following are the guidelines and sample outputs:


&lt;blockquote&gt;Data structures

Each cell in the grid will be represented by a Node (a class) with a Value field and two pointer (i.e. reference) fields, right and down. The right pointers will be used to link the nodes into rows and the down pointers will link the nodes into columns. Each row will be linked as a circle (the right field of the final node in each row will point to the first node in the row) as will each column (the down pointer of the bottom node pointing to the top node of the column).

A Value is represented as a class with three fields: a double field, dval, to hold numeric values, a String field, sval, for character strings, and a tag field which indicates whether the Value is currently a number or string (or is invalid). Arithmetic (+, -, *, and /) can be performed on Values.

The grid itself will be an instance of a Grid class. This class will have integer fields for the number of rows, number of columns, and the print width (for displaying a cell). Use the value 10 for print width. It will have a head field which points to the first node of the grid (at row 0, column 0). A constructor and a number of public member functions for the grid operations will be written.
Internals

After the (number of rows) × (number of columns) nodes have been created and linked together by the constructor for Grid all access to nodes will be done through pointer operations beginning at head.
Values

The Value class represents the values that can be stored in the nodes. A value can be either a double or a string. A separate data field is provided for each so it is possible for a &quot;Value&quot; to contain both a double and a string. The tag field indicates which of these data fields holds the &quot;real value&quot; of the Value. A Value can also have an &quot;INVALID&quot; tag. This tag value is only used for (some) intermediate results in arithmetic and a Value with an INVALID tag is never stored in a node. Values are constructed with tag STRING, dval 0, and sval an empty string.

Arithmetic can be done on Values with the operators plus, minus, star, and slash. Each of these will be implemented as a method of the Value class taking a Value as parameter. The operators will first check to see if the tags of both operands are DBL. If not no arithmetic is performed and the tag of the resulting Value is set to INVALID. Otherwise the sum, product, etc., is computed and the result stored in the dval field of the resulting Value. The tag is set to DBL.

You will write a toString method for Value. Notice that you do not know whether the input will be a double or a string until after it has been entered. To resolve this problem accept the input as a String and check the first character. If it is a double quote mark (&quot;) it is a string and copy it (after allocating memory) without the quote mark to the sval field. Otherwise the input is intended as a double. In this case convert it to a double with Double.parseDouble and store the result in the dval field.
The Grid class

The Grid class has member functions to print the grid, to do arithmetic on the cells, to insert and delete rows and columns, and to assign values to the cells.

The display member function will display the grid. Each cell will be displayed in a field of print_width characters. The row and column numbers will be displayed.
Grid arithmetic

Arithmetic can be done on individual cells with addNodes, subNodes, mulNodes, and divNodes member functions. Other member functions perform arithmetic on entire rows (addRows, etc.) or columns (addCols, etc.) at a time. In all cases once you have located the nodes to be operated on you can just &quot;add,&quot; etc., the Values and assign Values without accessing the Value&#39;s data fields or checking tags by simply using the arithmetic methods from Value.
Inserting and deleting nodes

Entire rows and columns can be inserted into the grid using insertRow and insertCol. Rows and columns can be deleted using deleteRow and deleteCol. These functions work through much fussing with pointers and require a certain amount of care to code.
Assigning Values to cells

Two member functions assign values to cells: number and fill. number requires the row and column numbers of two grid cells. These define a rectangular &quot;subgrid&quot; having these two grid cells as corners. number will assign the numbers 0, 1, 2, etc. (as doubles) to these cells. fill is similar but it puts the same Value (passed as a parameter) in the node representing each cell.

Notice that fill can be used to assign a value to a single cell.
Validation

For all methods the parameter values must be validated. Each row and column number must be in the correct range (between 0 and Grid.rows-1 and between 0 and Grid.cols-1 respectively). If two row/column pairs are used to define a subgrid (as with number and fill) the first pair cannot follow the second (but they can be the same). The delRow and delCol functions must not reduce the grid to an empty grid (there must always be at least one row and one column in the grid). Member functions which do division must check for zero divisors. If a zero divisor is found and error message is displayed and the division is not performed. Any other validations needed for the member functions to make sense must be done.&lt;/blockquote&gt;

&lt;blockquote&gt;                    col 0     col 1     col 2     col 3     col 4     col 5     
          row 0     0         1         2         3         4         5         
          row 1     6         7         8         9         10        11        
          row 2     12        13        14        15        16        17        
          row 3     18        19        20        21        22        23        
          row 4     24        25        26        27        28        29        
          row 5     30        31        32        33        34        35        
          row 6     36        37        38        39        40        41        
          row 7     42        43        44        45        46        47        
          row 8     48        49        50        51        52        53        
          row 9     54        55        56        57        58        59 &lt;/blockquote&gt;

I am having trouble getting my feet off of the ground, and would appreciate some help from a more proficient Java coder.  Basically what I have right now is a simple Linked list which will create a row of empty nodes.  I am not quite sure how I will connect the nodes to form a grid.  Should I be using Circular linked lists instead?  How can I connect nodes into a grid form?  Thank you for your attention.</description>
    
    <lastBuildDate>Wed, 04 Oct 2006 11:14:13 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@crutex crutex]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/crutex">@crutex</a> wrote:</p>
          <blockquote>
              <p>[quote=“Galook, post:12, topic:14587”]I’ll post here what I found wrong as i look through it.</p>
<p>The first thing i ound so far was in your main method in case 1: when you use the nextInt() line on a Scanner object, and you are intending to use a nextLine() method on it, you have to have a nextLine() before it. There is a bug in the Scanner when using nextInt() to nextLine(), so your case 1 should be :</p>
<p><code>case 1: //assign cell
                   System.out.print("row number: ");
                   startrow = endrow = kb.nextInt();
                   System.out.print("column number: ");
                   startcol = endcol = kb.nextInt();
                   System.out.print("with value: ");
                   kb.nextInt(); // you need this to get past the bug
                   strinput = kb.nextLine();                   
                   System.out.println();
                   g.fill(startrow, endrow, startcol, endcol, strinput);
                   break;</code></p>
<p>I need to know, did it work for you when you tested it out? The program as a whole, not a specific part.[/quote]<br>
There was one case for the menu which I had to change.  Also the decimal formatting was displaying numbers off to 10 digits or something.  Also they are not technically circularly linked <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> But it works regardless except for the insert row and insert column when called from the menu.  Its strange because I have it so that it calls these methods when making the grid but when called from the menu it shits out…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/13</link>
        <pubDate>Wed, 04 Oct 2006 11:14:13 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-13</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@Galook Galook]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/galook">@Galook</a> wrote:</p>
          <blockquote>
              <p>I’ll post here what I found wrong as i look through it.</p>
<p>The first thing i ound so far was in your main method in case 1: when you use the nextInt() line on a Scanner object, and you are intending to use a nextLine() method on it, you have to have a nextLine() before it. There is a bug in the Scanner when using nextInt() to nextLine(), so your case 1 should be :</p>
<p><code>case 1: //assign cell
                   System.out.print("row number: ");
                   startrow = endrow = kb.nextInt();
                   System.out.print("column number: ");
                   startcol = endcol = kb.nextInt();
                   System.out.print("with value: ");
                   kb.nextInt(); // you need this to get past the bug
                   strinput = kb.nextLine();                   
                   System.out.println();
                   g.fill(startrow, endrow, startcol, endcol, strinput);
                   break;</code></p>
<p>I need to know, did it work for you when you tested it out? The program as a whole, not a specific part.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/12</link>
        <pubDate>Tue, 03 Oct 2006 11:03:00 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-12</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@crutex crutex]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/crutex">@crutex</a> wrote:</p>
          <blockquote>
              <p>Well it’s not technically circular but here is what I came up with:</p>
<pre><code class="lang-auto">
import java.util.*;

public class ArithGrid {
   public static void main(String[] args)
   {
}




class Node {
//These are links which will connect the list into a grid, by having connections
//both to the right and below.
   public Node down, right;
   public Value value;
//This is a simple constructor for a new Node setting the links above to null.  
   public Node() {
       this.down = null; this.right = null; value = new Value();
   }
   @Override
   public String toString() {
       return value.toString();
   }
}

 
class Value {
   private String sval;
   private double dval;
   private int tag;
//Flags for the tag possibilities.	
   static final int TAG_INVALID = 0x1;
   static final int TAG_STRING = 0x2;
   static final int TAG_DOUBLE = 0x4;
   public Value() {
       tag = TAG_STRING;
       sval = "";
       dval = 0.0;
   }
	
   public void setValue(Value value) {
       setValue(value.toString());
   }
   public void setValue(double value) {
       tag = TAG_DOUBLE;
       dval = value;
       sval = "";
   }
   public void setValue(String value) {
       if(value.length() &gt;= 1 &amp;&amp; value.charAt(0) != '"') {
           try {
               tag = TAG_DOUBLE;
               dval = Double.parseDouble(value);
               sval = "";
           } catch(Exception e) {
               tag = TAG_INVALID;
               dval = 0.0;
               sval = "";
           }
       } else if(value.length() &gt; 1) {
           tag = TAG_STRING;
           sval = value.substring(1);
           dval = 0.0;
       }
   }
//setTag checks to see if there is a tag assigned by seeing if the tag value is
//equal to the flags set previously.  If its not the provided tag is set.	
   public void setTag(int tag) {
       if(tag != TAG_INVALID &amp;&amp; tag != TAG_STRING &amp;&amp; tag != TAG_DOUBLE)
return;
       this.tag = tag;
   }
//getTag simply returns whatever tag was set.	
   public int getTag() { return tag; }
//plus creates a temporary node, nv.  It will check to see if the value 
//provided is a double.  If it is a double, then the addition can be done.  
//If it is not, the tag is set to INVALID and the function breaks.	
   public Value plus(Value v) {
       Value nv = new Value();
       if(v.getTag() == TAG_DOUBLE &amp;&amp; this.tag == TAG_DOUBLE)
nv.setValue(this.dval + v.dval);
       else nv.setTag(TAG_INVALID);
       return nv;
   }
//minus uses the same principles as the plus method, with the difference being
//subtraction is performed instead of addition.	
   public Value minus(Value v) {
       Value nv = new Value();
       if(v.getTag() == TAG_DOUBLE &amp;&amp; this.tag == TAG_DOUBLE)
nv.setValue(this.dval - v.dval);
       else nv.setTag(TAG_INVALID);
       return nv;
   }
 //All of these methods for the basic arithmetic are practically clones.  	
   public Value times(Value v) {
       Value nv = new Value();
       if(v.getTag() == TAG_DOUBLE &amp;&amp; this.tag == TAG_DOUBLE)
nv.setValue(this.dval * v.dval);
       else nv.setTag(TAG_INVALID);
       return nv;
   }
   public Value divideBy(Value v) {
       Value nv = new Value();
       if(v.getTag() == TAG_DOUBLE &amp;&amp; this.tag == TAG_DOUBLE)
nv.setValue(this.dval / v.dval);
       else nv.setTag(TAG_INVALID);
       return nv;
   }
   @Override
   public String toString() {
       switch(tag) {
           case TAG_STRING: return sval;
           case TAG_DOUBLE: return String.format("%1.10f", dval);
           case TAG_INVALID: return "INVALID";
       }
       return "NOVALUE";
   }
}


class Grid {
   public int rows, cols, print_width;
//rows and cols will represent the height and width of the grid.  print_width
//is set to the instructor provided value of 10.  The default constructor
//with no parameters would create a grid of 10 rows x 6 columns.	
   public Grid() {
       this(10, 6);
   }
//The following actually builds the grid, by calling the insertRow and 
//insertColumn methods until i is incremeneted to reach the value provided 
//by the user.	
   private Node head;
   public Grid(int rows, int columns) {
       this.rows = rows;
       this.cols = columns;
       this.print_width = 10;
       head = new Node();
       for(int i = 0; i &lt; rows; i++) insertRow(i);
       for(int i = 0; i &lt; columns; i++) insertCol(i);
   }
//getCell will take a provided row and column number and return a reference
//to the node specified.  If an attempt to access a cell that is outside of
//the grid and therefore does not exist, null is returned.	
   private Node getCell(int row, int col) {
       if(row &gt; rows || col &gt; cols) return null;
       Node cell = head;
       for(int i = 0; i &lt; row; i++) cell = cell.down;
       for(int i = 0; i &lt; col; i++) cell = cell.right;
       return cell;
   }
//insertRow will first check to see if a row outside of the grid is provided.
//Next it will move down to the specified row number and create a new row and
//reset the links to weave the grid together again.	
   public boolean insertRow(int rownum) {
       if(rownum &gt; this.rows) return false;
       Node current = head;
       for(int i = 0; i &lt; rownum; i++, current = current.down);
       Node row = current.down = new Node();
       while((current = current.right) != null) {
           current.down = row.right = new Node();
           row = row.right;
       }
       return true;
   }
//insertCol will do similarly.  If a valid column number is specified, a loop
//will move to the specified column and create a string of nodes and
//repair the connections into a grid.	
   public boolean insertCol(int colnum) {
       if(colnum &gt; this.cols) return false;
       Node current = head;
       for(int i = 0; i &lt; colnum; i++, current = current.right);
       Node col = current.right = new Node();
       while((current = current.down) != null) {
           current.right = col.down = new Node();
           col = col.down;
       }
       return true;
   }
//delRow will move to the correct row and then reset connections so that the
//row provided will be picked up in garbage collection.	
   public boolean delRow(int rownum) {
       if(rownum &gt; this.rows || this.rows &lt;= 1) return false;
       Node current = head;
       for(int i = 0; i &lt; rownum-1; i++, current = current.down);
       do {
           current.down = current.down.down;
       } while((current = current.right) != null);
       this.rows--;
       return true;
   }
//delCol does the same thing as delRow except with the links which
//form a column.	
   public boolean delCol(int colnum) {
       if(colnum &gt; this.cols || this.cols &lt;= 1) return false;
       Node current = head;
       for(int i = 0; i &lt; colnum-1; i++, current = current.right);
       do {
           current.right = current.right.right;
       } while((current = current.down) != null);
       this.cols--;
       return true;
   }
//Fill takes coordinates specified by the user and fills the area
//enclosed by them with the specified value.	
   public void fill(int startrow, int endrow, int startcol, int endcol,
String value) {
       if(startrow &gt; 0 || startrow &lt; rows || startcol &gt; 0 || startcol &lt;
cols || endrow &gt; 0 || endrow &gt;= startrow ||
           endrow &lt; rows || endcol &gt; 0 || endcol &gt;= startcol || endcol
&lt; cols) {
           for(int i = startrow; i &lt;= endrow; i++)
               for(int j = startcol; j &lt;= endcol; j++)
                   getCell(i, j).value.setValue(value);
       }
   }
//Number will take the area specified and set the value of the cell to
//it's corresponding number starting from zero and working from left to right
//and top to bottom.	
   public void number(int startrow, int endrow, int startcol, int endcol) {
       if(startrow &gt; 0 || startrow &lt; rows || startcol &gt; 0 || startcol &lt;
cols || endrow &gt; 0 || endrow &gt;= startrow ||
           endrow &lt; rows || endcol &gt; 0 || endcol &gt;= startcol || endcol
&lt; cols) {
           int num = 0;
           for(int i = startrow; i &lt;= endrow; i++)
               for(int j = startcol; j &lt;= endcol; j++)
                   getCell(i, j).value.setValue(num++);
       }
   }
	
//The following is a collection of functions which will take specified
//input and run the arithmetic to find the rows or columns' sum, 
//difference, product, or quotient.	
   public void addRow(int startrow, int endrow, int destrow) {
       for(int i = 0; i &lt; cols; i++) {
           Value temp = getCell(startrow, i).value.plus(getCell(endrow,
i).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, i).value.setValue(temp);
       }
   }
   public void subRow(int startrow, int endrow, int destrow) {
       for(int i = 0; i &lt; cols; i++) {
           Value temp = getCell(startrow,
i).value.minus(getCell(endrow, i).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, i).value.setValue(temp);
       }
   }
   public void mulRow(int startrow, int endrow, int destrow) {
       for(int i = 0; i &lt; cols; i++) {
           Value temp = getCell(startrow,
i).value.times(getCell(endrow, i).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, i).value.setValue(temp);
       }
   }
   public void divRow(int startrow, int endrow, int destrow) {
       for(int i = 0; i &lt; cols; i++) {
           Value temp = getCell(startrow,
i).value.divideBy(getCell(endrow, i).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, i).value.setValue(temp);
       }
   }
   public void addCol(int startcol, int endcol, int destcol) {
       for(int i = 0; i &lt; rows; i++) {
           Value temp = getCell(i, startcol).value.plus(getCell(i,
endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(i, destcol).value.setValue(temp);
       }
   }
   public void subCol(int startcol, int endcol, int destcol) {
       for(int i = 0; i &lt; rows; i++) {
           Value temp = getCell(i, startcol).value.minus(getCell(i,
endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(i, destcol).value.setValue(temp);
       }
   }
   public void mulCol(int startcol, int endcol, int destcol) {
       for(int i = 0; i &lt; rows; i++) {
           Value temp = getCell(i, startcol).value.times(getCell(i,
endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(i, destcol).value.setValue(temp);
       }
   }
   public void divCol(int startcol, int endcol, int destcol) {
       for(int i = 0; i &lt; rows; i++) {
           Value temp = getCell(i, startcol).value.divideBy(getCell(i,
endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(i, destcol).value.setValue(temp);
       }
   }
   public void addNodes(int startrow, int endrow, int startcol, int
endcol, int destrow, int destcol) {
       if(startrow &gt; 0 || startrow &lt; rows || startcol &gt; 0 || startcol &lt;
cols || endrow &gt; 0 || endrow &gt;= startrow || endrow &lt; rows
          || endcol &gt; 0 || endcol &gt;= startcol || endcol &lt; cols ||
destrow &gt; 0 || destrow &lt; rows || destcol &gt; 0 || destcol &lt; cols) {
           Value temp =
getCell(startrow,startcol).value.plus(getCell(endrow,endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, destcol).value.setValue(temp);
       }
   }
   public void subNodes(int startrow, int endrow, int startcol, int
endcol, int destrow, int destcol) {
       if(startrow &gt; 0 || startrow &lt; rows || startcol &gt; 0 || startcol &lt;
cols || endrow &gt; 0 || endrow &gt;= startrow || endrow &lt; rows
           || endcol &gt; 0 || endcol &gt;= startcol || endcol &lt; cols ||
destrow &gt; 0 || destrow &lt; rows || destcol &gt; 0 || destcol &lt; cols) {
           Value temp =
getCell(startrow,startcol).value.minus(getCell(endrow,endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, destcol).value.setValue(temp);
       }
   }
   public void mulNodes(int startrow, int endrow, int startcol, int
endcol, int destrow, int destcol) {
       if(startrow &gt; 0 || startrow &lt; rows || startcol &gt; 0 || startcol &lt;
cols || endrow &gt; 0 || endrow &gt;= startrow || endrow &lt; rows
           || endcol &gt; 0 || endcol &gt;= startcol || endcol &lt; cols ||
destrow &gt; 0 || destrow &lt; rows || destcol &gt; 0 || destcol &lt; cols) {
           Value temp =
getCell(startrow,startcol).value.times(getCell(endrow,endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, destcol).value.setValue(temp);
       }
   }
   public void divNodes(int startrow, int endrow, int startcol, int
endcol, int destrow, int destcol) {
       if(startrow &gt; 0 || startrow &lt; rows || startcol &gt; 0 || startcol &lt;
cols || endrow &gt; 0 || endrow &gt;= startrow || endrow &lt; rows
           || endcol &gt; 0 || endcol &gt;= startcol || endcol &lt; cols ||
destrow &gt; 0 || destrow &lt; rows || destcol &gt; 0 || destcol &lt; cols) {
           Value temp =
getCell(startrow,startcol).value.divideBy(getCell(endrow,endcol).value);
           if(temp.getTag() != Value.TAG_INVALID)
               getCell(destrow, destcol).value.setValue(temp);
       }
   }
//display prints the grid with the default cell width of ten.
//I could not remember how to get the numbers to display without
//10 decimale places but I think that this is only a minor problem.	
   public void display() {
       System.out.print("       ");
       for(int i = 0; i &lt; cols; i++)
           System.out.format("%"+print_width+"s", "col "+i);
       System.out.println();
       for(int i = 0; i &lt; rows; i++) {
           System.out.format("%-"+print_width+"s  ", "row "+i);
           for(int j = 0; j &lt; cols; j++)
               System.out.format("%-"+print_width+"s", getCell(i, j));
           System.out.println();
       }
   }
}
[/code][br][size=1]Posted at: October 02, 2006, 01:08:38 PM[/size][hr]This should go in main:
[code]String[] cmds = new
String[]{"dis","as","f","n","a","s","m","d","ar","sr","mr","dr","ac","sc","mc","dc","ir","ic","delr","delc","q"};
       String[] options = new String[]{"display","assign
cell","fill","number","add cells","subtract cells","multiply
cells","divide cells",
                                       "add rows","subtract
rows","multiply rows","divide rows","add columns","subtract
columns","multiply columns",
                                       "divide columns","insert
row","insert column","delete row","delete column","quit"};
       int input = 0;
       Grid g = new Grid();
       Scanner kb = new Scanner(System.in);
       do {
           input = 0;
           System.out.println("Operations");
           for(int i = 0; i &lt; options.length-2; i+=2) {
               System.out.format("  %-18s %-4s    %-18s %-4s%n",
options[i], cmds[i], options[i+1], cmds[i+1]);
           }
           System.out.print("-&gt; ");
           String strinput = kb.nextLine();
           for(int i = 0; i &lt; cmds.length; i++)
               if(cmds[i].equals(strinput)) input = i;

           int startrow, startcol, endrow, endcol, destrow, destcol;
           switch(input) {
               case 0: //display
                   g.display();
                   break;
               case 1: //assign cell
                   System.out.print("row number: ");
                   startrow = endrow = kb.nextInt();
                   System.out.print("column number: ");
                   startcol = endcol = kb.nextInt();
                   System.out.print("with value: ");
                   strinput = kb.nextLine();
                   g.fill(startrow, endrow, startcol, endcol, strinput);
                   break;
               case 2: //fill
                   System.out.print("from row: ");
                   startrow = kb.nextInt();
                   System.out.print("from column: ");
                   startcol = kb.nextInt();
                   System.out.print("to row: ");
                   endrow = kb.nextInt();
                   System.out.print("to column: ");
                   endcol = kb.nextInt();
                   System.out.print("with value: ");
                   strinput = kb.nextLine();
                   g.fill(startrow, endrow, startcol, endcol, strinput);
                   break;
               case 3: //number
                   System.out.print("from row: ");
                   startrow = kb.nextInt();
                   System.out.print("from column: ");
                   startcol = kb.nextInt();
                   System.out.print("to row: ");
                   endrow = kb.nextInt();
                   System.out.print("to column: ");
                   endcol = kb.nextInt();
                   g.number(startrow, endrow, startcol, endcol);
                   break;
               case 4: //add cells
                   System.out.print("first node row: ");
                   startrow = kb.nextInt();
                   System.out.print("first node column: ");
                   startcol = kb.nextInt();
                   System.out.print("second node row: ");
                   endrow = kb.nextInt();
                   System.out.print("second node column: ");
                   endcol = kb.nextInt();
                   System.out.print("destination node row: ");
                   destrow = kb.nextInt();
                   System.out.print("destination node column: ");
                   destcol = kb.nextInt();
                   g.addNodes(startrow, endrow, startcol, endcol,
destrow, destcol);
                   break;
               case 5: //subtract cells
                   System.out.print("first node row: ");
                   startrow = kb.nextInt();
                   System.out.print("first node column: ");
                   startcol = kb.nextInt();
                   System.out.print("second node row: ");
                   endrow = kb.nextInt();
                   System.out.print("second node column: ");
                   endcol = kb.nextInt();
                   System.out.print("destination node row: ");
                   destrow = kb.nextInt();
                   System.out.print("destination node column: ");
                   destcol = kb.nextInt();
                   g.subNodes(startrow, endrow, startcol, endcol,
destrow, destcol);
                   break;
               case 6: //multiply cells
                   System.out.print("first node row: ");
                   startrow = kb.nextInt();
                   System.out.print("first node column: ");
                   startcol = kb.nextInt();
                   System.out.print("second node row: ");
                   endrow = kb.nextInt();
                   System.out.print("second node column: ");
                   endcol = kb.nextInt();
                   System.out.print("destination node row: ");
                   destrow = kb.nextInt();
                   System.out.print("destination node column: ");
                   destcol = kb.nextInt();
                   g.mulNodes(startrow, endrow, startcol, endcol,
destrow, destcol);
                   break;
               case 7: //divide cells
                   System.out.print("first node row: ");
                   startrow = kb.nextInt();
                   System.out.print("first node column: ");
                   startcol = kb.nextInt();
                   System.out.print("second node row: ");
                   endrow = kb.nextInt();
                   System.out.print("second node column: ");
                   endcol = kb.nextInt();
                   System.out.print("destination node row: ");
                   destrow = kb.nextInt();
                   System.out.print("destination node column: ");
                   destcol = kb.nextInt();
                   g.divNodes(startrow, endrow, startcol, endcol,
destrow, destcol);
                   break;
               case 8: //add rows
                   System.out.print("first row: ");
                   startrow = kb.nextInt();
                   System.out.print("second row: ");
                   endrow = kb.nextInt();
                   System.out.print("target row: ");
                   destrow = kb.nextInt();
                   g.addRow(startrow, endrow, destrow);
                   break;
               case 9: //subtract rows
                   System.out.print("first row: ");
                   startrow = kb.nextInt();
                   System.out.print("second row: ");
                   endrow = kb.nextInt();
                   System.out.print("target row: ");
                   destrow = kb.nextInt();
                   g.subRow(startrow, endrow, destrow);
                   break;
               case 10: //multiply rows
                   System.out.print("first row: ");
                   startrow = kb.nextInt();
                   System.out.print("second row: ");
                   endrow = kb.nextInt();
                   System.out.print("target row: ");
                   destrow = kb.nextInt();
                   g.mulRow(startrow, endrow, destrow);
                   break;
               case 11: //divide rows
                   System.out.print("first row: ");
                   startrow = kb.nextInt();
                   System.out.print("second row: ");
                   endrow = kb.nextInt();
                   System.out.print("target row: ");
                   destrow = kb.nextInt();
                   g.divRow(startrow, endrow, destrow);
                   break;
               case 12: //add columns
                   System.out.print("first column: ");
                   startcol = kb.nextInt();
                   System.out.print("second column: ");
                   endcol = kb.nextInt();
                   System.out.print("target column: ");
                   destcol = kb.nextInt();
                   g.addCol(startcol, endcol, destcol);
                   break;
               case 13: //subtract columns
                   System.out.print("first column: ");
                   startcol = kb.nextInt();
                   System.out.print("second column: ");
                   endcol = kb.nextInt();
                   System.out.print("target column: ");
                   destcol = kb.nextInt();
                   g.subCol(startcol, endcol, destcol);
                   break;
               case 14: //multiply columns
                   System.out.print("first column: ");
                   startcol = kb.nextInt();
                   System.out.print("second column: ");
                   endcol = kb.nextInt();
                   System.out.print("target column: ");
                   destcol = kb.nextInt();
                   g.mulCol(startcol, endcol, destcol);
                   break;
               case 15: //divide columns
                   System.out.print("first column: ");
                   startcol = kb.nextInt();
                   System.out.print("second column: ");
                   endcol = kb.nextInt();
                   System.out.print("target column: ");
                   destcol = kb.nextInt();
                   g.divCol(startcol, endcol, destcol);
                   break;
               case 16: //insert row
                   System.out.print("row to insert before: ");
                   startrow = kb.nextInt();
                   g.insertRow(startrow);
                   break;
               case 17: //insert column
                   System.out.print("column to insert before: ");
                   startcol = kb.nextInt();
                   g.insertCol(startcol);
                   break;
               case 18: //delete row
                   System.out.print("target row: ");
                   startrow = kb.nextInt();
                   g.delRow(startrow);
                   break;
               case 19: //delete column
                   System.out.print("target column: ");
                   startcol = kb.nextInt();
                   g.delCol(startcol);
                   break;
           }
       } while(input != cmds.length-1);
   }</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/11</link>
        <pubDate>Mon, 02 Oct 2006 23:12:54 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-11</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@Galook Galook]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/galook">@Galook</a> wrote:</p>
          <blockquote>
              <p>Nothing if you wanted it to be easier… but it isnt a program to be efficient, it seems to be more of a program to teach the student more about pointers… and data structures and what not.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/10</link>
        <pubDate>Thu, 21 Sep 2006 18:54:07 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-10</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@Stork Stork]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/stork">@Stork</a> wrote:</p>
          <blockquote>
              <p>What’s wrong with using a CellValue[][] (where CellValue can have a string or a double) with a JTable using a custom TableModel ?<br>
Sorry If I missed something.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/9</link>
        <pubDate>Thu, 21 Sep 2006 12:37:16 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-9</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@Galook Galook]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/galook">@Galook</a> wrote:</p>
          <blockquote>
              <p>i made it myself… i made a 4x4 pic first and just copy and pasted that 1, then drew the long arrows myself <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/8</link>
        <pubDate>Mon, 18 Sep 2006 06:30:20 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-8</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@iwasinmoparseas101cl iwasinmoparseas101class]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/iwasinmoparseas101cl">@iwasinmoparseas101cl</a> wrote:</p>
          <blockquote>
              <p>haha…nice picture galook <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:">  did it take you a while to make that yourself or did you copy and paste?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/7</link>
        <pubDate>Sun, 17 Sep 2006 21:01:47 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-7</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@crutex crutex]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/crutex">@crutex</a> wrote:</p>
          <blockquote>
              <p>I will try to work on this tomorrow.  I missed a few of my Java classes because I prioritized ECE above it, so I have a little bit to catch up one <img src="https://forum.moparisthebest.com/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:">  Thank you for your help guys I’ll let you know tomorrow how far I can get on this.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/6</link>
        <pubDate>Sat, 16 Sep 2006 13:04:05 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-6</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@Galook Galook]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/galook">@Galook</a> wrote:</p>
          <blockquote>
              <p>Your Grid(if visually imagined would look like this:<br>
<img src="http://img227.imageshack.us/img227/5117/gridhy5.png" alt width="" height=""><br>
“These functions work through much fussing with pointers and require a certain amount of care to code.”<br>
^^^^ that line assured me i was thinking rigth, and visually… your grid should look like that picture</p>
<pre><code class="lang-auto">public class Grid
{
    //hold the number of rows, columns, and how many 
    //characters long the print of each node should be
    private int rows, columns, printwidth;
    //the pointer to the top-right most node
    private Node head; 
    
    /*
     * Constructor for the Grid class, the parameters should fill 
     * in the rows and columns fields
     */
    public Gird(/* constructor parameters*/)
    {
        // make printwidth equal to 10 (instructions say to)
        
        // set the rows and columns fields
        
        /*
         * add your nodes to the head node, building mroe and 
         * more upon the grid
         */  
        
    }
    
    //addNode, subNode, divNode, mulNode functions
    
    //make methods to insert new nodes into the grid
    
    //make methods to add columns and rows to the grid
    
    //make methods to delete rows and columns
    
    //make number and fill methods
    /*#
     * the number method fills up a sub section of the grid
     * with a value given as a parameter, would look like this:
     * number(int x1, int y1, int x2, int y2)
     */
    
}</code></pre>
<p>^^ kind of like the basics of the grid class</p>
<pre><code class="lang-auto">public class Value
{
    private static final String DOUBLE = "DBL", STRING = "STRING";
    
    private String sval; // The value of the node if it holds a String
    private String tag; /*# this is used to determine whether the node holds a double
                             or a String */
    private double dval; // The value of the node if it holds a double
    
    public Value()
    {
        /*
         * put in the default values for your fields:
         * sval is equal to an empty String
         * dval is equal to 0.0, and
         * tag is equal to "STRING"
         */
    }
    public Value(String value) 
    {
        /*
         * check to see if the first character of value is
         * a double quote character("), if it is, fill in
         * your sval field with the rest of the value string
         * after the (") mark, fill in the tag as STRING,
         * and fill in the default value(0.0) for dval;
         * 
         * if it is not, fill in dval using Double.parseDouble(),
         * fill in the tag as DBL, and fill in the default value
         * (an empty String) in sval
         */
    }  
    // your add, multiply, divide, and subtract methods
}   </code></pre>
<p>^^^ The basic part of the Value class</p>
<p>[code]<br>
public class Node<br>
{<br>
/*<br>
* have the Node values that point to the right Node<br>
* and the bottom Node<br>
*/</p>
<pre><code>// have the Value of the node stored here
</code></pre>
<p>}[/code]<br>
^^^^ the basic Node class to hold the pointers to the other nodes</p>
<hr>
<p>If that doesnt help you still, then I’ll fill it in mroe with code rather than comments, but I really don’t like giving the answers all the way without having the person think first</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/5</link>
        <pubDate>Sat, 16 Sep 2006 11:57:20 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-5</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@BobDole81 BobDole81]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/bobdole81">@BobDole81</a> wrote:</p>
          <blockquote>
              <p>[quote=“1337h4x, post:2, topic:14587”]Try a JTable? Search java swing JTable. I think that’s what you’re looking for.[/quote]I think he’s more concerned with the data structure portion than the ui.</p>
<p>If I follow correctly, you could easily use a single LinkedList to store each node…here’s something like what I’m thinking of:</p>
<pre><code class="lang-auto">// Definitions of the grid
final int gridRows = 10;
final int gridColumns = 6;

// ...

List&lt;Value&gt; gridValues = new LinkedList&lt;Value&gt;();
for(int i = 0; i &lt; gridRows; i++) {
    for(int j = 0; j &lt; gridColumns; j++) {
        Value gridNode = new Value(i, j); // Assuming its parameters just includes it location
        gridList.add(gridNode);

        // Add references
    }
}</code></pre>
<p>As for references, you can grab the Value object left of the newly created node in the loop and set its right reference to this new node (or if its the last element, then the node at index 0) and the Value above (assuming i &gt; 0) and set its down reference to this node…</p>
<p>Hope that made some sense and its what you needed.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/4</link>
        <pubDate>Sat, 16 Sep 2006 10:32:59 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-4</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@iwasinmoparseas101cl iwasinmoparseas101class]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/iwasinmoparseas101cl">@iwasinmoparseas101cl</a> wrote:</p>
          <blockquote>
              <p>you could try creating a 2-D array, filling it with some Linked Nodes, and then just set the currentNode.next to be the arrayObject[i][j];</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/3</link>
        <pubDate>Sat, 16 Sep 2006 09:53:59 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-3</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@1337h4x 1337h4x]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/1337h4x">@1337h4x</a> wrote:</p>
          <blockquote>
              <p>Try a JTable? Search java swing JTable. I think that’s what you’re looking for.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/2</link>
        <pubDate>Sat, 16 Sep 2006 08:03:39 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-2</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
      <item>
        <title>Creating a grid using linked nodes</title>
        <dc:creator><![CDATA[@crutex crutex]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/crutex">@crutex</a> wrote:</p>
          <blockquote>
              <p>I have an assignment where the objective is to create a grid composed of 10 rows and 6 columns, where each cell can hold a String or Double.  Operations will be provided which display the grid, assign values to the cells, do arithmetic on cells, do arithmetic on rows and columns, fill cells with values, insert, delete, and move rows and columns. The default value for all cells is an empty string.<br>
The following are the guidelines and sample outputs:</p>
<blockquote>Data structures
<p>Each cell in the grid will be represented by a Node (a class) with a Value field and two pointer (i.e. reference) fields, right and down. The right pointers will be used to link the nodes into rows and the down pointers will link the nodes into columns. Each row will be linked as a circle (the right field of the final node in each row will point to the first node in the row) as will each column (the down pointer of the bottom node pointing to the top node of the column).</p>
<p>A Value is represented as a class with three fields: a double field, dval, to hold numeric values, a String field, sval, for character strings, and a tag field which indicates whether the Value is currently a number or string (or is invalid). Arithmetic (+, -, *, and /) can be performed on Values.</p>
<p>The grid itself will be an instance of a Grid class. This class will have integer fields for the number of rows, number of columns, and the print width (for displaying a cell). Use the value 10 for print width. It will have a head field which points to the first node of the grid (at row 0, column 0). A constructor and a number of public member functions for the grid operations will be written.<br>
Internals</p>
<p>After the (number of rows) × (number of columns) nodes have been created and linked together by the constructor for Grid all access to nodes will be done through pointer operations beginning at head.<br>
Values</p>
<p>The Value class represents the values that can be stored in the nodes. A value can be either a double or a string. A separate data field is provided for each so it is possible for a “Value” to contain both a double and a string. The tag field indicates which of these data fields holds the “real value” of the Value. A Value can also have an “INVALID” tag. This tag value is only used for (some) intermediate results in arithmetic and a Value with an INVALID tag is never stored in a node. Values are constructed with tag STRING, dval 0, and sval an empty string.</p>
<p>Arithmetic can be done on Values with the operators plus, minus, star, and slash. Each of these will be implemented as a method of the Value class taking a Value as parameter. The operators will first check to see if the tags of both operands are DBL. If not no arithmetic is performed and the tag of the resulting Value is set to INVALID. Otherwise the sum, product, etc., is computed and the result stored in the dval field of the resulting Value. The tag is set to DBL.</p>
<p>You will write a toString method for Value. Notice that you do not know whether the input will be a double or a string until after it has been entered. To resolve this problem accept the input as a String and check the first character. If it is a double quote mark (") it is a string and copy it (after allocating memory) without the quote mark to the sval field. Otherwise the input is intended as a double. In this case convert it to a double with Double.parseDouble and store the result in the dval field.<br>
The Grid class</p>
<p>The Grid class has member functions to print the grid, to do arithmetic on the cells, to insert and delete rows and columns, and to assign values to the cells.</p>
<p>The display member function will display the grid. Each cell will be displayed in a field of print_width characters. The row and column numbers will be displayed.<br>
Grid arithmetic</p>
<p>Arithmetic can be done on individual cells with addNodes, subNodes, mulNodes, and divNodes member functions. Other member functions perform arithmetic on entire rows (addRows, etc.) or columns (addCols, etc.) at a time. In all cases once you have located the nodes to be operated on you can just “add,” etc., the Values and assign Values without accessing the Value’s data fields or checking tags by simply using the arithmetic methods from Value.<br>
Inserting and deleting nodes</p>
<p>Entire rows and columns can be inserted into the grid using insertRow and insertCol. Rows and columns can be deleted using deleteRow and deleteCol. These functions work through much fussing with pointers and require a certain amount of care to code.<br>
Assigning Values to cells</p>
<p>Two member functions assign values to cells: number and fill. number requires the row and column numbers of two grid cells. These define a rectangular “subgrid” having these two grid cells as corners. number will assign the numbers 0, 1, 2, etc. (as doubles) to these cells. fill is similar but it puts the same Value (passed as a parameter) in the node representing each cell.</p>
<p>Notice that fill can be used to assign a value to a single cell.<br>
Validation</p>
<p>For all methods the parameter values must be validated. Each row and column number must be in the correct range (between 0 and Grid.rows-1 and between 0 and Grid.cols-1 respectively). If two row/column pairs are used to define a subgrid (as with number and fill) the first pair cannot follow the second (but they can be the same). The delRow and delCol functions must not reduce the grid to an empty grid (there must always be at least one row and one column in the grid). Member functions which do division must check for zero divisors. If a zero divisor is found and error message is displayed and the division is not performed. Any other validations needed for the member functions to make sense must be done.</p>
</blockquote>
<blockquote>                    col 0     col 1     col 2     col 3     col 4     col 5     
          row 0     0         1         2         3         4         5         
          row 1     6         7         8         9         10        11        
          row 2     12        13        14        15        16        17        
          row 3     18        19        20        21        22        23        
          row 4     24        25        26        27        28        29        
          row 5     30        31        32        33        34        35        
          row 6     36        37        38        39        40        41        
          row 7     42        43        44        45        46        47        
          row 8     48        49        50        51        52        53        
          row 9     54        55        56        57        58        59 </blockquote>
<p>I am having trouble getting my feet off of the ground, and would appreciate some help from a more proficient Java coder.  Basically what I have right now is a simple Linked list which will create a row of empty nodes.  I am not quite sure how I will connect the nodes to form a grid.  Should I be using Circular linked lists instead?  How can I connect nodes into a grid form?  Thank you for your attention.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587/1</link>
        <pubDate>Sat, 16 Sep 2006 06:11:45 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-14587-1</guid>
        <source url="https://forum.moparisthebest.com/t/creating-a-grid-using-linked-nodes/14587.rss">Creating a grid using linked nodes</source>
      </item>
  </channel>
</rss>
