<!DOCTYPE html>
<html lang="en-US">
  
<!-- Mirrored from forum.moparisthebest.com/t/door-snippet/528104 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 04 Aug 2019 15:48:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>Door Snippet - Runescape - moparisthebest.com</title>
    <meta name="description" content="Door handling in a majority of sources, in my opinion, is done wrong. Here&amp;#39;s a snippet of what you could do. Allows you to stop door spamming, and also is much simpler. 

Steps:  

Assuming you have all the objects in me&amp;hellip;">
    <meta name="generator" content="Discourse 2.3.2 - https://github.com/discourse/discourse version c587df7e2a03c2962f4c8cefd6f03969bb87d525">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/1/1f0dc167bcf798bdbd70b03bf0fd1bc836e54e1a_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff_2_180x180.png">
<meta name="theme-color" content="#0088cc">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="528104.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.moparisthebest.com","potentialAction":{"@type":"SearchAction","target":"https://forum.moparisthebest.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="moparisthebest.com Search">

      <link href="../../stylesheets/desktop_1_ec9f75e3d0b2a904642ce53663991837b70cda3334fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="../../stylesheets/desktop_theme_2_6707e7ee46ac9f2f0510c29ddd10e8f6ce21c1ae34fc.css?__ws=forum.moparisthebest.com" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
      <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;Door Snippet&#39;" href="528104.rss" />
  <meta property="og:site_name" content="moparisthebest.com" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:image" content="https://forum.moparisthebest.com/uploads/default/original/2X/4/41fecb6185fddc2758aeba68c3f8c9c78e26e4ff.png" />
<meta property="og:url" content="https://forum.moparisthebest.com/t/door-snippet/528104" />
<meta name="twitter:url" content="https://forum.moparisthebest.com/t/door-snippet/528104" />
<meta property="og:title" content="Door Snippet" />
<meta name="twitter:title" content="Door Snippet" />
<meta property="og:description" content="Door handling in a majority of sources, in my opinion, is done wrong. Here’s a snippet of what you could do. Allows you to stop door spamming, and also is much simpler.  Steps:  Assuming you have all the objects in memory (I do, don’t judge), iterate through all of them.  If one of the object matches a door objects, then create a door at that position + the position of the hidden objects.  Create the hidden objects, and then like a light switch hide and show the proper objects when a door is ope..." />
<meta name="twitter:description" content="Door handling in a majority of sources, in my opinion, is done wrong. Here’s a snippet of what you could do. Allows you to stop door spamming, and also is much simpler.  Steps:  Assuming you have all the objects in memory (I do, don’t judge), iterate through all of them.  If one of the object matches a door objects, then create a door at that position + the position of the hidden objects.  Create the hidden objects, and then like a light switch hide and show the proper objects when a door is ope..." />
<meta property="article:published_time" content="2013-08-14T17:58:27+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="../../index.html">
          <img src="../../uploads/default/original/2X/3/37bba8fb3bd06c372ab54fa72ec38bf9f8f40b37.gif" alt="moparisthebest.com" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
      <h1 class="crawler-topic-title">
  <a href="528104.html">Door Snippet</a>
</h1>

<div id='breadcrumbs'>
    <div id="breadcrumb-0" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
        itemref="breadcrumb-1"
      >
      <a href="../../c/games.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>Games</span>
      </a>
    </div>
    <div id="breadcrumb-1" itemscope itemtype="http://data-vocabulary.org/Breadcrumb"
>
      <a href="../../c/games/runescape.html" itemprop="url" class='badge-wrapper bullet'>
        <span class="badge-category-bg"></span>
        <span itemprop="title" class='category-title'>Runescape</span>
      </a>
    </div>
</div>





  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/sinisoul.html'><span itemprop='name'>sinisoul</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2013-08-14T17:58:27Z'>
            <time itemprop='dateModified' datetime='2016-08-04T10:10:18Z' class='post-time'>
              August 4, 2016, 10:10am
            </time>
        <span itemprop='position'>#1</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Door handling in a majority of sources, in my opinion, is done wrong. Here’s a snippet of what you could do. Allows you to stop door spamming, and also is much simpler.</p>
<p>Steps:</p>
<p>Assuming you have all the objects in memory (I do, don’t judge), iterate through all of them.<br>
If one of the object matches a door objects, then create a door at that position + the position of the hidden objects.<br>
Create the hidden objects, and then like a light switch hide and show the proper objects when a door is opened.</p>
<pre><code class="lang-auto"># TODO: May not be valid to set the type in the way I have

java_import 'net.scapeemulator.game.model.World'
java_import 'net.scapeemulator.game.model.object.ObjectOrientation'
java_import 'net.scapeemulator.game.model.object.GroundObjectListenerAdapter'
java_import 'net.scapeemulator.game.model.object.ObjectType'
java_import 'net.scapeemulator.game.model.Position'
java_import 'net.scapeemulator.game.model.Door'

module RuneEmulator
	class Doors

		# The worlds object list to grab objects from
		OBJECT_LIST = World::getWorld().getGroundObjects()

		# States for if the door is opened or closed
		OPENED = 0
		CLOSED = 1

		# Each of the orientations
		ORIENTATION_ONE   = 1
		ORIENTATION_TWO   = 2
		ORIENTATION_THREE = 3
		ORIENTATION_FOUR  = 4

		# The mapping for all the single doors
		SINGLE_DOORS = {}

		# The mapping for all the doors registered
		DOORS = {}

		# The array of objects to add to the object list after a refresh
		OBJECTS = []

		class &lt;&lt; self
			def bind_door(opened_obj_id, closed_obj_id)
				DoorData.new(opened_obj_id, closed_obj_id).bind
			end

			def create_door(object)
				data = SINGLE_DOORS[object.id]

				raise "Data does not exist for door, id: #{object.id}" if data == nil

				state       = data.state(object.id)
				orientation = data.get_orientation(object.rotation, state)
				origin      = data.get_origin(object.position, object.rotation, state)

				objects = {}

				[ :opened, :closed ].each { |type|
					object = objects[type] = data.get_object(origin, orientation, type)
					OBJECTS &lt;&lt; object
				}

				SingleTileDoor.new(objects[:opened], objects[:closed]).bind
			end

			def refresh()
				OBJECT_LIST.fire_all_events(DoorObjectListener.new)

				OBJECTS.each { |object|
					object.register
				}
			end
		end

		class ObjectProxy
			attr_reader :id, :position, :rotation, :type

			def initialize(args)
				case args.size
				when 1
					@target = args[:target]
				when 4
					@id       = args[:id]
					@position = args[:position]
					@rotation = args[:rotation]
					@type     = args[:type]
				else
					raise 'Invalid constructor sent to object proxy'
				end
			end

			def register()
				if @target == nil
					@target = OBJECT_LIST.put(@position, @id, @rotation, @type)
					#@target.hide
				end
			end

			def hide()
				@target.hide
			end

			def reveal()
				@target.reveal
			end
		end

		class DoorData

			# Each of the orientations
			# Orientation One: North, Orientation Two: South, Orientation Three: East, Orientation Four: West
			ORIENTATIONS = { ORIENTATION_ONE   =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 1 }, :opened =&gt; { :x =&gt;  0, :y =&gt;  1, :rotation =&gt; 2 } }, 
			                 ORIENTATION_TWO   =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 3 }, :opened =&gt; { :x =&gt;  0, :y =&gt; -1, :rotation =&gt; 0 } }, 
			                 ORIENTATION_THREE =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 2 }, :opened =&gt; { :x =&gt;  1, :y =&gt;  0, :rotation =&gt; 3 } }, 
			                 ORIENTATION_FOUR  =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 0 }, :opened =&gt; { :x =&gt; -1, :y =&gt;  0, :rotation =&gt; 1 } } 
			               }

			def initialize(opened_obj_id, closed_obj_id)
				@opened_obj_id = opened_obj_id
				@closed_obj_id = closed_obj_id
			end

			def get_origin(position, rotation, state)
				delta = { :x =&gt; 0, :y =&gt; 0 }

				case state
				when OPENED
					case rotation
					when ObjectOrientation::NORTH
						delta[:x] =  1
					when ObjectOrientation::SOUTH
						delta[:x] = -1
					when ObjectOrientation::EAST
						delta[:y] = -1	
					when ObjectOrientation::WEST
						delta[:y] =  1
					end
				end

				Position.new(position.x + delta[:x], position.y + delta[:y], position.height)
			end

			def get_orientation(rotation, state)
				case state
				when OPENED				
					case rotation
					when ObjectOrientation::NORTH
						ORIENTATIONS[ORIENTATION_FOUR]
					when ObjectOrientation::SOUTH
						ORIENTATIONS[ORIENTATION_THREE]			
					when ObjectOrientation::EAST
						ORIENTATIONS[ORIENTATION_ONE]
					when ObjectOrientation::WEST
						ORIENTATIONS[ORIENTATION_TWO]
					end
				when CLOSED
					case rotation
					when ObjectOrientation::NORTH
						ORIENTATIONS[ORIENTATION_ONE]
					when ObjectOrientation::SOUTH
						ORIENTATIONS[ORIENTATION_TWO]					
					when ObjectOrientation::EAST
						ORIENTATIONS[ORIENTATION_THREE]
					when ObjectOrientation::WEST
						ORIENTATIONS[ORIENTATION_FOUR]
					end
				end
			end

			def get_object(origin, orientation, type)
				case type
				when :opened
					position = Position.new(origin.x + orientation[:opened][:x], origin.y + orientation[:opened][:y], origin.height)
					if OBJECT_LIST.contains(@opened_obj_id, position)
						args = { :target =&gt; OBJECT_LIST.get(@opened_obj_id, position) }
						ObjectProxy.new(args)
					else
						args = { :id =&gt; @opened_obj_id, :position =&gt; position, :rotation =&gt; orientation[:opened][:rotation], :type =&gt; ObjectType::TYPE_0 }
						ObjectProxy.new(args)
					end
				when :closed
					position = Position.new(origin.x + orientation[:closed][:x], origin.y + orientation[:closed][:y], origin.height)
					if OBJECT_LIST.contains(@closed_obj_id, position)
						args = { :target =&gt; OBJECT_LIST.get(@closed_obj_id, position) }
						ObjectProxy.new(args)
					else
						args = { :id =&gt; @closed_obj_id, :position =&gt; position, :rotation =&gt; orientation[:closed][:rotation], :type =&gt; ObjectType::TYPE_0 }
						ObjectProxy.new(args)
					end
				end
			end

			def state(object_id)
				{ @opened_obj_id =&gt; OPENED, @closed_obj_id =&gt; CLOSED }.fetch(object_id)
			end

			def bind()
				SINGLE_DOORS[@opened_obj_id] = self
				SINGLE_DOORS[@closed_obj_id] = self
			end
		end

		class DoubleDoorData
			def initialize(opened_ldoor_obj_id, opened_rdoor_obj_id, closed_ldoor_obj_id, closed_rdoor_obj_id)
				@opened_ldoor_obj_id = opened_ldoor_obj_id
				@opened_rdoor_obj_id = opened_rdoor_obj_id
				@closed_ldoor_obj_id = closed_ldoor_obj_id
				@closed_rdoor_obj_id = closed_rdoor_obj_id
			end

			def get_object(origin, orientation, type)
			end

			def state(object_id)
				{ @opened_ldoor_obj_id =&gt; OPENED, @opened_rdoor_obj_id =&gt; OPENED, 
			      @closed_ldoor_obj_id =&gt; CLOSED, @closed_rdoor_obj_id =&gt; CLOSED }.fetch(object_id)
			end
		end

		class GateData
			def initialize(opened_lgate_obj_id, opened_rgate_obj_id, closed_lgate_obj_id, closed_rgate_obj_id)
				@opened_lgate_obj_id = opened_lgate_obj_id
				@opened_rgate_obj_id = opened_rgate_obj_id
				@closed_lgate_obj_id = closed_lgate_obj_id
				@closed_rgate_obj_id = closed_rgate_obj_id
			end

			def get(type)
			end

			def state(object_id)
				{ @opened_lgate_obj_id =&gt; OPENED, @opened_rgate_obj_id =&gt; OPENED, 
			      @closed_lgate_obj_id =&gt; CLOSED, @closed_rgate_obj_id =&gt; CLOSED }.fetch(object_id)
			end
		end

		class SingleTileDoor &lt; Door
			def initialize(opened_door, closed_door)
				super()
				@opened_door = opened_door
				@closed_door = closed_door
			end

			def open()
				@opened_door.reveal
				@closed_door.hide
			end

			def close()
				@opened_door.hide
				@closed_door.reveal
			end

			def bind()
				DOORS[@opened_door.position] = @opened_door
				DOORS[@closed_door.position] = @closed_door
			end
		end

		class DoubleTileDoor &lt; Door
			def initialize(opened_left, opened_right, closed_left, closed_right)
				super()
				@opened_left  = opened_left
				@opened_right = opened_right
				@closed_left  = closed_left
				@closed_right = closed_right
			end

			def open()
				@opened_left.reveal
				@opened_right.reveal
				@closed_left.hide
				@closed_right.hide
			end

			def close()
				@opened_left.hide
				@opened_right.hide
				@closed_left.reveal
				@closed_right.reveal
			end

			def bind()
				DOORS[@opened_left.position]  = self
				DOORS[@opened_right.position] = self
				DOORS[@closed_left.position]  = self
				DOORS[@closed_right.position] = self
			end
		end

		class DoorObjectListener &lt; GroundObjectListenerAdapter
			def groundObjectAdded(object)
				if SINGLE_DOORS.include?(object.id)
					Doors.create_door(object)
				end
			end
		end
	end
end

RuneEmulator::Doors.bind_door(36848, 36846)
RuneEmulator::Doors.refresh()</code></pre>
      </div>

      <meta itemprop='headline' content='Door Snippet'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/sspoke.html'><span itemprop='name'>sspoke</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2013-08-14T19:21:41Z'>
            <time itemprop='dateModified' datetime='2016-08-04T10:10:31Z' class='post-time'>
              August 4, 2016, 10:10am
            </time>
        <span itemprop='position'>#2</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>Is it possible to predict how the doors rotation will look opened or closed without making a doors.cfg file for all doors orientations</p>
      </div>

      <meta itemprop='headline' content='Door Snippet'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/sinisoul.html'><span itemprop='name'>sinisoul</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2013-08-14T19:45:02Z'>
            <time itemprop='dateModified' datetime='2016-08-04T10:10:32Z' class='post-time'>
              August 4, 2016, 10:10am
            </time>
        <span itemprop='position'>#3</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <aside class="quote" data-post="2" data-topic="528104">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="../../letter_avatar/sspoke/40/5_e05bb34c421432ee4d40de30c10af3e5.png" class="avatar"> sspoke:</div>
<blockquote>
<p>Is it possible to predict how the doors rotation will look opened or closed without making a doors.cfg file for all doors orientations</p>
</blockquote>
</aside>
<p>Single tile doors only open outward, double tile doors only open *outward, gates open counter clockwise.</p>
      </div>

      <meta itemprop='headline' content='Door Snippet'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/arham_4.html'><span itemprop='name'>arham_4</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2013-08-14T20:10:22Z'>
            <time itemprop='dateModified' datetime='2016-08-04T10:10:35Z' class='post-time'>
              August 4, 2016, 10:10am
            </time>
        <span itemprop='position'>#4</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>This is Ruby or…?</p>
      </div>

      <meta itemprop='headline' content='Door Snippet'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/sinisoul.html'><span itemprop='name'>sinisoul</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2013-08-16T09:34:23Z'>
            <time itemprop='dateModified' datetime='2016-08-04T10:12:10Z' class='post-time'>
              August 4, 2016, 10:12am
            </time>
        <span itemprop='position'>#5</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <aside class="quote quote-modified" data-post="4" data-topic="528104">
<div class="title">
<div class="quote-controls"></div>
 arham 4:</div>
<blockquote>
<p>This is Ruby or…?</p>
</blockquote>
</aside>
<p><img src="../../images/emoji/twitter/expressionlessae52.png?v=5" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
<pre><code class="lang-auto"># TODO: May not be valid to set the type in the way I have

java_import 'net.scapeemulator.game.model.World'
java_import 'net.scapeemulator.game.model.object.ObjectOrientation'
java_import 'net.scapeemulator.game.model.object.GroundObjectListenerAdapter'
java_import 'net.scapeemulator.game.model.object.ObjectType'
java_import 'net.scapeemulator.game.model.Position'
java_import 'net.scapeemulator.game.model.Door'

module RuneEmulator
	class Doors

		# The worlds object list to grab objects from
		OBJECT_LIST = World::getWorld().getGroundObjects()

		# States for if the door is opened or closed
		OPENED = 0
		CLOSED = 1

		# Each of the orientations
		ORIENTATION_ONE   = 1
		ORIENTATION_TWO   = 2
		ORIENTATION_THREE = 3
		ORIENTATION_FOUR  = 4

		# The mapping for all the single doors
		SINGLE_DOORS = {}

		# The mapping for all the doors registered
		DOORS = {}

		# The array of objects to add to the object list after a refresh
		OBJECTS = []

		class &lt;&lt; self
			def bind_door(opened_obj_id, closed_obj_id)
				DoorData.new(opened_obj_id, closed_obj_id).bind
			end

			def create_door(object)
				data = SINGLE_DOORS[object.id]

				raise "Data does not exist for door, id: #{object.id}" if data == nil

				state       = data.state(object.id)
				orientation = data.get_orientation(object.rotation, state)
				origin      = data.get_origin(object.position, object.rotation, state)

				objects = {}

				[ :opened, :closed ].each { |type|
					object = objects[type] = data.get_object(origin, orientation, type)
					OBJECTS &lt;&lt; object
				}

				SingleTileDoor.new(objects[:opened], objects[:closed]).bind
			end

			def refresh()
				OBJECT_LIST.fire_all_events(DoorObjectListener.new)

				OBJECTS.each { |object|
					object.register
				}
			end
		end

		class ObjectProxy
			attr_reader :id, :position, :rotation, :type

			def initialize(args)
				case args.size
				when 1
					@target = args[:target]
				when 4
					@id       = args[:id]
					@position = args[:position]
					@rotation = args[:rotation]
					@type     = args[:type]
				else
					raise 'Invalid constructor sent to object proxy'
				end
			end

			def register()
				if @target == nil
					@target = OBJECT_LIST.put(@position, @id, @rotation, @type)
					#@target.hide
				end
			end

			def hide()
				@target.hide
			end

			def reveal()
				@target.reveal
			end
		end

		class DoorData

			# Each of the orientations
			# Orientation One: North, Orientation Two: South, Orientation Three: East, Orientation Four: West
			ORIENTATIONS = { ORIENTATION_ONE   =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 1 }, :opened =&gt; { :x =&gt;  0, :y =&gt;  1, :rotation =&gt; 2 } }, 
			                 ORIENTATION_TWO   =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 3 }, :opened =&gt; { :x =&gt;  0, :y =&gt; -1, :rotation =&gt; 0 } }, 
			                 ORIENTATION_THREE =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 2 }, :opened =&gt; { :x =&gt;  1, :y =&gt;  0, :rotation =&gt; 3 } }, 
			                 ORIENTATION_FOUR  =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 0 }, :opened =&gt; { :x =&gt; -1, :y =&gt;  0, :rotation =&gt; 1 } } 
			               }

			def initialize(opened_obj_id, closed_obj_id)
				@opened_obj_id = opened_obj_id
				@closed_obj_id = closed_obj_id
			end

			def get_origin(position, rotation, state)
				delta = { :x =&gt; 0, :y =&gt; 0 }

				case state
				when OPENED
					case rotation
					when ObjectOrientation::NORTH
						delta[:x] =  1
					when ObjectOrientation::SOUTH
						delta[:x] = -1
					when ObjectOrientation::EAST
						delta[:y] = -1	
					when ObjectOrientation::WEST
						delta[:y] =  1
					end
				end

				Position.new(position.x + delta[:x], position.y + delta[:y], position.height)
			end

			def get_orientation(rotation, state)
				case state
				when OPENED				
					case rotation
					when ObjectOrientation::NORTH
						ORIENTATIONS[ORIENTATION_FOUR]
					when ObjectOrientation::SOUTH
						ORIENTATIONS[ORIENTATION_THREE]			
					when ObjectOrientation::EAST
						ORIENTATIONS[ORIENTATION_ONE]
					when ObjectOrientation::WEST
						ORIENTATIONS[ORIENTATION_TWO]
					end
				when CLOSED
					case rotation
					when ObjectOrientation::NORTH
						ORIENTATIONS[ORIENTATION_ONE]
					when ObjectOrientation::SOUTH
						ORIENTATIONS[ORIENTATION_TWO]					
					when ObjectOrientation::EAST
						ORIENTATIONS[ORIENTATION_THREE]
					when ObjectOrientation::WEST
						ORIENTATIONS[ORIENTATION_FOUR]
					end
				end
			end

			def get_object(origin, orientation, type)
				case type
				when :opened
					position = Position.new(origin.x + orientation[:opened][:x], origin.y + orientation[:opened][:y], origin.height)
					if OBJECT_LIST.contains(@opened_obj_id, position)
						args = { :target =&gt; OBJECT_LIST.get(@opened_obj_id, position) }
						ObjectProxy.new(args)
					else
						args = { :id =&gt; @opened_obj_id, :position =&gt; position, :rotation =&gt; orientation[:opened][:rotation], :type =&gt; ObjectType::TYPE_0 }
						ObjectProxy.new(args)
					end
				when :closed
					position = Position.new(origin.x + orientation[:closed][:x], origin.y + orientation[:closed][:y], origin.height)
					if OBJECT_LIST.contains(@closed_obj_id, position)
						args = { :target =&gt; OBJECT_LIST.get(@closed_obj_id, position) }
						ObjectProxy.new(args)
					else
						args = { :id =&gt; @closed_obj_id, :position =&gt; position, :rotation =&gt; orientation[:closed][:rotation], :type =&gt; ObjectType::TYPE_0 }
						ObjectProxy.new(args)
					end
				end
			end

			def state(object_id)
				{ @opened_obj_id =&gt; OPENED, @closed_obj_id =&gt; CLOSED }.fetch(object_id)
			end

			def bind()
				SINGLE_DOORS[@opened_obj_id] = self
				SINGLE_DOORS[@closed_obj_id] = self
			end
		end

		class DoubleDoorData
			def initialize(opened_ldoor_obj_id, opened_rdoor_obj_id, closed_ldoor_obj_id, closed_rdoor_obj_id)
				@opened_ldoor_obj_id = opened_ldoor_obj_id
				@opened_rdoor_obj_id = opened_rdoor_obj_id
				@closed_ldoor_obj_id = closed_ldoor_obj_id
				@closed_rdoor_obj_id = closed_rdoor_obj_id
			end

			def get_object(origin, orientation, type)
			end

			def state(object_id)
				{ @opened_ldoor_obj_id =&gt; OPENED, @opened_rdoor_obj_id =&gt; OPENED, 
			      @closed_ldoor_obj_id =&gt; CLOSED, @closed_rdoor_obj_id =&gt; CLOSED }.fetch(object_id)
			end
		end

		class GateData
			def initialize(opened_lgate_obj_id, opened_rgate_obj_id, closed_lgate_obj_id, closed_rgate_obj_id)
				@opened_lgate_obj_id = opened_lgate_obj_id
				@opened_rgate_obj_id = opened_rgate_obj_id
				@closed_lgate_obj_id = closed_lgate_obj_id
				@closed_rgate_obj_id = closed_rgate_obj_id
			end

			def get(type)
			end

			def state(object_id)
				{ @opened_lgate_obj_id =&gt; OPENED, @opened_rgate_obj_id =&gt; OPENED, 
			      @closed_lgate_obj_id =&gt; CLOSED, @closed_rgate_obj_id =&gt; CLOSED }.fetch(object_id)
			end
		end

		class SingleTileDoor &lt; Door
			def initialize(opened_door, closed_door)
				super()
				@opened_door = opened_door
				@closed_door = closed_door
			end

			def open()
				@opened_door.reveal
				@closed_door.hide
			end

			def close()
				@opened_door.hide
				@closed_door.reveal
			end

			def bind()
				DOORS[@opened_door.position] = @opened_door
				DOORS[@closed_door.position] = @closed_door
			end
		end

		class DoubleTileDoor &lt; Door
			def initialize(opened_left, opened_right, closed_left, closed_right)
				super()
				@opened_left  = opened_left
				@opened_right = opened_right
				@closed_left  = closed_left
				@closed_right = closed_right
			end

			def open()
				@opened_left.reveal
				@opened_right.reveal
				@closed_left.hide
				@closed_right.hide
			end

			def close()
				@opened_left.hide
				@opened_right.hide
				@closed_left.reveal
				@closed_right.reveal
			end

			def bind()
				DOORS[@opened_left.position]  = self
				DOORS[@opened_right.position] = self
				DOORS[@closed_left.position]  = self
				DOORS[@closed_right.position] = self
			end
		end

		class DoorObjectListener &lt; GroundObjectListenerAdapter
			def groundObjectAdded(object)
				if SINGLE_DOORS.include?(object.id)
					Doors.create_door(object)
				end
			end
		end
	end
end

RuneEmulator::Doors.bind_door(36848, 36846)
RuneEmulator::Doors.refresh()</code></pre>
<p>Heres a much CLEANER version.</p>
      </div>

      <meta itemprop='headline' content='Door Snippet'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="1" />
        </div>


  </div>
  <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
      <div class='crawler-post-meta'>
        <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a itemprop="url" href='../../u/arham_4.html'><span itemprop='name'>arham_4</span></a>
          
        </span>

        <span class="crawler-post-infos">
            <meta itemprop='datePublished' content='2013-08-16T17:24:37Z'>
            <time itemprop='dateModified' datetime='2016-08-04T10:12:18Z' class='post-time'>
              August 4, 2016, 10:12am
            </time>
        <span itemprop='position'>#6</span>
        </span>
      </div>
      <div class='post' itemprop='articleBody'>
        <p>[quote=“sinisoul, post:5, topic:528104”][quote author=arham 4 link=topic=646855.msg4350167#msg4350167 date=1376511022]<br>
This is Ruby or…?<br>
[/quote]</p>
<p><img src="../../images/emoji/twitter/expressionlessae52.png?v=5" title=":expressionless:" class="emoji" alt=":expressionless:"></p>
<pre><code class="lang-auto"># TODO: May not be valid to set the type in the way I have

java_import 'net.scapeemulator.game.model.World'
java_import 'net.scapeemulator.game.model.object.ObjectOrientation'
java_import 'net.scapeemulator.game.model.object.GroundObjectListenerAdapter'
java_import 'net.scapeemulator.game.model.object.ObjectType'
java_import 'net.scapeemulator.game.model.Position'
java_import 'net.scapeemulator.game.model.Door'

module RuneEmulator
	class Doors

		# The worlds object list to grab objects from
		OBJECT_LIST = World::getWorld().getGroundObjects()

		# States for if the door is opened or closed
		OPENED = 0
		CLOSED = 1

		# Each of the orientations
		ORIENTATION_ONE   = 1
		ORIENTATION_TWO   = 2
		ORIENTATION_THREE = 3
		ORIENTATION_FOUR  = 4

		# The mapping for all the single doors
		SINGLE_DOORS = {}

		# The mapping for all the doors registered
		DOORS = {}

		# The array of objects to add to the object list after a refresh
		OBJECTS = []

		class &lt;&lt; self
			def bind_door(opened_obj_id, closed_obj_id)
				DoorData.new(opened_obj_id, closed_obj_id).bind
			end

			def create_door(object)
				data = SINGLE_DOORS[object.id]

				raise "Data does not exist for door, id: #{object.id}" if data == nil

				state       = data.state(object.id)
				orientation = data.get_orientation(object.rotation, state)
				origin      = data.get_origin(object.position, object.rotation, state)

				objects = {}

				[ :opened, :closed ].each { |type|
					object = objects[type] = data.get_object(origin, orientation, type)
					OBJECTS &lt;&lt; object
				}

				SingleTileDoor.new(objects[:opened], objects[:closed]).bind
			end

			def refresh()
				OBJECT_LIST.fire_all_events(DoorObjectListener.new)

				OBJECTS.each { |object|
					object.register
				}
			end
		end

		class ObjectProxy
			attr_reader :id, :position, :rotation, :type

			def initialize(args)
				case args.size
				when 1
					@target = args[:target]
				when 4
					@id       = args[:id]
					@position = args[:position]
					@rotation = args[:rotation]
					@type     = args[:type]
				else
					raise 'Invalid constructor sent to object proxy'
				end
			end

			def register()
				if @target == nil
					@target = OBJECT_LIST.put(@position, @id, @rotation, @type)
					#@target.hide
				end
			end

			def hide()
				@target.hide
			end

			def reveal()
				@target.reveal
			end
		end

		class DoorData

			# Each of the orientations
			# Orientation One: North, Orientation Two: South, Orientation Three: East, Orientation Four: West
			ORIENTATIONS = { ORIENTATION_ONE   =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 1 }, :opened =&gt; { :x =&gt;  0, :y =&gt;  1, :rotation =&gt; 2 } }, 
			                 ORIENTATION_TWO   =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 3 }, :opened =&gt; { :x =&gt;  0, :y =&gt; -1, :rotation =&gt; 0 } }, 
			                 ORIENTATION_THREE =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 2 }, :opened =&gt; { :x =&gt;  1, :y =&gt;  0, :rotation =&gt; 3 } }, 
			                 ORIENTATION_FOUR  =&gt; { :closed =&gt; { :x =&gt; 0, :y =&gt; 0, :rotation =&gt; 0 }, :opened =&gt; { :x =&gt; -1, :y =&gt;  0, :rotation =&gt; 1 } } 
			               }

			def initialize(opened_obj_id, closed_obj_id)
				@opened_obj_id = opened_obj_id
				@closed_obj_id = closed_obj_id
			end

			def get_origin(position, rotation, state)
				delta = { :x =&gt; 0, :y =&gt; 0 }

				case state
				when OPENED
					case rotation
					when ObjectOrientation::NORTH
						delta[:x] =  1
					when ObjectOrientation::SOUTH
						delta[:x] = -1
					when ObjectOrientation::EAST
						delta[:y] = -1	
					when ObjectOrientation::WEST
						delta[:y] =  1
					end
				end

				Position.new(position.x + delta[:x], position.y + delta[:y], position.height)
			end

			def get_orientation(rotation, state)
				case state
				when OPENED				
					case rotation
					when ObjectOrientation::NORTH
						ORIENTATIONS[ORIENTATION_FOUR]
					when ObjectOrientation::SOUTH
						ORIENTATIONS[ORIENTATION_THREE]			
					when ObjectOrientation::EAST
						ORIENTATIONS[ORIENTATION_ONE]
					when ObjectOrientation::WEST
						ORIENTATIONS[ORIENTATION_TWO]
					end
				when CLOSED
					case rotation
					when ObjectOrientation::NORTH
						ORIENTATIONS[ORIENTATION_ONE]
					when ObjectOrientation::SOUTH
						ORIENTATIONS[ORIENTATION_TWO]					
					when ObjectOrientation::EAST
						ORIENTATIONS[ORIENTATION_THREE]
					when ObjectOrientation::WEST
						ORIENTATIONS[ORIENTATION_FOUR]
					end
				end
			end

			def get_object(origin, orientation, type)
				case type
				when :opened
					position = Position.new(origin.x + orientation[:opened][:x], origin.y + orientation[:opened][:y], origin.height)
					if OBJECT_LIST.contains(@opened_obj_id, position)
						args = { :target =&gt; OBJECT_LIST.get(@opened_obj_id, position) }
						ObjectProxy.new(args)
					else
						args = { :id =&gt; @opened_obj_id, :position =&gt; position, :rotation =&gt; orientation[:opened][:rotation], :type =&gt; ObjectType::TYPE_0 }
						ObjectProxy.new(args)
					end
				when :closed
					position = Position.new(origin.x + orientation[:closed][:x], origin.y + orientation[:closed][:y], origin.height)
					if OBJECT_LIST.contains(@closed_obj_id, position)
						args = { :target =&gt; OBJECT_LIST.get(@closed_obj_id, position) }
						ObjectProxy.new(args)
					else
						args = { :id =&gt; @closed_obj_id, :position =&gt; position, :rotation =&gt; orientation[:closed][:rotation], :type =&gt; ObjectType::TYPE_0 }
						ObjectProxy.new(args)
					end
				end
			end

			def state(object_id)
				{ @opened_obj_id =&gt; OPENED, @closed_obj_id =&gt; CLOSED }.fetch(object_id)
			end

			def bind()
				SINGLE_DOORS[@opened_obj_id] = self
				SINGLE_DOORS[@closed_obj_id] = self
			end
		end

		class DoubleDoorData
			def initialize(opened_ldoor_obj_id, opened_rdoor_obj_id, closed_ldoor_obj_id, closed_rdoor_obj_id)
				@opened_ldoor_obj_id = opened_ldoor_obj_id
				@opened_rdoor_obj_id = opened_rdoor_obj_id
				@closed_ldoor_obj_id = closed_ldoor_obj_id
				@closed_rdoor_obj_id = closed_rdoor_obj_id
			end

			def get_object(origin, orientation, type)
			end

			def state(object_id)
				{ @opened_ldoor_obj_id =&gt; OPENED, @opened_rdoor_obj_id =&gt; OPENED, 
			      @closed_ldoor_obj_id =&gt; CLOSED, @closed_rdoor_obj_id =&gt; CLOSED }.fetch(object_id)
			end
		end

		class GateData
			def initialize(opened_lgate_obj_id, opened_rgate_obj_id, closed_lgate_obj_id, closed_rgate_obj_id)
				@opened_lgate_obj_id = opened_lgate_obj_id
				@opened_rgate_obj_id = opened_rgate_obj_id
				@closed_lgate_obj_id = closed_lgate_obj_id
				@closed_rgate_obj_id = closed_rgate_obj_id
			end

			def get(type)
			end

			def state(object_id)
				{ @opened_lgate_obj_id =&gt; OPENED, @opened_rgate_obj_id =&gt; OPENED, 
			      @closed_lgate_obj_id =&gt; CLOSED, @closed_rgate_obj_id =&gt; CLOSED }.fetch(object_id)
			end
		end

		class SingleTileDoor &lt; Door
			def initialize(opened_door, closed_door)
				super()
				@opened_door = opened_door
				@closed_door = closed_door
			end

			def open()
				@opened_door.reveal
				@closed_door.hide
			end

			def close()
				@opened_door.hide
				@closed_door.reveal
			end

			def bind()
				DOORS[@opened_door.position] = @opened_door
				DOORS[@closed_door.position] = @closed_door
			end
		end

		class DoubleTileDoor &lt; Door
			def initialize(opened_left, opened_right, closed_left, closed_right)
				super()
				@opened_left  = opened_left
				@opened_right = opened_right
				@closed_left  = closed_left
				@closed_right = closed_right
			end

			def open()
				@opened_left.reveal
				@opened_right.reveal
				@closed_left.hide
				@closed_right.hide
			end

			def close()
				@opened_left.hide
				@opened_right.hide
				@closed_left.reveal
				@closed_right.reveal
			end

			def bind()
				DOORS[@opened_left.position]  = self
				DOORS[@opened_right.position] = self
				DOORS[@closed_left.position]  = self
				DOORS[@closed_right.position] = self
			end
		end

		class DoorObjectListener &lt; GroundObjectListenerAdapter
			def groundObjectAdded(object)
				if SINGLE_DOORS.include?(object.id)
					Doors.create_door(object)
				end
			end
		end
	end
end

RuneEmulator::Doors.bind_door(36848, 36846)
RuneEmulator::Doors.refresh()</code></pre>
<p>Heres a much CLEANER version.[/quote]<br>
Thanks for this. And I’m not guessing this is in the Ruby programming language. xD</p>
      </div>

      <meta itemprop='headline' content='Door Snippet'>

      <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
         <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
         <meta itemprop="userInteractionCount" content="0" />
         <span class='post-likes'></span>
       </div>

       <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
          <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
          <meta itemprop="userInteractionCount" content="0" />
        </div>


  </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav' itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <ul>
        <li itemprop="name"><a href='../../index.html' itemprop="url">Home </a></li>
        <li itemprop="name"><a href='../../categories.html' itemprop="url">Categories </a></li>
        <li itemprop="name"><a href='../../guidelines.html' itemprop="url">FAQ/Guidelines </a></li>
        <li itemprop="name"><a href='../../tos.html' itemprop="url">Terms of Service </a></li>
        <li itemprop="name"><a href='../../privacy.html' itemprop="url">Privacy Policy </a></li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
  </body>
  

<!-- Mirrored from forum.moparisthebest.com/t/door-snippet/528104 by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 04 Aug 2019 15:48:43 GMT -->
</html>
