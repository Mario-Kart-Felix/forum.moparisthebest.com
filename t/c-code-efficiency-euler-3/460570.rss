<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>[C] Code Efficiency (Euler #3)</title>
    <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570</link>
    <description>This is problem #3 for Project Euler (which I have just started doing) by the way. I was just wondering if there&#39;s a better algorithm to do this.

I actually originally did this in Python, but it was so horribly slow (I&#39;m not sure why exactly my code sucked ass (number too large for a list was one of them), but the program never actually completed).

[code=c]
/*
 projecteuler.net - problem three
 @author whackatre
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[])
{
	long long i, j;
	long long num = 600851475143; // 13195;
	long long lpf = 0;
	for (i = 2; i &lt; num / 2; i++)
	{
		if (num % i == 0)
		{
			int j_prime = 1;
			printf(&quot;%lld\n&quot;, i);
			for (j = 2; j &lt; i / 2; j++)
			{
				if (i % j == 0)
				{
					j_prime = 0;
					break;
				}
			}
			if (j_prime)
			{
				lpf = i;
			}
			else
			{
				break;
			}
		}
	}
	printf(&quot;Largest Prime Factor: %lld\n&quot;, lpf);
	return 0;
}
[/code]

The process time was less than one second.

Original Question:
&lt;blockquote&gt;The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?&lt;/blockquote&gt;

Any ideas?</description>
    
    <lastBuildDate>Tue, 25 Sep 2012 18:44:31 +0000</lastBuildDate>
    <category>General Programming</category>
    <atom:link href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <p>Here is my superior prime sieve, written in the superior C++ language.</p>
<pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

std::vector&lt;unsigned int&gt; primeSieve(const unsigned int n)
{
	std::vector&lt;unsigned int&gt; primes;
	std::vector&lt;bool&gt; sieve(n, true);

	for (unsigned int i = 2; i &lt; n; ++i)
	{
		if (sieve[i])
		{
			for (std::size_t j = i * i; j &lt; n; j += i)
			{
				sieve[j] = false;
			}

			primes.push_back(i);
		}
	}

	return primes;
}

int main()
{
	std::cout &lt;&lt; "The superior C++ Eratothenes sieve - created by The Enforcer (REAL SUPERIOR GUY)." &lt;&lt; std::endl;

	const std::clock_t startClocks = std::clock();
	const std::vector&lt;unsigned int&gt; primes = primeSieve(200000000);
	const std::clock_t clocksTaken = std::clock() - startClocks;
	std::cout &lt;&lt; "Size: " &lt;&lt; primes.size() &lt;&lt; "." &lt;&lt; std::endl;
	std::cout &lt;&lt; "Clocks taken: " &lt;&lt; clocksTaken &lt;&lt; "." &lt;&lt; std::endl;

	std::cin.sync();
	std::cin.get();
	return EXIT_SUCCESS;
}</code></pre>
<p>As you can see my code is extremely superior since I myself am extremely superior. Furthermore, for the sieve I’m using the superior std::vector specialization which is actually a dynamic bitset. It not only consumes eight times less memory, but it also outperforms a raw byte/bool array by a factor of 1.5. Hold on, this is not all. My sieve also returns a vector of primes instead of returning a sieve. Returning the sieve itself would be nonsense, customers want primes - not a sieve of primes (unless the goal is to look up integers for primality). Let’s be honest, SUPERIOR.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/23">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/23</link>
        <pubDate>Tue, 25 Sep 2012 18:44:31 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-23</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“The Enforcer, post:21, topic:460570”][quote author=t4 link=topic=563500.msg4110964#msg4110964 date=1348516829]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>Replace this line</p>
<pre><code class="lang-auto"></code></pre>
<p>with the following superior line.</p>
<pre><code class="lang-auto"></code></pre>
</blockquote>
</aside>
<p>Uh, that’s not how the sieve works…</p>
</blockquote>
</aside>
<p>No. You’re starting from 2 * i which is not optimal, it’s safe to start from i². Furthermore, you perform two arithmetic operations every step to calculate comp, instead of one.</p>
</blockquote>
</aside>
<p>I saw nothing stating that starting at i^2 was allowed. The basic algorithm states you should multiply each integer from 2 to n by 2, 3, … to the square of n.<br>
[/quote]</p>
<p><aside class="onebox wikipedia">
  <header class="source">
      <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="nofollow noopener">en.wikipedia.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:445/369;"><img src="//upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" class="thumbnail"></div>

<h3><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="nofollow noopener">Sieve of Eratosthenes</a></h3>

<p>In mathematics, the sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime. This is the sieve's key distinction from using trial division to sequentially...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<span class="bbcode-b">As a refinement, it is sufficient to mark the numbers in step 3 starting from p², as all the smaller multiples of p will have already been marked at that point.</span>[/quote]<br>
fair enough <img src="https://forum.moparisthebest.com/images/emoji/twitter/slight_smile.png?v=5" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/22">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/22</link>
        <pubDate>Mon, 24 Sep 2012 20:37:09 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-22</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:19, topic:460570”][quote author=The Enforcer link=topic=563500.msg4110883#msg4110883 date=1348507466]</p>
<aside class="quote">
<blockquote>
<aside class="quote">
<blockquote>
<p>Replace this line</p>
<pre><code class="lang-auto"></code></pre>
<p>with the following superior line.</p>
<pre><code class="lang-auto"></code></pre>
</blockquote>
</aside>
<p>Uh, that’s not how the sieve works…</p>
</blockquote>
</aside>
<p>No. You’re starting from 2 * i which is not optimal, it’s safe to start from i². Furthermore, you perform two arithmetic operations every step to calculate comp, instead of one.<br>
[/quote]<br>
I saw nothing stating that starting at i^2 was allowed. The basic algorithm states you should multiply each integer from 2 to n by 2, 3, … to the square of n.[/quote]</p>
<p><aside class="onebox wikipedia">
  <header class="source">
      <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="nofollow noopener">en.wikipedia.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:445/369;"><img src="//upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" class="thumbnail"></div>

<h3><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="nofollow noopener">Sieve of Eratosthenes</a></h3>

<p>In mathematics, the sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime. This is the sieve's key distinction from using trial division to sequentially...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<span class="bbcode-b">As a refinement, it is sufficient to mark the numbers in step 3 starting from p², as all the smaller multiples of p will have already been marked at that point.</span></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/21">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/21</link>
        <pubDate>Mon, 24 Sep 2012 20:18:04 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-21</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@_bool]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_bool">@_bool</a> wrote:</p>
          <blockquote>
              <aside class="onebox wikipedia">
  <header class="source">
      <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="nofollow noopener">en.wikipedia.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:445/369;"><img src="//upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" class="thumbnail"></div>

<h3><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="nofollow noopener">Sieve of Eratosthenes</a></h3>

<p>In mathematics, the sieve of Eratosthenes is a simple, ancient algorithm for finding all prime numbers up to any given limit. It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime, with constant difference between them that is equal to that prime. This is the sieve's key distinction from using trial division to sequentially...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>“As a refinement, it is sufficient to mark the numbers in step 3 starting from p^2, as all the smaller multiples of p will have already been marked at that point.”</p>
<p>man, this whole reading thing is rlly tough</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/20">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/20</link>
        <pubDate>Mon, 24 Sep 2012 20:14:24 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-20</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“The Enforcer, post:18, topic:460570”][quote author=t4 link=topic=563500.msg4110872#msg4110872 date=1348506698]</p>
<aside class="quote">
<blockquote>
<p>Replace this line</p>
<pre><code class="lang-auto"></code></pre>
<p>with the following superior line.</p>
<pre><code class="lang-auto"></code></pre>
</blockquote>
</aside>
<p>Uh, that’s not how the sieve works…<br>
[/quote]</p>
<p>No. You’re starting from 2 * i which is not optimal, it’s safe to start from i². Furthermore, you perform two arithmetic operations every step to calculate comp, instead of one.[/quote]<br>
I saw nothing stating that starting at i^2 was allowed. The basic algorithm states you should multiply each integer from 2 to n by 2, 3, … to the square of n.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/19">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/19</link>
        <pubDate>Mon, 24 Sep 2012 20:00:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-19</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:17, topic:460570”][quote author=The Enforcer link=topic=563500.msg4110862#msg4110862 date=1348504409]<br>
Replace this line</p>
<pre><code class="lang-auto"></code></pre>
<p>with the following superior line.</p>
<pre><code class="lang-auto"></code></pre>
<p>[/quote]<br>
Uh, that’s not how the sieve works…[/quote]</p>
<p>No. You’re starting from 2 * i which is not optimal, it’s safe to start from i². Furthermore, you perform two arithmetic operations every step to calculate comp, instead of one.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/18">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/18</link>
        <pubDate>Mon, 24 Sep 2012 17:24:26 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-18</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“The Enforcer, post:16, topic:460570”]Replace this line</p>
<pre><code class="lang-auto"></code></pre>
<p>with the following superior line.</p>
<pre><code class="lang-auto"></code></pre>
<p>Uh, that’s not how the sieve works…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/17">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/17</link>
        <pubDate>Mon, 24 Sep 2012 17:11:38 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-17</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:13, topic:460570”]I messed around a bit and I ended up doing the following. It’s pretty fast - I tested dumping all primes up to 2.2 billion; it took around 40 seconds to generate and pipe to a file. The numbers were accurate too. Obviously, this implementation is only good up to the limit of uint64.</p>
<p>Here is a Sieve of Eratosthenes implementation:</p>
<pre><code class="lang-auto">/**
  primegen.c
  Author: t4
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

#include "eratosthenes.h"

int main(int argc, char* argv[]) {
  uint64_t n = strtoq(argv[1], NULL, 10);
  eratosthenes_mem* mem = eratosthenes_sieve(n);
  for(uint64_t i = 2; i &lt; n; ++i) {
    if(mem[i]) {
      printf("%" PRIu64 " ", i);
    }
  }
  printf("\n");
  free(mem);
  return 0;
}</code></pre>
<pre><code class="lang-auto">/**
  eratosthenes.c
  Author: t4
*/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;math.h&gt;

#include "eratosthenes.h"

eratosthenes_mem* eratosthenes_sieve(uint64_t n) {
  eratosthenes_mem* m = (eratosthenes_mem*) malloc(n * sizeof(eratosthenes_mem));
  memset(m, 1, n * sizeof(eratosthenes_mem));

  uint64_t limit = sqrt((long double) n);

  for(uint64_t i = 2; i &lt; limit; ++i) {
    if(m[i]) {
      uint64_t comp;
      for(int mult = 2; (comp = mult * i) &lt; n; ++mult) {
        m[comp] = 0;
      }
    }
  }
  return m;
}

int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i) {
  return m[i] == 1;
}</code></pre>
<p>[code=c]<br>
/**<br>
eratosthenes.h<br>
Author: t4<br>
*/</p>
<p><span class="hashtag">#include</span> &lt;stdint.h&gt;</p>
<p><span class="hashtag">#ifndef</span> ERATOSTHENES_H<br>
<span class="hashtag">#define</span> ERATOSTHENES_H</p>
<p>typedef char eratosthenes_mem;</p>
<p>eratosthenes_mem* eratosthenes_sieve(uint64_t n);</p>
<p>int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i);</p>
<p><span class="hashtag">#endif</span><br>
[/code][/quote]</p>
<p>Replace this line</p>
<pre><code class="lang-auto"></code></pre>
<p>with the following superior line.</p>
<pre><code class="lang-auto"></code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/16</link>
        <pubDate>Mon, 24 Sep 2012 16:33:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-16</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>[quote=“s1gma, post:14, topic:460570”][quote author=t4 link=topic=563500.msg4110407#msg4110407 date=1348447874]<br>
I messed around a bit and I ended up doing the following. It’s pretty fast - I tested dumping all primes up to 2.2 billion; it took around 40 seconds to generate and pipe to a file. The numbers were accurate too. Obviously, this implementation is only good up to the limit of uint64.</p>
<p>Here is a Sieve of Eratosthenes implementation:</p>
<pre><code class="lang-auto">/**
  primegen.c
  Author: t4
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

#include "eratosthenes.h"

int main(int argc, char* argv[]) {
  uint64_t n = strtoq(argv[1], NULL, 10);
  eratosthenes_mem* mem = eratosthenes_sieve(n);
  for(uint64_t i = 2; i &lt; n; ++i) {
    if(mem[i]) {
      printf("%" PRIu64 " ", i);
    }
  }
  printf("\n");
  free(mem);
  return 0;
}</code></pre>
<pre><code class="lang-auto">/**
  eratosthenes.c
  Author: t4
*/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;math.h&gt;

#include "eratosthenes.h"

eratosthenes_mem* eratosthenes_sieve(uint64_t n) {
  eratosthenes_mem* m = (eratosthenes_mem*) malloc(n * sizeof(eratosthenes_mem));
  memset(m, 1, n * sizeof(eratosthenes_mem));

  uint64_t limit = sqrt((long double) n);

  for(uint64_t i = 2; i &lt; limit; ++i) {
    if(m[i]) {
      uint64_t comp;
      for(int mult = 2; (comp = mult * i) &lt; n; ++mult) {
        m[comp] = 0;
      }
    }
  }
  return m;
}

int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i) {
  return m[i] == 1;
}</code></pre>
<pre><code class="lang-auto">/**
  eratosthenes.h
  Author: t4
*/

#include &lt;stdint.h&gt;

#ifndef ERATOSTHENES_H
#define ERATOSTHENES_H 

typedef char eratosthenes_mem;

eratosthenes_mem* eratosthenes_sieve(uint64_t n);

int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i);

#endif</code></pre>
<p>[/quote]<a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin" data-bbcode="true" rel="nofollow noopener">cool now make it even faster</a>[/quote]</p>
<pre><code class="lang-auto">$ ls src/
atkin.c  atkin.h  eratosthenes.c  eratosthenes.h  primegen.c</code></pre>
<p>I was doing both, atkin isn’t done yet.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/15</link>
        <pubDate>Mon, 24 Sep 2012 12:36:52 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-15</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@_s11 s1gma]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_s11">@_s11</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:13, topic:460570”]I messed around a bit and I ended up doing the following. It’s pretty fast - I tested dumping all primes up to 2.2 billion; it took around 40 seconds to generate and pipe to a file. The numbers were accurate too. Obviously, this implementation is only good up to the limit of uint64.</p>
<p>Here is a Sieve of Eratosthenes implementation:</p>
<pre><code class="lang-auto">/**
  primegen.c
  Author: t4
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

#include "eratosthenes.h"

int main(int argc, char* argv[]) {
  uint64_t n = strtoq(argv[1], NULL, 10);
  eratosthenes_mem* mem = eratosthenes_sieve(n);
  for(uint64_t i = 2; i &lt; n; ++i) {
    if(mem[i]) {
      printf("%" PRIu64 " ", i);
    }
  }
  printf("\n");
  free(mem);
  return 0;
}</code></pre>
<pre><code class="lang-auto">/**
  eratosthenes.c
  Author: t4
*/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;math.h&gt;

#include "eratosthenes.h"

eratosthenes_mem* eratosthenes_sieve(uint64_t n) {
  eratosthenes_mem* m = (eratosthenes_mem*) malloc(n * sizeof(eratosthenes_mem));
  memset(m, 1, n * sizeof(eratosthenes_mem));

  uint64_t limit = sqrt((long double) n);

  for(uint64_t i = 2; i &lt; limit; ++i) {
    if(m[i]) {
      uint64_t comp;
      for(int mult = 2; (comp = mult * i) &lt; n; ++mult) {
        m[comp] = 0;
      }
    }
  }
  return m;
}

int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i) {
  return m[i] == 1;
}</code></pre>
<p>[code=c]<br>
/**<br>
eratosthenes.h<br>
Author: t4<br>
*/</p>
<p><span class="hashtag">#include</span> &lt;stdint.h&gt;</p>
<p><span class="hashtag">#ifndef</span> ERATOSTHENES_H<br>
<span class="hashtag">#define</span> ERATOSTHENES_H</p>
<p>typedef char eratosthenes_mem;</p>
<p>eratosthenes_mem* eratosthenes_sieve(uint64_t n);</p>
<p>int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i);</p>
<p><span class="hashtag">#endif</span><br>
[/code][/quote]<a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin" data-bbcode="true" rel="nofollow noopener">cool now make it even faster</a></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/14</link>
        <pubDate>Mon, 24 Sep 2012 06:06:17 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-14</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>I messed around a bit and I ended up doing the following. It’s pretty fast - I tested dumping all primes up to 2.2 billion; it took around 40 seconds to generate and pipe to a file. The numbers were accurate too. Obviously, this implementation is only good up to the limit of uint64.</p>
<p>Here is a Sieve of Eratosthenes implementation:</p>
<pre><code class="lang-auto">/**
  primegen.c
  Author: t4
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

#include "eratosthenes.h"

int main(int argc, char* argv[]) {
  uint64_t n = strtoq(argv[1], NULL, 10);
  eratosthenes_mem* mem = eratosthenes_sieve(n);
  for(uint64_t i = 2; i &lt; n; ++i) {
    if(mem[i]) {
      printf("%" PRIu64 " ", i);
    }
  }
  printf("\n");
  free(mem);
  return 0;
}</code></pre>
<pre><code class="lang-auto">/**
  eratosthenes.c
  Author: t4
*/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;math.h&gt;

#include "eratosthenes.h"

eratosthenes_mem* eratosthenes_sieve(uint64_t n) {
  eratosthenes_mem* m = (eratosthenes_mem*) malloc(n * sizeof(eratosthenes_mem));
  memset(m, 1, n * sizeof(eratosthenes_mem));

  uint64_t limit = sqrt((long double) n);

  for(uint64_t i = 2; i &lt; limit; ++i) {
    if(m[i]) {
      uint64_t comp;
      for(int mult = 2; (comp = mult * i) &lt; n; ++mult) {
        m[comp] = 0;
      }
    }
  }
  return m;
}

int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i) {
  return m[i] == 1;
}</code></pre>
<pre><code class="lang-auto">/**
  eratosthenes.h
  Author: t4
*/

#include &lt;stdint.h&gt;

#ifndef ERATOSTHENES_H
#define ERATOSTHENES_H 

typedef char eratosthenes_mem;

eratosthenes_mem* eratosthenes_sieve(uint64_t n);

int8_t is_eratosthenes_prime(eratosthenes_mem* m, uint64_t i);

#endif</code></pre>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/13</link>
        <pubDate>Mon, 24 Sep 2012 00:51:14 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-13</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <p>[quote=“s1gma, post:10, topic:460570”][quote author=The Enforcer link=topic=563500.msg4108741#msg4108741 date=1348320717]</p>
<aside class="quote">
<blockquote>
<p>edit: why is that volatile there?</p>
</blockquote>
</aside>
<p>VC++ decided to optimize away the ‘factor’ variable and move the function call to the second std::cout statement.<br>
[/quote]what a dick[/quote]</p>
<aside class="quote quote-modified" data-post="11" data-topic="460570">
<div class="title">
<div class="quote-controls"></div>
 t4:</div>
<blockquote>
<p>guess you shouldn’t be using VStudio…</p>
</blockquote>
</aside>
<p>It’s a valid optimization. If the function largestPrimeFactor had any external side effects or if there was a dependency on the ‘factor’ variable, then the function call would not be moved forward. The variable was made volatile for timing purposes only.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/12</link>
        <pubDate>Sat, 22 Sep 2012 16:01:10 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-12</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>guess you shouldn’t be using VStudio…</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/11</link>
        <pubDate>Sat, 22 Sep 2012 15:02:48 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-11</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@_s11 s1gma]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_s11">@_s11</a> wrote:</p>
          <blockquote>
              <p>[quote=“The Enforcer, post:9, topic:460570”][quote author=s1gma link=topic=563500.msg4108733#msg4108733 date=1348319990]<br>
edit: why is that volatile there?<br>
[/quote]</p>
<p>VC++ decided to optimize away the ‘factor’ variable and move the function call to the second std::cout statement.[/quote]what a dick</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/10</link>
        <pubDate>Sat, 22 Sep 2012 14:47:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-10</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <aside class="quote" data-post="8" data-topic="460570">
<div class="title">
<div class="quote-controls"></div>
 s1gma:</div>
<blockquote>
<p>edit: why is that volatile there?</p>
</blockquote>
</aside>
<p>VC++ decided to optimize away the ‘factor’ variable and move the function call to the second std::cout statement.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/9</link>
        <pubDate>Sat, 22 Sep 2012 13:31:57 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-9</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@_s11 s1gma]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_s11">@_s11</a> wrote:</p>
          <blockquote>
              <p>[quote=“The Enforcer, post:7, topic:460570”]Here is my superior factorizer, written in the superior C++ language.</p>
<p><a href="http://pastie.org/4760370" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/4760370</a></p>
<pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;

unsigned long long largestPrimeFactor(unsigned long long integer)
{
	for (bool factorize = true; factorize &amp;&amp; integer &gt; 3; )
	{
		factorize = false;

		if (integer % 2 == 0)
		{
			integer /= 2;
			factorize = true;
		}
		else if (integer % 3 == 0)
		{
			integer /= 3;
			factorize = true;
		}
		else
		{
			const unsigned long long sqrt = static_cast&lt;unsigned long long&gt;(std::sqrt(integer));

			for (unsigned long long i = 5, j = 7; i &lt;= sqrt; i += 6, j += 6)
			{
				if (integer % i == 0)
				{
					integer /= i;
					factorize = true;
					break;
				}
				else if (integer % j == 0)
				{
					integer /= j;
					factorize = true;
					break;
				}
			}
		}
	}

	return integer;
}

void benchmark(const unsigned long long integer)
{
	std::cout &lt;&lt; "Factorizing: " &lt;&lt; integer &lt;&lt; "." &lt;&lt; std::endl;
	const std::clock_t startClocks = std::clock();
	volatile const unsigned long long factor = largestPrimeFactor(integer);
	const std::clock_t clocksTaken = std::clock() - startClocks;
	std::cout &lt;&lt; "Factor: " &lt;&lt; factor &lt;&lt; "." &lt;&lt; std::endl;
	std::cout &lt;&lt; "Clocks taken: " &lt;&lt; clocksTaken &lt;&lt; ".\n" &lt;&lt; std::endl;
}

int main()
{
	const unsigned long long a = 3267000013;
	const unsigned long long b = 5463458053;
	const unsigned long long c = a * b;
	benchmark(600851475143);
	benchmark(c);

	std::cin.sync();
	std::cin.get();
	return EXIT_SUCCESS;
}</code></pre>
<pre><code class="lang-auto">Factorizing: 600851475143.
Factor: 6857.
Clocks taken: 0.

Factorizing: 17849117530175954689.
Factor: 5463458053.
Clocks taken: 5457.</code></pre>
<p>Note: This is probably as fast as trial division can get.[/quote]<br>
jesus christ that’s verbose… <span class="hashtag">#include</span>  because you wrote ‘unsigned long long’ approximately 100 times.</p>
<p>edit: why is that volatile there?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/8</link>
        <pubDate>Sat, 22 Sep 2012 13:19:50 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-8</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <p>Here is my superior factorizer, written in the superior C++ language.</p>
<p><a href="http://pastie.org/4760370" class="onebox" target="_blank" rel="nofollow noopener">http://pastie.org/4760370</a></p>
<pre><code class="lang-auto">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;

unsigned long long largestPrimeFactor(unsigned long long integer)
{
	for (bool factorize = true; factorize &amp;&amp; integer &gt; 3; )
	{
		factorize = false;

		if (integer % 2 == 0)
		{
			integer /= 2;
			factorize = true;
		}
		else if (integer % 3 == 0)
		{
			integer /= 3;
			factorize = true;
		}
		else
		{
			const unsigned long long sqrt = static_cast&lt;unsigned long long&gt;(std::sqrt(integer));

			for (unsigned long long i = 5, j = 7; i &lt;= sqrt; i += 6, j += 6)
			{
				if (integer % i == 0)
				{
					integer /= i;
					factorize = true;
					break;
				}
				else if (integer % j == 0)
				{
					integer /= j;
					factorize = true;
					break;
				}
			}
		}
	}

	return integer;
}

void benchmark(const unsigned long long integer)
{
	std::cout &lt;&lt; "Factorizing: " &lt;&lt; integer &lt;&lt; "." &lt;&lt; std::endl;
	const std::clock_t startClocks = std::clock();
	volatile const unsigned long long factor = largestPrimeFactor(integer);
	const std::clock_t clocksTaken = std::clock() - startClocks;
	std::cout &lt;&lt; "Factor: " &lt;&lt; factor &lt;&lt; "." &lt;&lt; std::endl;
	std::cout &lt;&lt; "Clocks taken: " &lt;&lt; clocksTaken &lt;&lt; ".\n" &lt;&lt; std::endl;
}

int main()
{
	const unsigned long long a = 3267000013;
	const unsigned long long b = 5463458053;
	const unsigned long long c = a * b;
	benchmark(600851475143);
	benchmark(c);

	std::cin.sync();
	std::cin.get();
	return EXIT_SUCCESS;
}</code></pre>
<pre><code class="lang-auto">Factorizing: 600851475143.
Factor: 6857.
Clocks taken: 0.

Factorizing: 17849117530175954689.
Factor: 5463458053.
Clocks taken: 5457.</code></pre>
<p>Note: This is probably as fast as trial division can get.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/7</link>
        <pubDate>Thu, 20 Sep 2012 14:12:56 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-7</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@_bool]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_bool">@_bool</a> wrote:</p>
          <blockquote>
              <aside class="quote quote-modified" data-post="5" data-topic="460570">
<div class="title">
<div class="quote-controls"></div>
 The Enforcer:</div>
<blockquote>
<p>The stdint.h typedefs are useful when you need exact bit-width or don’t want to consume unneeded bits. However, in this case it doesn’t matter at all - long long is the largest integer type and it makes sense to use it incase larger integers are to be factored. Although, an unsigned long long would make more sense.</p>
</blockquote>
</aside>
<p>hence “(in this case)”</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/6</link>
        <pubDate>Wed, 19 Sep 2012 21:34:20 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-6</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@The_Enforcer The Enforcer]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/the_enforcer">@The_Enforcer</a> wrote:</p>
          <blockquote>
              <p>[quote=“Whackatre, post:1, topic:460570”]This is problem <span class="hashtag">#3</span> for Project Euler (which I have just started doing) by the way. I was just wondering if there’s a better algorithm to do this.</p>
<p>I actually originally did this in Python, but it was so horribly slow (I’m not sure why exactly my code sucked ass (number too large for a list was one of them), but the program never actually completed).</p>
<pre><code class="lang-auto">/*
 projecteuler.net - problem three
 @author whackatre
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[])
{
	long long i, j;
	long long num = 600851475143; // 13195;
	long long lpf = 0;
	for (i = 2; i &lt; num / 2; i++)
	{
		if (num % i == 0)
		{
			int j_prime = 1;
			printf("%lld\n", i);
			for (j = 2; j &lt; i / 2; j++)
			{
				if (i % j == 0)
				{
					j_prime = 0;
					break;
				}
			}
			if (j_prime)
			{
				lpf = i;
			}
			else
			{
				break;
			}
		}
	}
	printf("Largest Prime Factor: %lld\n", lpf);
	return 0;
}</code></pre>
<p>The process time was less than one second.</p>
<p>Original Question:</p>
<aside class="quote">
<blockquote>
<p>The prime factors of 13195 are 5, 7, 13 and 29.</p>
<p>What is the largest prime factor of the number 600851475143 ?</p>
</blockquote>
</aside>
<p>Any ideas?[/quote]<br>
Your algorithm is flawed, it doesn’t do what it should do - so it’s wrong to even judge its efficiency. Try the inputs 19 and 152. Figure out yourself what you did wrong.</p>
<p>[quote="(Anthony), post:4, topic:460570"][quote author=t4 link=topic=563500.msg4106580#msg4106580 date=1348060434]<br>
Here are a few algorithms for generating primes:<br>
<a href="http://en.wikibooks.org/wiki/Efficient_Prime_Number_Generating_Algorithms" class="onebox" target="_blank" rel="nofollow noopener">http://en.wikibooks.org/wiki/Efficient_Prime_Number_Generating_Algorithms</a></p>
<p>Protip:<br>
Don’t use raw primitive type names (short, int, long, long long, etc) as they may be of difference size on different systems. The most portable thing to do (and proper) is to use stdint.h (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html" rel="nofollow noopener">http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html</a>)<br>
[/quote]<br>
the size of the data type is irrelevant (in this case), the standard clearly defines the range a data type must accommodate.</p>
<p>edit: it should be noted that the standard defines range in terms of the minimum range.[/quote]<br>
The stdint.h typedefs are useful when you need exact bit-width or don’t want to consume unneeded bits. However, in this case it doesn’t matter at all - long long is the largest integer type and it makes sense to use it incase larger integers are to be factored. Although, an unsigned long long would make more sense.</p>
<aside class="quote quote-modified" data-post="3" data-topic="460570">
<div class="title">
<div class="quote-controls"></div>
 Taharok:</div>
<blockquote>
<p>Also, a more straightforward way to iteratively build a table of primes is to list all primes before the sqrt(n) for any integer n, and then check whether any prime in that table divides n. You can do that in a single loop. As far as the expensive sqrt goes, there are very fast integer-based sqrts you can find on the internet. Next is finding all primes &lt;= sqrt(n). It’s easy to weed out about half while checking for modulo of 2 for even numbers, but it may take a bit of creativity for finding the rest quickly. sqrt(600851475143) is definitely not a small number, lol. <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
</blockquote>
</aside>
<p>There are efficient prime number sieves for generating primes in the range [a; b]. If the task is to simply factorize an integer using trial division, pregenerating primes will do more harm than good. Have a go with <span class="bbcode-b">17849117530175954689</span>.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/5</link>
        <pubDate>Wed, 19 Sep 2012 21:30:58 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-5</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@_bool]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/_bool">@_bool</a> wrote:</p>
          <blockquote>
              <p>[quote=“t4, post:2, topic:460570”]Here are a few algorithms for generating primes:<br>
<a href="http://en.wikibooks.org/wiki/Efficient_Prime_Number_Generating_Algorithms" class="onebox" target="_blank" rel="nofollow noopener">http://en.wikibooks.org/wiki/Efficient_Prime_Number_Generating_Algorithms</a></p>
<p>Protip:<br>
Don’t use raw primitive type names (short, int, long, long long, etc) as they may be of difference size on different systems. The most portable thing to do (and proper) is to use stdint.h (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html" rel="nofollow noopener">http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html</a>)[/quote]<br>
the size of the data type is irrelevant (in this case), the standard clearly defines the range a data type must accommodate.</p>
<p>edit: it should be noted that the standard defines range in terms of the minimum range.</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/4</link>
        <pubDate>Wed, 19 Sep 2012 20:36:16 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-4</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@mod_taharok Taharok]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/mod_taharok">@mod_taharok</a> wrote:</p>
          <blockquote>
              <p>Also, a more straightforward way to iteratively build a table of primes is to list all primes before the sqrt(n) for any integer n, and then check whether any prime in that table divides n. You can do that in a single loop. As far as the expensive sqrt goes, there are very fast integer-based sqrts you can find on the internet. Next is finding all primes &lt;= sqrt(n). It’s easy to weed out about half while checking for modulo of 2 for even numbers, but it may take a bit of creativity for finding the rest quickly. sqrt(600851475143) is definitely not a small number, lol. <img src="https://forum.moparisthebest.com/images/emoji/twitter/stuck_out_tongue.png?v=5" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/3</link>
        <pubDate>Wed, 19 Sep 2012 14:33:29 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-3</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@T41 t4]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/t41">@T41</a> wrote:</p>
          <blockquote>
              <p>Here are a few algorithms for generating primes:<br>
<a href="http://en.wikibooks.org/wiki/Efficient_Prime_Number_Generating_Algorithms" class="onebox" target="_blank" rel="nofollow noopener">http://en.wikibooks.org/wiki/Efficient_Prime_Number_Generating_Algorithms</a></p>
<p>Protip:<br>
Don’t use raw primitive type names (short, int, long, long long, etc) as they may be of difference size on different systems. The most portable thing to do (and proper) is to use stdint.h (<a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html" rel="nofollow noopener">http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html</a>)</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/2</link>
        <pubDate>Wed, 19 Sep 2012 13:13:54 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-2</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
      <item>
        <title>[C] Code Efficiency (Euler #3)</title>
        <dc:creator><![CDATA[@whackatre Whackatre]]></dc:creator>
        <description><![CDATA[
          <p><a href="https://forum.moparisthebest.com/u/whackatre">@whackatre</a> wrote:</p>
          <blockquote>
              <p>This is problem <span class="hashtag">#3</span> for Project Euler (which I have just started doing) by the way. I was just wondering if there’s a better algorithm to do this.</p>
<p>I actually originally did this in Python, but it was so horribly slow (I’m not sure why exactly my code sucked ass (number too large for a list was one of them), but the program never actually completed).</p>
<pre><code class="lang-auto">/*
 projecteuler.net - problem three
 @author whackatre
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[])
{
	long long i, j;
	long long num = 600851475143; // 13195;
	long long lpf = 0;
	for (i = 2; i &lt; num / 2; i++)
	{
		if (num % i == 0)
		{
			int j_prime = 1;
			printf("%lld\n", i);
			for (j = 2; j &lt; i / 2; j++)
			{
				if (i % j == 0)
				{
					j_prime = 0;
					break;
				}
			}
			if (j_prime)
			{
				lpf = i;
			}
			else
			{
				break;
			}
		}
	}
	printf("Largest Prime Factor: %lld\n", lpf);
	return 0;
}</code></pre>
<p>The process time was less than one second.</p>
<p>Original Question:</p>
<blockquote>The prime factors of 13195 are 5, 7, 13 and 29.
<p>What is the largest prime factor of the number 600851475143 ?</p>
</blockquote>
<p>Any ideas?</p>
          </blockquote>
          <p><a href="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570/1</link>
        <pubDate>Wed, 19 Sep 2012 07:14:05 +0000</pubDate>
        <guid isPermaLink="false">forum.moparisthebest.com-post-460570-1</guid>
        <source url="https://forum.moparisthebest.com/t/c-code-efficiency-euler-3/460570.rss">[C] Code Efficiency (Euler #3)</source>
      </item>
  </channel>
</rss>
